diff -r 68f95e015346 usr/src/grub/patches/0000-Makefile.extra-dist.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0000-Makefile.extra-dist.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,15 @@
+# Source: Upstream
+# Info: Fixes build failure due to the extra_deps.lst file not existing in the
+# tarball. Found while trying to package GRUB 2.12 for Gentoo.
+diff --git a/conf/Makefile.extra-dist b/conf/Makefile.extra-dist
+index 5e7126f98..0bef2c752 100644
+--- a/conf/Makefile.extra-dist
++++ b/conf/Makefile.extra-dist
+@@ -27,6 +27,7 @@ EXTRA_DIST += grub-core/gensyminfo.sh.in
+ EXTRA_DIST += grub-core/gensymlist.sh
+ EXTRA_DIST += grub-core/genemuinit.sh
+ EXTRA_DIST += grub-core/genemuinitheader.sh
++EXTRA_DIST += grub-core/extra_deps.lst
+ 
+ EXTRA_DIST += grub-core/lib/gnulib-patches/fix-width.patch
+ 
diff -r 68f95e015346 usr/src/grub/patches/0001-autogen.sh.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0001-autogen.sh.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,32 @@
+# Source: Local
+# Patch autogen so we can run it during nightly:
+# Add GNU to path, don't mess with contrib, and force the mv
+--- old/./autogen.sh	2024-05-09 08:15:20.377529225 -0700
++++ new/./autogen.sh	2024-07-26 10:24:37.840622341 -0700
+@@ -26,6 +26,8 @@
+ export LC_COLLATE=C
+ unset LC_ALL
+ 
++export PATH=/usr/gnu/bin:$PATH
++
+ find . -iname '*.[ch]' ! -ipath './grub-core/lib/libgcrypt-grub/*' ! -ipath './build-aux/*' ! -ipath './grub-core/lib/libgcrypt/src/misc.c' ! -ipath './grub-core/lib/libgcrypt/src/global.c' ! -ipath './grub-core/lib/libgcrypt/src/secmem.c'  ! -ipath './util/grub-gen-widthspec.c' ! -ipath './util/grub-gen-asciih.c' ! -ipath './gnulib/*' ! -ipath './grub-core/lib/gnulib/*' |sort > po/POTFILES.in
+ find util -iname '*.in' ! -name Makefile.in  |sort > po/POTFILES-shell.in
+ 
+@@ -54,7 +56,7 @@
+ echo "Generating Automake input..."
+ 
+ # Automake doesn't like including files from a path outside the project.
+-rm -f contrib grub-core/contrib
++#rm -f contrib grub-core/contrib
+ if [ "x${GRUB_CONTRIB}" != x ]; then
+   [ "${GRUB_CONTRIB}" = contrib ] || ln -s "${GRUB_CONTRIB}" contrib
+   [ "${GRUB_CONTRIB}" = grub-core/contrib ] || ln -s ../contrib grub-core/contrib
+@@ -110,7 +112,7 @@
+   echo "Running autoreconf..."
+   cp -a INSTALL INSTALL.grub
+   autoreconf -vif
+-  mv INSTALL.grub INSTALL
++  mv -f INSTALL.grub INSTALL
+ fi
+ 
+ exit 0
diff -r 68f95e015346 usr/src/grub/patches/0002-acinclude.m4.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0002-acinclude.m4.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,85 @@
+# Source: Local, carried from 1.99
+# Definitions for configure to use Solaris linker
+--- old/./acinclude.m4	2024-03-07 16:25:49.992014319 +0000
++++ new/./acinclude.m4	2024-03-07 16:25:49.074004263 +0000
+@@ -34,6 +34,20 @@
+ ])
+ 
+ 
++dnl Check whether target compiler uses gas as its assembler
++AC_DEFUN([grub_PROG_TARGET_CC_USES_GAS],
++[AC_MSG_CHECKING([whether target compiler uses gas as its assembler])
++AC_CACHE_VAL(grub_cv_prog_target_cc_uses_gas,
++[AC_LINK_IFELSE([AC_LANG_PROGRAM([[
++asm (".code16; .globl start; .type start, \"function\"; start:");
++int main (void);
++]], [[]])],
++  		[grub_cv_prog_target_cc_uses_gas=yes],
++		[grub_cv_prog_target_cc_uses_gas=no])
++])
++AC_MSG_RESULT([$grub_cv_prog_target_cc_uses_gas])
++])
++
+ dnl grub_ASM_USCORE checks if C symbols get an underscore after
+ dnl compiling to assembler.
+ dnl Written by Pavel Roskin. Based on grub_ASM_EXT_C written by
+@@ -93,14 +107,30 @@
+ fi
+ grub_cv_prog_objcopy_absolute=yes
+ for link_addr in 0x2000 0x8000 0x7C00; do
+-  if AC_TRY_COMMAND([${CC-cc} ${TARGET_CFLAGS} ${TARGET_LDFLAGS} -nostdlib ${TARGET_IMG_LDFLAGS_AC} ${TARGET_IMG_BASE_LDOPT},$link_addr conftest.o -o conftest.exec]); then :
++
++  if test x$grub_cv_solaris_linker = xyes ; then
++
++cat > conftest.map <<EOF
++	text = P${link_addr} ;
++EOF
++    if AC_TRY_COMMAND([${CC-cc} ${CFLAGS} -nostdlib -Wl,-Mconftest.map conftest.o -o conftest.exec]); then :
++    else
++      AC_MSG_ERROR([${CC-cc} cannot link at address $link_addr])
++    fi
++    if AC_TRY_COMMAND([${OBJCOPY-objcopy} --only-section=.text -O binary conftest.exec conftest]); then :
++    else
++      AC_MSG_ERROR([${OBJCOPY-objcopy} cannot create binary files])
++    fi
+   else
+-    AC_MSG_ERROR([${CC-cc} cannot link at address $link_addr])
++    if AC_TRY_COMMAND([${CC-cc} ${TARGET_CFLAGS} ${TARGET_LDFLAGS} -nostdlib ${TARGET_IMG_LDFLAGS_AC} ${TARGET_IMG_BASE_LDOPT},$link_addr conftest.o -o conftest.exec]); then :
++    else
++      AC_MSG_ERROR([${CC-cc} cannot link at address $link_addr])
++    fi
++    if AC_TRY_COMMAND([${TARGET_OBJCOPY-objcopy} --only-section=.text -O binary conftest.exec conftest]); then :
++    else
++      AC_MSG_ERROR([${TARGET_OBJCOPY-objcopy} cannot create binary files])
++    fi
+   fi
+-  if AC_TRY_COMMAND([${TARGET_OBJCOPY-objcopy} --only-section=.text -O binary conftest.exec conftest]); then :
+-  else
+-    AC_MSG_ERROR([${TARGET_OBJCOPY-objcopy} cannot create binary files])
+-  fi
+   if test ! -f conftest.old || AC_TRY_COMMAND([cmp -s conftest.old conftest]); then
+     mv -f conftest conftest.old
+   else
+@@ -116,6 +146,22 @@
+ fi
+ ])
+ 
++dnl check if our target linker is Solaris ld
++dnl because it requires mapfiles instead of GNU ld command-line args
++AC_DEFUN([grub_solaris_linker],
++[AC_REQUIRE([AC_PROG_CC])
++AC_MSG_CHECKING([whether our target linker is Solaris ld])
++AC_CACHE_VAL(grub_cv_solaris_linker,
++[cat > conftest.c <<\EOF
++int main(int argc, char **argv){return 0;}
++EOF
++if $CC conftest.c -o /dev/null -Wl,-V 2>&1 | grep "Solaris Link Editors" > /dev/null; then
++  grub_cv_solaris_linker=yes
++else
++  grub_cv_solaris_linker=no
++fi
++])
++AC_MSG_RESULT([$grub_cv_solaris_linker])])
+ 
+ dnl Supply --build-id=none to ld if building modules.
+ dnl This suppresses warnings from ld on some systems
diff -r 68f95e015346 usr/src/grub/patches/0003-Makefile.common.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0003-Makefile.common.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,78 @@
+# Source: Local, adapted from 1.99
+# Solaris compiler and linker flags definitions
+--- old/conf/Makefile.common	2024-04-08 14:43:43.106250649 +0000
++++ new/conf/Makefile.common	2024-04-08 14:43:40.980627476 +0000
+@@ -38,11 +38,17 @@
+ BUILD_CPPFLAGS += $(CPPFLAGS_DEFAULT)
+ 
+ CFLAGS_KERNEL = $(CFLAGS_PLATFORM) -ffreestanding
++if COND_ld_Solaris
++CFLAGS_KERNEL += -fno-common
++LDFLAGS_KERNEL = $(LDFLAGS_PLATFORM) -nostdlib $(LDFLAGS_BASE_ADDRESS_$(GRUB_KERNEL_MACHINE_LINK_ADDR))
++else
+ LDFLAGS_KERNEL = $(LDFLAGS_PLATFORM) -nostdlib $(TARGET_LDFLAGS_OLDMAGIC)
++endif
+ CPPFLAGS_KERNEL = $(CPPFLAGS_CPU) $(CPPFLAGS_PLATFORM) -DGRUB_KERNEL=1
+ CCASFLAGS_KERNEL = $(CCASFLAGS_CPU) $(CCASFLAGS_PLATFORM)
+ STRIPFLAGS_KERNEL = -R .rel.dyn -R .reginfo -R .note -R .comment -R .drectve -R .note.gnu.gold-version -R .MIPS.abiflags -R .ARM.exidx
+ if !COND_emu
++if !COND_ld_Solaris
+ if COND_HAVE_ASM_USCORE
+   LDFLAGS_KERNEL += -Wl,--defsym=_malloc=_grub_malloc -Wl,--defsym=_free=_grub_free
+ else
+@@ -49,14 +55,23 @@
+   LDFLAGS_KERNEL += -Wl,--defsym=malloc=grub_malloc -Wl,--defsym=free=grub_free
+ endif
+ endif
++endif
+ 
+ CFLAGS_MODULE = $(CFLAGS_PLATFORM) -ffreestanding
++if COND_ld_Solaris
++CFLAGS_MODULE += -fno-builtin -fno-common
++endif
+ LDFLAGS_MODULE = $(LDFLAGS_PLATFORM) -nostdlib $(TARGET_LDFLAGS_OLDMAGIC) -Wl,-r
+ CPPFLAGS_MODULE = $(CPPFLAGS_CPU) $(CPPFLAGS_PLATFORM)
+ CCASFLAGS_MODULE = $(CCASFLAGS_CPU) $(CCASFLAGS_PLATFORM)
+ 
+ CFLAGS_IMAGE = $(CFLAGS_PLATFORM) -fno-builtin
++if COND_ld_Solaris
++CFLAGS_IMAGE += -fno-common
++LDFLAGS_IMAGE = $(LDFLAGS_PLATFORM) -nostdlib $(TARGET_LDFLAGS_OLDMAGIC)
++else
+ LDFLAGS_IMAGE = $(LDFLAGS_PLATFORM) -nostdlib $(TARGET_LDFLAGS_OLDMAGIC) -Wl,-S
++endif
+ CPPFLAGS_IMAGE = $(CPPFLAGS_CPU) $(CPPFLAGS_PLATFORM)
+ CCASFLAGS_IMAGE = $(CCASFLAGS_CPU) $(CCASFLAGS_PLATFORM)
+ 
+@@ -69,6 +84,30 @@
+ CPPFLAGS_LIBRARY =
+ CCASFLAGS_LIBRARY =
+ 
++if COND_ld_Solaris
++LDFLAGS_EMU = -Wl,-r
++LDFLAGS_X86_EFI = -Wl,-r
++LDFLAGS_PACKDATA = -Wl,-dn
++LDFLAGS_BASE_ADDRESS_0x0 = -Wl,-M,$(top_srcdir)/conf/mapfile-0.map
++LDFLAGS_BASE_ADDRESS_0x7C00 = -Wl,-M,$(top_srcdir)/conf/mapfile-7c00.map
++LDFLAGS_BASE_ADDRESS_0x8000 = -Wl,-M,$(top_srcdir)/conf/mapfile-8000.map
++LDFLAGS_BASE_ADDRESS_0x8200 = -Wl,-M,$(top_srcdir)/conf/mapfile-8200.map
++LDFLAGS_BASE_ADDRESS_0x6000 = -Wl,-M,$(top_srcdir)/conf/mapfile-6000.map
++LDFLAGS_BASE_ADDRESS_0x9000 = -Wl,-M,$(top_srcdir)/conf/mapfile-9000.map
++LDFLAGS_BASE_ADDRESS_0x100000 = -Wl,-M,$(top_srcdir)/conf/mapfile-100000.map
++else
++LDFLAGS_EMU = -Wl,-r,-d
++LDFLAGS_X86_EFI = -Wl,-r,-d
++LDFLAGS_PACKDATA = -Wl,-N
++LDFLAGS_BASE_ADDRESS_0x0 = $(TARGET_IMG_BASE_LDOPT),0
++LDFLAGS_BASE_ADDRESS_0x6000 = $(TARGET_IMG_BASE_LDOPT),0x6000
++LDFLAGS_BASE_ADDRESS_0x7C00 = $(TARGET_IMG_BASE_LDOPT),0x7c00
++LDFLAGS_BASE_ADDRESS_0x8000 = $(TARGET_IMG_BASE_LDOPT),0x8000
++LDFLAGS_BASE_ADDRESS_0x8200 = $(TARGET_IMG_BASE_LDOPT),0x8200
++LDFLAGS_BASE_ADDRESS_0x9000 = $(TARGET_IMG_BASE_LDOPT),0x9000
++LDFLAGS_BASE_ADDRESS_0x100000 = $(TARGET_IMG_BASE_LDOPT),0x100000
++endif
++
+ # Other variables
+ 
+ grubconfdir = $(sysconfdir)/grub.d
+
diff -r 68f95e015346 usr/src/grub/patches/0004-configure.ac.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0004-configure.ac.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,115 @@
+# Source: Local, adapted from 1.99
+# Use Solaris linker, gstrip, gnm.  Patch path to unifont.
+--- old/./configure.ac	2024-04-08 14:43:58.794667219 +0000
++++ new/./configure.ac	2024-04-08 14:43:57.634971385 +0000
+@@ -227,7 +227,7 @@
+   linux*)			host_kernel=linux ;;
+   freebsd* | kfreebsd*-gnu)	host_kernel=kfreebsd ;;
+   netbsd*)			host_kernel=netbsd ;;
+-  solaris*)			host_kernel=illumos ;;
++  solaris*)			host_kernel=solaris ;;
+   darwin*)			host_kernel=xnu ;;
+   cygwin | windows* | mingw32*)	host_kernel=windows ;;
+ esac
+@@ -542,8 +542,13 @@
+   AC_CHECK_TOOLS(TARGET_CC, [gcc egcs cc],
+                  [AC_MSG_ERROR([none of gcc, egcs and cc is found. set TARGET_CC manually.])])
+   AC_CHECK_TOOL(TARGET_OBJCOPY, objcopy)
+-  AC_CHECK_TOOL(TARGET_STRIP, strip)
+-  AC_CHECK_TOOL(TARGET_NM, nm)
++  if test "$host_kernel" = solaris; then
++    AC_CHECK_TOOL(TARGET_STRIP, gstrip)
++    AC_CHECK_TOOL(TARGET_NM, gnm)
++  else
++    AC_CHECK_TOOL(TARGET_STRIP, strip)
++    AC_CHECK_TOOL(TARGET_NM, nm)
++  fi
+   AC_CHECK_TOOL(TARGET_RANLIB, ranlib)
+ 
+   ac_tool_prefix="$tmp_ac_tool_prefix"
+@@ -552,8 +557,13 @@
+     TARGET_CC=$CC
+   fi
+   AC_CHECK_TOOL(TARGET_OBJCOPY, objcopy)
+-  AC_CHECK_TOOL(TARGET_STRIP, strip)
+-  AC_CHECK_TOOL(TARGET_NM, nm)
++  if test "$host_kernel" = solaris; then
++    AC_CHECK_TOOL(TARGET_STRIP, gstrip)
++    AC_CHECK_TOOL(TARGET_NM, gnm)
++  else
++    AC_CHECK_TOOL(TARGET_STRIP, strip)
++    AC_CHECK_TOOL(TARGET_NM, nm)
++  fi
+   AC_CHECK_TOOL(TARGET_RANLIB, ranlib)
+ fi
+ 
+@@ -1113,7 +1123,11 @@
+ 
+ CFLAGS="$TARGET_CFLAGS"
+ 
++grub_solaris_linker
+ 
++AM_CONDITIONAL([COND_ld_Solaris], [test x$grub_cv_solaris_linker = xyes])
++TARGET_SOLARIS_LD=0
++
+ if test x"$platform" = xemu ; then
+   TARGET_OBJ2ELF=
+   grub_cv_target_cc_link_format=
+@@ -1134,6 +1148,8 @@
+       TARGET_LDFLAGS="$TARGET_LDFLAGS -Wl,$grub_cv_target_cc_link_format"
+       ;;
+   esac
++elif test x$grub_cv_solaris_linker = xyes ; then
++  TARGET_SOLARIS_LD=1
+ elif test x"$target_cpu" = xi386 || test x"$target_cpu" = xx86_64; then
+   AC_CACHE_CHECK([for target linking format], [grub_cv_target_cc_link_format], [
+     grub_cv_target_cc_link_format=unknown
+@@ -1185,6 +1201,13 @@
+    TARGET_IMG_LDFLAGS_AC='-nostdlib -static -Wl,-preload -Wl,-segalign,20'
+    TARGET_IMG_BASE_LDOPT="-Wl,-image_base"
+    TARGET_LDFLAGS_OLDMAGIC=""
++elif test x$grub_cv_solaris_linker = xyes ; then
++   TARGET_APPLE_LINKER=0
++   TARGET_LDFLAGS_OLDMAGIC=
++   TARGET_IMG_LDFLAGS="-Wl,-dn"
++   TARGET_IMG_LDFLAGS_AC="-Wl,-dn,-M${srcdir}/conf/${target_cpu}-${platform}-${hostOs}-img-ld.sc"
++   TARGET_IMG_BASE_LDOPT=
++   TARGET_IMG_LDSCRIPT=
+ elif test x$grub_cv_target_cc_link_format = x-mi386pe || test x$grub_cv_target_cc_link_format = x-mi386pep ; then
+   TARGET_APPLE_LINKER=0
+   TARGET_LDFLAGS_OLDMAGIC="-Wl,-N"
+@@ -1516,6 +1539,8 @@
+ 
+ if test "x$TARGET_APPLE_LINKER" = x1 ; then
+ CFLAGS="$TARGET_CFLAGS -nostdlib -static"
++elif test "x$TARGET_SOLARIS_LD" = x1 ; then
++CFLAGS="$TARGET_CFLAGS -nostdlib -static"
+ else
+ CFLAGS="$TARGET_CFLAGS -nostdlib"
+ fi
+@@ -1876,7 +1901,7 @@
+ if test "x$with_unifont" = x; then
+   # search in well-known directories
+   for ext in pcf pcf.gz bdf bdf.gz ttf ttf.gz; do
+-    for dir in . /usr/src /usr/share/fonts/X11/misc /usr/share/fonts/unifont /usr/share/fonts/uni /usr/share/fonts/truetype/unifont /usr/share/fonts/misc /usr/pkg/share/fonts/X11/misc /usr/local/share/fonts/gnu-unifont /usr/local/share/fonts/unifont; do
++    for dir in . /usr/src /usr/share/fonts/TrueType/unifont /usr/share/fonts/X11/misc /usr/share/fonts/unifont /usr/share/fonts/uni /usr/share/fonts/truetype/unifont /usr/share/fonts/misc /usr/pkg/share/fonts/X11/misc /usr/local/share/fonts/gnu-unifont /usr/local/share/fonts/unifont; do
+       if test -f "$dir/unifont.$ext"; then
+         md5="$(md5sum "$dir/unifont.$ext"|awk '{ print $1; }')"
+         # PCF and BDF from version 6.3 isn't hanled properly by libfreetype.
+@@ -2112,6 +2137,7 @@
+ AC_SUBST(TARGET_IMG_CFLAGS)
+ AC_SUBST(TARGET_IMG_BASE_LDOPT)
+ AC_SUBST(TARGET_APPLE_LINKER)
++AC_SUBST(TARGET_SOLARIS_LD)
+ 
+ AC_SUBST(HOST_CFLAGS)
+ AC_SUBST(HOST_LDFLAGS)
+@@ -2166,6 +2192,7 @@
+ AM_CONDITIONAL([COND_HOST_KFREEBSD], [test x$host_kernel = xkfreebsd])
+ AM_CONDITIONAL([COND_HOST_XNU], [test x$host_kernel = xxnu])
+ AM_CONDITIONAL([COND_HOST_ILLUMOS], [test x$host_kernel = xillumos])
++AM_CONDITIONAL([COND_HOST_SOLARIS], [test x$host_kernel = xsolaris])
+ 
+ AM_CONDITIONAL([COND_MAN_PAGES], [test x$cross_compiling = xno -a x$HELP2MAN != x])
+ AM_CONDITIONAL([COND_GRUB_EMU_SDL2], [test x$enable_grub_emu_sdl2 = xyes])
+
diff -r 68f95e015346 usr/src/grub/patches/0005-config.h.in.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0005-config.h.in.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,18 @@
+# Source: Local, carried from 1.99
+# Use extended version string on Solaris
+--- old/./config.h.in	2024-04-08 14:43:58.846683796 +0000
++++ new/./config.h.in	2024-04-08 14:43:57.634221492 +0000
+@@ -55,7 +55,11 @@
+ /* Define to the full name and version of this package. */
+ #  define PACKAGE_STRING "@PACKAGE_STRING@"
+ /* Define to the version of this package. */
+-#  define PACKAGE_VERSION "@PACKAGE_VERSION@"
++#  ifdef __sun__
++#    include <grub/xversion.h>
++#  else
++#    define PACKAGE_VERSION "@PACKAGE_VERSION@"
++#  endif
+ /* Define to the full name of this package. */
+ #  define PACKAGE_NAME "@PACKAGE_NAME@"
+ /* Define to the address where bug reports for this package should be sent. */
+
diff -r 68f95e015346 usr/src/grub/patches/0006-Makefile.util.def.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0006-Makefile.util.def.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,61 @@
+# Source: Local, adapted from 1.99
+# Add 10_solaris, grub-solvers, grub-version-check. Disable 30_uefi-firmware.
+--- old/./Makefile.util.def	2024-04-08 14:43:42.157892755 +0000
++++ new/./Makefile.util.def	2024-04-08 14:43:40.605359805 +0000
+@@ -369,6 +369,7 @@
+   extra_dist = grub-core/osdep/generic/blocklist.c;
+   extra_dist = grub-core/osdep/linux/blocklist.c;
+   extra_dist = grub-core/osdep/windows/blocklist.c;
++  extra_dist = util/grub-solvers.c;
+   common = grub-core/osdep/init.c;
+ 
+   ldadd = libgrubmods.a;
+@@ -456,6 +457,13 @@
+ };
+ 
+ script = {
++  name = '10_solaris';
++  common = util/grub.d/10_solaris.in;
++  installdir = grubconf;
++  condition = COND_HOST_SOLARIS;
++};
++
++script = {
+   name = '10_windows';
+   common = util/grub.d/10_windows.in;
+   installdir = grubconf;
+@@ -527,6 +535,7 @@
+   name = '30_uefi-firmware';
+   common = util/grub.d/30_uefi-firmware.in;
+   installdir = grubconf;
++  condition = !COND_HOST_SOLARIS;
+ };
+ 
+ script = {
+@@ -533,6 +542,7 @@
+   name = '40_custom';
+   common = util/grub.d/40_custom.in;
+   installdir = grubconf;
++  condition = !COND_HOST_SOLARIS;
+ };
+ 
+ script = {
+@@ -1421,4 +1431,17 @@
+   ldadd = libgrubkern.a;
+   ldadd = grub-core/lib/gnulib/libgnu.a;
+   ldadd = '$(LIBINTL) $(LIBDEVMAPPER) $(LIBZFS) $(LIBNVPAIR) $(LIBGEOM)';
++};
++
++program = {
++  name = grub-version-check;
++  mansection = 1;
++
++  common = util/grub-version-check.c;
++  common = util/solaris-version.c;
++  common = grub-core/osdep/init.c;
++
++  ldadd = libgrubkern.a;
++  ldadd = grub-core/lib/gnulib/libgnu.a;
++  ldadd = '$(LIBINTL) $(LIBDEVMAPPER)';
+ };
+
diff -r 68f95e015346 usr/src/grub/patches/0007-Makefile.core.def.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0007-Makefile.core.def.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,119 @@
+# Source: Local, carried from 1.99
+# Patch linker invocations for Solaris, add verified_boot module
+--- old/grub-core/Makefile.core.def	2024-04-08 14:44:18.584240873 +0000
++++ new/grub-core/Makefile.core.def	2024-04-08 14:44:16.777599132 +0000
+@@ -82,9 +82,9 @@
+   riscv64_efi_stripflags   = '--strip-unneeded -K start -R .note -R .comment -R .note.gnu.gold-version -R .eh_frame';
+ 
+   i386_pc_ldflags          = '$(TARGET_IMG_LDFLAGS)';
+-  i386_pc_ldflags          = '$(TARGET_IMG_BASE_LDOPT),0x9000';
++  i386_pc_ldflags          = '$(LDFLAGS_BASE_ADDRESS_0x9000)';
+   i386_qemu_ldflags        = '$(TARGET_IMG_LDFLAGS)';
+-  i386_qemu_ldflags        = '$(TARGET_IMG_BASE_LDOPT),0x9000';
++  i386_qemu_ldflags        = '$(LDFLAGS_BASE_ADDRESS_0x9000)';
+   i386_coreboot_ldflags    = '$(TARGET_IMG_LDFLAGS)';
+   i386_coreboot_ldflags    = '$(TARGET_IMG_BASE_LDOPT),0x9000';
+   i386_multiboot_ldflags   = '$(TARGET_IMG_LDFLAGS)';
+@@ -442,10 +442,10 @@
+   sparc64_ieee1275 = boot/sparc64/ieee1275/boot.S;
+ 
+   i386_pc_ldflags = '$(TARGET_IMG_LDFLAGS)';
+-  i386_pc_ldflags = '$(TARGET_IMG_BASE_LDOPT),0x7C00';
++  i386_pc_ldflags = '$(LDFLAGS_BASE_ADDRESS_0x7C00)';
+ 
+   i386_qemu_ldflags = '$(TARGET_IMG_LDFLAGS)';
+-  i386_qemu_ldflags = '$(TARGET_IMG_BASE_LDOPT),$(GRUB_BOOT_MACHINE_LINK_ADDR)';
++  i386_qemu_ldflags = '$(LDFLAGS_BASE_ADDRESS_$(GRUB_BOOT_MACHINE_LINK_ADDR))';
+   i386_qemu_ccasflags = '-DGRUB_BOOT_MACHINE_LINK_ADDR=$(GRUB_BOOT_MACHINE_LINK_ADDR)';
+ 
+   /* The entry point for a.out binaries on sparc64 starts
+@@ -470,7 +470,7 @@
+   cppflags = '-DHYBRID_BOOT=1';
+   
+   i386_pc_ldflags = '$(TARGET_IMG_LDFLAGS)';
+-  i386_pc_ldflags = '$(TARGET_IMG_BASE_LDOPT),0x7C00';
++  i386_pc_ldflags = '$(LDFLAGS_BASE_ADDRESS_0x7C00)';
+ 
+   objcopyflags = '-O binary';
+   enable = i386_pc;
+@@ -481,7 +481,7 @@
+ 
+   i386_pc = boot/i386/pc/cdboot.S;
+   i386_pc_ldflags = '$(TARGET_IMG_LDFLAGS)';
+-  i386_pc_ldflags = '$(TARGET_IMG_BASE_LDOPT),0x7C00';
++  i386_pc_ldflags = '$(LDFLAGS_BASE_ADDRESS_0x7C00)';
+ 
+   sparc64_ieee1275 = boot/sparc64/ieee1275/boot.S;
+ 
+@@ -501,7 +501,7 @@
+   i386_pc = boot/i386/pc/pxeboot.S;
+ 
+   i386_pc_ldflags = '$(TARGET_IMG_LDFLAGS)';
+-  i386_pc_ldflags = '$(TARGET_IMG_BASE_LDOPT),0x7C00';
++  i386_pc_ldflags = '$(LDFLAGS_BASE_ADDRESS_0x7C00)';
+ 
+   objcopyflags = '-O binary';
+   enable = i386_pc;
+@@ -512,7 +512,7 @@
+   i386_pc = boot/i386/pc/diskboot.S;
+ 
+   i386_pc_ldflags = '$(TARGET_IMG_LDFLAGS)';
+-  i386_pc_ldflags = '$(TARGET_IMG_BASE_LDOPT),0x8000';
++  i386_pc_ldflags = '$(LDFLAGS_BASE_ADDRESS_0x8000)';
+ 
+   sparc64_ieee1275 = boot/sparc64/ieee1275/diskboot.S;
+   sparc64_ieee1275_ldflags = '-Wl,-Ttext=0x4200';
+@@ -528,7 +528,7 @@
+   i386_pc = boot/i386/pc/lnxboot.S;
+ 
+   i386_pc_ldflags = '$(TARGET_IMG_LDFLAGS)';
+-  i386_pc_ldflags = '$(TARGET_IMG_BASE_LDOPT),0x6000';
++  i386_pc_ldflags = '$(LDFLAGS_BASE_ADDRESS_0x6000)';
+ 
+   objcopyflags = '-O binary';
+   enable = i386_pc;
+@@ -570,7 +570,7 @@
+   i386_pc_nodist = rs_decoder.h;
+ 
+   objcopyflags = '-O binary';
+-  ldflags = '$(TARGET_IMG_LDFLAGS) $(TARGET_IMG_BASE_LDOPT),0x8200';
++  ldflags = '$(TARGET_IMG_LDFLAGS) $(LDFLAGS_BASE_ADDRESS_0x8200)';
+   enable = i386_pc;
+ };
+ 
+@@ -1820,6 +1820,34 @@
+   enable = mips;
+ };
+ 
++module = {
++  name = verified_boot;
++  cppflags = '-DGRUB_USE_MULTIBOOT2 -D_GCRYPT_IN_LIBGCRYPT';
++  cppflags = '-D_GCRY_GCC_ATTR_PURE= -D_ELF64 -DEFI_VBOOT';
++  cppflags = '-DUSE_INTERNAL_CERT';
++  cppflags = '-I$(ONBLD_KEEP)/$(MACH)/signing-material';
++  cppflags = '-I$(srcdir)/lib/libgcrypt_vboot';
++  cppflags = '-I$(srcdir)/../contrib/vboot';
++  cppflags = '-I$(srcdir)/../contrib/vboot/elfsignrange';
++  cppflags = '-I$(srcdir)/lib/libgcrypt-grub/src';
++  cppflags = '-I$(srcdir)/lib/libgcrypt-grub/mpi';
++  cppflags = '-I$(srcdir)/lib/libgcrypt_wrap';
++  cppflags = '-I$(SRC)/uts/common';
++  cppflags = '-I/usr/include';
++  cflags = '-Wno-vla -Wno-undef -Wno-sign-compare';
++  cflags = '-Wno-unused-parameter -Wno-unknown-pragmas';
++
++  common = ../contrib/vboot/verify.c;
++  common = ../contrib/vboot/verify_elf.c;
++  common = ../contrib/vboot/verify_rsa.c;
++  common = ../contrib/vboot/verify_efi.c;
++  common = ../contrib/vboot/verify_base64.c;
++  common = ../contrib/vboot/verify_cert.c;
++  common = ../contrib/vboot/elfsignrange/elfsignrange.c;
++
++  enable = x86_64_efi;
++};
++
+ module = {
+   name = multiboot;
+   common = loader/multiboot.c;
+
diff -r 68f95e015346 usr/src/grub/patches/0008-extra_deps.lst.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0008-extra_deps.lst.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,7 @@
+# Source: upstream
+# Add extra_deps.lst
+--- /dev/null	2024-04-08 14:44:16.000000000 +0000
++++ new/grub-core/extra_deps.lst	2024-04-08 14:44:16.702879824 +0000
+@@ -0,0 +1 @@
++depends bli part_gpt
+
diff -r 68f95e015346 usr/src/grub/patches/0009-libnvpair.h.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0009-libnvpair.h.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,13 @@
+# Source: Local, new for 2.12
+# define NVLIST macro for the HAVE_NVPAIR_H case
+--- old/include/grub/util/libnvpair.h	2024-04-08 14:44:56.992088375 +0000
++++ new/include/grub/util/libnvpair.h	2024-04-08 14:44:55.464596464 +0000
+@@ -23,6 +23,7 @@
+ 
+ #ifdef HAVE_LIBNVPAIR_H
+ #include <libnvpair.h>
++#define NVLIST(x) nvlist_ ## x
+ #else /* ! HAVE_LIBNVPAIR_H */
+ 
+ #include <stdio.h>	/* FILE */
+
diff -r 68f95e015346 usr/src/grub/patches/0010-cat.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0010-cat.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,13 @@
+# Source: Local, new for 2.12
+# Disable format warning/error
+--- old/grub-core/commands/cat.c	2024-04-08 14:44:18.676114105 +0000
++++ new/grub-core/commands/cat.c	2024-04-08 14:44:17.123887888 +0000
+@@ -25,6 +25,7 @@
+ #include <grub/extcmd.h>
+ #include <grub/i18n.h>
+ #include <grub/charset.h>
++#pragma GCC diagnostic ignored "-Wformat" 
+ 
+ GRUB_MOD_LICENSE ("GPLv3+");
+ 
+
diff -r 68f95e015346 usr/src/grub/patches/0011-memdisk.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0011-memdisk.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,35 @@
+# Source: Local, carried from 1.99
+# Patches for zvboot
+--- old/grub-core/disk/memdisk.c	2024-04-08 14:44:18.528081642 +0000
++++ new/grub-core/disk/memdisk.c	2024-04-08 14:44:17.123839186 +0000
+@@ -85,6 +85,29 @@
+     .next = 0
+   };
+ 
++#ifdef ZVBOOT
++void
++memdisk_set(char *addr, grub_off_t size)
++{
++	static int registered = 0;
++
++	grub_dprintf("memdisk", "memdisk at %p, %ld\n", addr, size);
++
++	memdisk_size = size;
++	memdisk_addr = addr;
++
++	if (registered == 0) {
++		grub_disk_dev_register (&grub_memdisk_dev);
++		registered = 1;
++	}
++}
++#endif /* ZVBOOT */
++
++#ifdef ZVBOOT
++/* Fake out the dynamic loader symbols. */
++grub_addr_t grub_modbase;
++#endif /* ZVBOOT */
++
+ GRUB_MOD_INIT(memdisk)
+ {
+   struct grub_module_header *header;
+
diff -r 68f95e015346 usr/src/grub/patches/0012-read.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0012-read.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,47 @@
+# Source: Local, adapted from 1.99
+# Add noblock option to read command
+--- old/grub-core/commands/read.c	2024-04-08 14:44:18.528031800 +0000
++++ new/grub-core/commands/read.c	2024-04-08 14:44:17.123925212 +0000
+@@ -30,12 +30,13 @@
+ 
+ static const struct grub_arg_option options[] =
+   {
++    {"noblock", 'd', 0, N_("Do not block for input"), 0, 0},
+     {"silent", 's', 0, N_("Do not echo input"), 0, 0},
+     {0, 0, 0, 0, 0, 0}
+   };
+ 
+ static char *
+-grub_getline (int silent)
++grub_getline (int silent, int noblock)
+ {
+   int i;
+   char *line;
+@@ -49,6 +50,8 @@
+ 
+   while (1)
+     {
++      if (noblock && grub_getkey_noblock() == GRUB_TERM_NO_KEY)
++        break;
+       c = grub_getkey ();
+       if ((c == '\n') || (c == '\r'))
+ 	break;
+@@ -77,7 +80,7 @@
+ grub_cmd_read (grub_extcmd_context_t ctxt, int argc, char **args)
+ {
+   struct grub_arg_list *state = ctxt->state;
+-  char *line = grub_getline (state[0].set);
++  char *line = grub_getline (state[1].set, state[0].set);
+ 
+   if (! line)
+     return grub_errno;
+@@ -93,7 +96,7 @@
+ GRUB_MOD_INIT(read)
+ {
+   cmd = grub_register_extcmd ("read", grub_cmd_read, 0,
+-			       N_("[-s] [ENVVAR]"),
++			       N_("[-ds] [ENVVAR]"),
+ 			       N_("Set variable with user input."), options);
+ }
+ 
+
diff -r 68f95e015346 usr/src/grub/patches/0013-ufs.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0013-ufs.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,22 @@
+# Source: Local, carried from 1.99
+# Patch endian macros for zvboot
+--- old/grub-core/fs/ufs.c	2024-04-08 14:44:18.552819121 +0000
++++ new/grub-core/fs/ufs.c	2024-04-08 14:44:17.098618658 +0000
+@@ -26,6 +26,16 @@
+ #include <grub/types.h>
+ #include <grub/i18n.h>
+ 
++#ifdef ZVBOOT
++/* Solaris UFS uses CPU endian ordering on disk. */
++#undef grub_le_to_cpu16
++#undef grub_le_to_cpu32
++#undef grub_le_to_cpu64
++#define grub_le_to_cpu16(x) (x)
++#define grub_le_to_cpu32(x) (x)
++#define grub_le_to_cpu64(x) (x)
++#endif /* ZVBOOT */
++
+ GRUB_MOD_LICENSE ("GPLv3+");
+ 
+ #ifdef MODE_UFS2
+
diff -r 68f95e015346 usr/src/grub/patches/0014-zfs.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0014-zfs.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,780 @@
+# Source: Local, adapted from 1.99
+# ZFS patches carried forward from 1.99
+# Add progress reporting hook support
+--- old/grub-core/fs/zfs/zfs.c	2024-05-09 08:15:20.308979186 -0700
++++ new/grub-core/fs/zfs/zfs.c	2024-05-28 07:23:12.969987605 -0700
+@@ -61,6 +61,8 @@
+ 
+ #define	ZPOOL_PROP_BOOTFS		"bootfs"
+ 
++#define BOOTFSNAME_SIZE	256
++
+ /*
+  * For nvlist manipulation. (from nvpair.h)
+  */
+@@ -200,6 +202,7 @@
+ struct grub_zfs_device_desc
+ {
+   enum { DEVICE_LEAF, DEVICE_MIRROR, DEVICE_RAIDZ } type;
++  enum { DEVICE_OK, DEVICE_ERROR } dev_state;
+   grub_uint64_t id;
+   grub_uint64_t guid;
+   unsigned ashift;
+@@ -235,6 +238,8 @@
+ 
+ struct grub_zfs_data
+ {
++  int zcached; /* the value should be zero if no cache available */
++
+   /* cache for a file block of the currently zfs_open()-ed file */
+   char *file_buf;
+   grub_uint64_t file_start;
+@@ -259,6 +264,7 @@
+   uberblock_t current_uberblock;
+ 
+   grub_uint64_t guid;
++  char *dev_name;
+ };
+ 
+ /* Context for grub_zfs_dir.  */
+@@ -367,6 +373,10 @@
+ static grub_err_t zio_read_data (blkptr_t * bp, grub_zfs_endian_t endian,
+ 				 void *buf, struct grub_zfs_data *data);
+ 
++static grub_err_t zio_read_common (blkptr_t * bp, dva_t *dva,
++				 grub_zfs_endian_t endian, void *buf,
++				 struct grub_zfs_data *data);
++
+ /*
+  * Our own version of log2().  Same thing as highbit()-1.
+  */
+@@ -627,6 +637,34 @@
+   return GRUB_ERR_NONE;
+ }
+ 
++/*
++ * Check if this vdev is online and is in a good state.
++ */
++static int
++vdev_validate (const char *nv)
++{
++  grub_uint64_t ival = 0;
++
++  if (grub_zfs_nvlist_lookup_uint64 (nv, ZPOOL_CONFIG_OFFLINE, &ival) && ival)
++    {
++      grub_dprintf ("zfs", "vdev_validate: ZPOOL_CONFIG_OFFLINE\n");
++      return (1);
++    }
++  if ((grub_zfs_nvlist_lookup_uint64 (nv, ZPOOL_CONFIG_FAULTED, &ival) && ival) &&
++      !(grub_zfs_nvlist_lookup_uint64 (nv, ZPOOL_CONFIG_DEGRADED, &ival) && ival))
++    {
++      grub_dprintf ("zfs", "vdev_validate: ZPOOL_CONFIG_FAULTED\n");
++      return (1);
++    }
++  if (grub_zfs_nvlist_lookup_uint64 (nv, ZPOOL_CONFIG_REMOVED, &ival) && ival)
++    {
++      grub_dprintf ("zfs", "vdev_validate: ZPOOL_CONFIG_REMOVED\n");
++      return (1);
++    }
++
++    return (0);
++}
++
+ static grub_err_t
+ fill_vdev_info_real (struct grub_zfs_data *data,
+ 		     const char *nvlist,
+@@ -686,6 +724,11 @@
+ 	  *inserted = 1;
+ 	}
+ 
++      if (vdev_validate(nvlist))
++        fill->dev_state = DEVICE_ERROR;
++      else
++        fill->dev_state = DEVICE_OK;
++
+       grub_free (type);
+ 
+       return GRUB_ERR_NONE;
+@@ -692,11 +735,15 @@
+     }
+ 
+   if (grub_strcmp (type, VDEV_TYPE_MIRROR) == 0
++      || grub_strcmp (type, VDEV_TYPE_REPLACING) == 0
++      || grub_strcmp (type, VDEV_TYPE_SPARE) == 0
+       || grub_strcmp (type, VDEV_TYPE_RAIDZ) == 0)
+     {
+       int nelm, i;
+ 
+-      if (grub_strcmp (type, VDEV_TYPE_MIRROR) == 0)
++      if (grub_strcmp (type, VDEV_TYPE_MIRROR) == 0
++          || grub_strcmp (type, VDEV_TYPE_SPARE) == 0
++          || grub_strcmp (type, VDEV_TYPE_REPLACING) == 0)
+ 	fill->type = DEVICE_MIRROR;
+       else
+ 	{
+@@ -963,65 +1010,29 @@
+   return 1;
+ }
+ 
+-/*
+- * Check the disk label information and retrieve needed vdev name-value pairs.
+- *
+- */
+ static grub_err_t
+-check_pool_label (struct grub_zfs_data *data,
+-		  struct grub_zfs_device_desc *diskdesc,
+-		  int *inserted, int original)
++zfs_pool_validate(struct grub_zfs_device_desc *diskdesc, grub_uint64_t *poolguid,
++    char **ret_nvlist)
+ {
+   grub_uint64_t pool_state, txg = 0;
+-  char *nvlist,*features;
+-#if 0
+-  char *nv;
+-#endif
+-  grub_uint64_t poolguid;
++  char *nvlist;
+   grub_uint64_t version;
+   int found;
+   grub_err_t err;
+-  grub_zfs_endian_t endian;
+-  vdev_phys_t *phys;
+-  zio_cksum_t emptycksum;
+ 
+-  *inserted = 0;
+-
+   err = zfs_fetch_nvlist (diskdesc, &nvlist);
+   if (err)
+     return err;
+ 
+-  phys = (vdev_phys_t*) nvlist;
+-  if (grub_zfs_to_cpu64 (phys->vp_zbt.zec_magic,
+-			 GRUB_ZFS_LITTLE_ENDIAN)
+-      == ZEC_MAGIC)
+-    endian = GRUB_ZFS_LITTLE_ENDIAN;
+-  else if (grub_zfs_to_cpu64 (phys->vp_zbt.zec_magic,
+-			      GRUB_ZFS_BIG_ENDIAN)
+-	   == ZEC_MAGIC)
+-    endian = GRUB_ZFS_BIG_ENDIAN;
+-  else
+-    {
+-      grub_free (nvlist);
+-      return grub_error (GRUB_ERR_BAD_FS,
+-			 "bad vdev_phys_t.vp_zbt.zec_magic number");
+-    }
+-  /* Now check the integrity of the vdev_phys_t structure though checksum.  */
+-  ZIO_SET_CHECKSUM(&emptycksum, diskdesc->vdev_phys_sector << 9, 0, 0, 0);
+-  err = zio_checksum_verify (emptycksum, ZIO_CHECKSUM_LABEL, endian,
+-			     nvlist, VDEV_PHYS_SIZE);
+-  if (err)
+-    return err;
+-
+   grub_dprintf ("zfs", "check 2 passed\n");
+ 
+   found = grub_zfs_nvlist_lookup_uint64 (nvlist, ZPOOL_CONFIG_POOL_STATE,
+-					 &pool_state);
++                                         &pool_state);
+   if (! found)
+     {
+       grub_free (nvlist);
+       if (! grub_errno)
+-	grub_error (GRUB_ERR_BAD_FS, ZPOOL_CONFIG_POOL_STATE " not found");
++        grub_error (GRUB_ERR_BAD_FS, ZPOOL_CONFIG_POOL_STATE " not found");
+       return grub_errno;
+     }
+   grub_dprintf ("zfs", "check 3 passed\n");
+@@ -1038,7 +1049,7 @@
+     {
+       grub_free (nvlist);
+       if (! grub_errno)
+-	grub_error (GRUB_ERR_BAD_FS, ZPOOL_CONFIG_POOL_TXG " not found");
++        grub_error (GRUB_ERR_BAD_FS, ZPOOL_CONFIG_POOL_TXG " not found");
+       return grub_errno;
+     }
+   grub_dprintf ("zfs", "check 6 passed\n");
+@@ -1052,48 +1063,79 @@
+   grub_dprintf ("zfs", "check 7 passed\n");
+ 
+   found = grub_zfs_nvlist_lookup_uint64 (nvlist, ZPOOL_CONFIG_VERSION,
+-					 &version);
++                                         &version);
+   if (! found)
+     {
+       grub_free (nvlist);
+       if (! grub_errno)
+-	grub_error (GRUB_ERR_BAD_FS, ZPOOL_CONFIG_VERSION " not found");
++        grub_error (GRUB_ERR_BAD_FS, ZPOOL_CONFIG_VERSION " not found");
+       return grub_errno;
+     }
+   grub_dprintf ("zfs", "check 8 passed\n");
+ 
+-  if (!SPA_VERSION_IS_SUPPORTED(version))
++  if (version > SPA_VERSION)
+     {
++      grub_dprintf("zfs", "SPA_VERSION is too old! (%llu vs. %llu on disk)\n",
++                   SPA_VERSION, (unsigned long long)version);
++      grub_printf (
++"ZFS pool version (%llu) is too new for the GRUB2 ZFS module (maximum version\n"
++"supported is %llu)\n", (unsigned long long)version, SPA_VERSION);
+       grub_free (nvlist);
+       return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+-			 "too new version %llu > %llu",
+-			 (unsigned long long) version,
+-			 (unsigned long long) SPA_VERSION_BEFORE_FEATURES);
++                         "ZFS SPA version is later than GRUB2 ZFS "
++                         "reader code (%llu > %llu)",
++                         (unsigned long long) version,
++                         (unsigned long long) SPA_VERSION);
+     }
+   grub_dprintf ("zfs", "check 9 passed\n");
+ 
+   found = grub_zfs_nvlist_lookup_uint64 (nvlist, ZPOOL_CONFIG_GUID,
+-					 &(diskdesc->guid));
++                                         &(diskdesc->guid));
+   if (! found)
+     {
+       grub_free (nvlist);
+       if (! grub_errno)
+-	grub_error (GRUB_ERR_BAD_FS, ZPOOL_CONFIG_GUID " not found");
++        grub_error (GRUB_ERR_BAD_FS, ZPOOL_CONFIG_GUID " not found");
+       return grub_errno;
+     }
+ 
+   found = grub_zfs_nvlist_lookup_uint64 (nvlist, ZPOOL_CONFIG_POOL_GUID,
+-					 &poolguid);
++                                         poolguid);
+   if (! found)
+     {
+       grub_free (nvlist);
+       if (! grub_errno)
+-	grub_error (GRUB_ERR_BAD_FS, ZPOOL_CONFIG_POOL_GUID " not found");
++        grub_error (GRUB_ERR_BAD_FS, ZPOOL_CONFIG_POOL_GUID " not found");
+       return grub_errno;
+     }
+ 
+-  grub_dprintf ("zfs", "check 11 passed\n");
++  grub_dprintf ("zfs", "check 10 passed\n");
++  if (ret_nvlist == NULL)
++    grub_free (nvlist);
++  else
++    *ret_nvlist = nvlist;
++  return (GRUB_ERR_NONE);
++}
+ 
++/*
++ * Check the disk label information and retrieve needed vdev name-value pairs.
++ *
++ */
++static grub_err_t
++check_pool_label (struct grub_zfs_data *data,
++		  struct grub_zfs_device_desc *diskdesc,
++		  int *inserted, int original)
++{
++  char *nvlist = NULL,*features;
++  grub_uint64_t poolguid;
++  grub_err_t err;
++
++  *inserted = 0;
++
++  err = zfs_pool_validate(diskdesc, &poolguid, &nvlist);
++  if (err)
++    return err;
++
+   if (original)
+     data->guid = poolguid;
+ 
+@@ -1149,6 +1191,28 @@
+   return GRUB_ERR_NONE;
+ }
+ 
++static grub_uint64_t
++zfs_get_poolprop_ashift(struct grub_zfs_device_desc *dev_desc)
++{
++  grub_err_t err;
++  grub_uint64_t ashift = UBERBLOCK_SHIFT;
++  char *nvlist, *vdev_nv;
++
++  err = zfs_fetch_nvlist (dev_desc, &nvlist);
++  if (!err) {
++    vdev_nv = grub_zfs_nvlist_lookup_nvlist (nvlist, ZPOOL_CONFIG_VDEV_TREE);
++    if (vdev_nv) {
++      err = grub_zfs_nvlist_lookup_uint64 (vdev_nv, "ashift", &ashift);
++      grub_free(vdev_nv);
++    }
++    grub_free(nvlist);
++    grub_dprintf("zfs", "Using ashift = %u\n", (unsigned)ashift);
++  } else
++    grub_dprintf("zfs", "ashift nvlist lookup failed\n");
++
++  return ashift;
++}
++
+ static grub_err_t
+ scan_disk (grub_device_t dev, struct grub_zfs_data *data,
+ 	   int original, int *inserted)
+@@ -1200,12 +1264,8 @@
+ 	}
+       grub_dprintf ("zfs", "label ok %d\n", label);
+ 
+-      err = check_pool_label (data, &desc, inserted, original);
+-      if (err || !*inserted)
+-	{
+-	  grub_errno = GRUB_ERR_NONE;
+-	  continue;
+-	}
++      /* Make sure that ashift is filled in desc before calling find_bestub */
++      desc.ashift = zfs_get_poolprop_ashift(&desc);
+ 
+       ubbest = find_bestub (ub_array, &desc);
+       if (!ubbest)
+@@ -1221,6 +1281,14 @@
+ 	grub_memmove (&(data->current_uberblock),
+ 		      &ubbest->ubp_uberblock, sizeof (uberblock_t));
+ 
++      err = check_pool_label (data, &desc, inserted, original);
++      grub_dprintf ("zfs", "label err %d\n", err);
++      if (err || !*inserted)
++	{
++	  grub_errno = GRUB_ERR_NONE;
++	  continue;
++	}
++
+ #if 0
+       if (find_best_root &&
+ 	  vdev_uberblock_compare (&ubbest->ubp_uberblock,
+@@ -1723,6 +1791,25 @@
+ /*
+  * Read a block of data based on the gang block address dva,
+  * and put its data in buf.
++ */
++static grub_err_t
++zio_read_gang_data (blkptr_t * bp, grub_zfs_endian_t endian, void *buf, 
++	       struct grub_zfs_data *data)
++{
++  int i;
++
++  /* pick a good dva from the block pointer */
++  for (i = 0; i < BP_GET_NDVAS(bp); i++)
++    {
++      if (zio_read_common(bp, &bp->blk_dva[i], endian, buf, data) == GRUB_ERR_NONE)
++	return GRUB_ERR_NONE;
++    }
++  return grub_error (GRUB_ERR_BAD_FS, "couldn't find a valid DVA");
++}
++
++/*
++ * Read a block of data based on the gang block address dva,
++ * and put its data in buf.
+  *
+  */
+ static grub_err_t
+@@ -1768,7 +1855,7 @@
+       if (BP_IS_HOLE(&zio_gb->zg_blkptr[i]))
+ 	continue;
+ 
+-      err = zio_read_data (&zio_gb->zg_blkptr[i], endian, buf, data);
++      err = zio_read_gang_data (&zio_gb->zg_blkptr[i], endian, buf, data);
+       if (err)
+ 	{
+ 	  grub_free (zio_gb);
+@@ -1784,31 +1871,60 @@
+  * Read in a block of raw data to buf.
+  */
+ static grub_err_t
++zio_read_common (blkptr_t * bp, dva_t *dva, grub_zfs_endian_t endian,
++                void *buf, struct grub_zfs_data *data)
++{
++  int psize;
++  grub_err_t err = GRUB_ERR_NONE;
++
++  psize = get_psize (bp, endian);
++
++  if (dva->dva_word[0] == 0 && dva->dva_word[1] == 0)
++    return grub_error (GRUB_ERR_BAD_FS, "couldn't find a valid DVA");
++
++  if ((grub_zfs_to_cpu64 (dva->dva_word[1], endian)>>63) & 1)
++    err = zio_read_gang (bp, endian, dva, buf, data);
++  else
++    err = read_dva (dva, endian, data, buf, psize);
++
++  return err;
++
++}
++/*
++ * Read in a block of raw data to buf.
++ */
++static grub_err_t
+ zio_read_data (blkptr_t * bp, grub_zfs_endian_t endian, void *buf,
+ 	       struct grub_zfs_data *data)
+ {
+   int i, psize;
+   grub_err_t err = GRUB_ERR_NONE;
++  zio_cksum_t zc = bp->blk_cksum;
++  grub_uint32_t checksum;
+ 
+   psize = get_psize (bp, endian);
++  checksum = (grub_zfs_to_cpu64((bp)->blk_prop, endian) >> 40) & 0xff;
+ 
+   /* pick a good dva from the block pointer */
+-  for (i = 0; i < SPA_DVAS_PER_BP; i++)
++  for (i = 0; i < BP_GET_NDVAS(bp); i++)
+     {
+-      if (bp->blk_dva[i].dva_word[0] == 0 && bp->blk_dva[i].dva_word[1] == 0)
+-	continue;
+-
+-      if ((grub_zfs_to_cpu64 (bp->blk_dva[i].dva_word[1], endian)>>63) & 1)
+-	err = zio_read_gang (bp, endian, &bp->blk_dva[i], buf, data);
+-      else
+-	err = read_dva (&bp->blk_dva[i], endian, data, buf, psize);
+-      if (!err)
+-	return GRUB_ERR_NONE;
+-      grub_errno = GRUB_ERR_NONE;
++      if (zio_read_common(bp, &bp->blk_dva[i], endian, buf, data) != GRUB_ERR_NONE)
++       {
++         grub_errno = GRUB_ERR_NONE;
++         continue;
++       }
++      err = zio_checksum_verify (zc, checksum, endian, buf, psize);
++      if (err)
++       {
++         grub_dprintf ("zfs", "incorrect checksum\n");
++         grub_errno = GRUB_ERR_NONE;
++         continue;
++       }
++      /* if no errors, return from here */
++      return GRUB_ERR_NONE;
+     }
+ 
+-  if (!err)
+-    err = grub_error (GRUB_ERR_BAD_FS, "couldn't find a valid DVA");
++  err = grub_error (GRUB_ERR_BAD_FS, "couldn't find a valid DVA");
+   grub_errno = err;
+ 
+   return err;
+@@ -2105,6 +2221,33 @@
+   return grub_error (GRUB_ERR_FILE_NOT_FOUND, N_("file `%s' not found"), name);
+ }
+ 
++/*
++ * mzap_value_search: Looks up value and returns property name.
++ */
++static grub_err_t
++mzap_value_search (mzap_phys_t *zapobj, grub_zfs_endian_t endian,
++	     int objsize, char *name, grub_uint64_t *value)
++{
++  int i, chunks;
++  mzap_ent_phys_t *mzap_ent = zapobj->mz_chunk;
++  grub_uint64_t mze_val;
++
++  chunks = objsize / MZAP_ENT_LEN - 1;
++  for (i = 0; i < chunks; i++)
++    {
++	mze_val = grub_zfs_to_cpu64 (mzap_ent[i].mze_value, endian);
++	if (mze_val == *value)
++	  {
++	    grub_memcpy (name, mzap_ent[i].mze_name, grub_strlen
++			 (mzap_ent[i].mze_name) + 1);
++	    return GRUB_ERR_NONE;
++	  }
++    }
++
++  return grub_error (GRUB_ERR_FILE_NOT_FOUND,
++			"mzap_value_search: couldn't find %llu", (unsigned long long)*value);
++}
++
+ static int
+ mzap_iterate (mzap_phys_t * zapobj, grub_zfs_endian_t endian, int objsize,
+ 	      int (*hook) (const char *name, grub_uint64_t val,
+@@ -2539,6 +2682,52 @@
+   return grub_error (GRUB_ERR_BAD_FS, "unknown ZAP type");
+ }
+ 
++/*
++ * Read in the data of a zap object and find the property name for a
++ * matching value.
++ *
++ */
++static grub_err_t
++zap_value_search (dnode_end_t *zap_dnode, char *name, grub_uint64_t *val,
++	    struct grub_zfs_data *data)
++{
++  grub_uint64_t block_type;
++  int size;
++  void *zapbuf;
++  grub_err_t err;
++  grub_zfs_endian_t endian;
++
++  grub_dprintf ("zfs", "zap_value_search: looking for '%lld'\n", (unsigned long long)*val);
++
++  /* Read in the first block of the zap object data. */
++  size = grub_zfs_to_cpu16 (zap_dnode->dn.dn_datablkszsec, 
++			    zap_dnode->endian) << SPA_MINBLOCKSHIFT;
++  err = dmu_read (zap_dnode, 0, &zapbuf, &endian, data);
++  if (err)
++    return err;
++  block_type = grub_zfs_to_cpu64 (*((grub_uint64_t *) zapbuf), endian);
++
++  grub_dprintf ("zfs", "zap_value_search: zap read\n");
++
++  if (block_type == ZBT_MICRO)
++    {
++      grub_dprintf ("zfs", "zap_value_search: micro zap value search\n");
++      err = (mzap_value_search (zapbuf, endian, size, name, val));
++      grub_dprintf ("zfs", "zap_value_search: returned %d\n", err);      
++      grub_free (zapbuf);
++      return err;
++    }
++  else if (block_type == ZBT_HEADER)
++    {
++      /* this is a fat zap */
++      grub_dprintf ("zfs", "fat zap value search not supported\n");
++      grub_free (zapbuf);
++      return grub_error (GRUB_ERR_BAD_FS, "fat zap value search not supported");
++    }
++
++  return grub_error (GRUB_ERR_BAD_FS, "zap_value_search: unknown ZAP type");
++}
++
+ /* Context for zap_iterate_u64.  */
+ struct zap_iterate_u64_ctx
+ {
+@@ -3038,57 +3227,146 @@
+   return err;
+ }
+ 
+-#if 0
+ /*
++ * Get the default 'bootfs' dataset name using rootfs object number
++ *
++ */
++static grub_err_t
++get_default_bootfsname (dnode_end_t * mosmdn, grub_uint64_t bootfsobj,
++		       struct grub_zfs_data *data, char **bootfsname)
++{
++  dnode_end_t dn;
++  dnode_end_t mdn;
++  grub_uint64_t dirobj;
++  grub_uint64_t parentobj;
++  grub_uint64_t childobj;
++  grub_uint64_t rootobj;
++  grub_size_t	buf_size;
++  grub_err_t err = GRUB_ERR_NONE;
++  char *bootfs;
++
++  *bootfsname = 0;
++  if ((grub_errno = dnode_get (mosmdn, DMU_POOL_DIRECTORY_OBJECT,
++			       DMU_OT_OBJECT_DIRECTORY, &mdn, data)))
++      return (grub_errno);
++
++  err = zap_lookup (&mdn, DMU_POOL_ROOT_DATASET, &rootobj, data, 0);
++  if (err)
++       return err;
++
++  if ((grub_errno = dnode_get (mosmdn, bootfsobj, DMU_OT_DSL_DATASET, &dn, data)))
++       return (grub_errno);
++
++  dirobj = grub_zfs_to_cpu64 (((dsl_dataset_phys_t *)
++			DN_BONUS (&dn.dn))->ds_dir_obj, dn.endian);
++
++  buf_size = BOOTFSNAME_SIZE;
++  bootfs = grub_zalloc(buf_size);
++  do
++    {
++      if ((grub_errno = dnode_get (mosmdn, dirobj, DMU_OT_DSL_DIR, &dn, data))) 
++	{
++	  grub_free (bootfs);
++          return (grub_errno);
++	}
++
++      parentobj = grub_zfs_to_cpu64 ((((dsl_dir_phys_t *)
++			    DN_BONUS (&dn.dn)))->dd_parent_obj, dn.endian);
++
++      if ((grub_errno = dnode_get (mosmdn, parentobj, DMU_OT_DSL_DIR, &dn, data)))
++	{
++	  grub_free (bootfs);
++          return (grub_errno);
++	}
++
++      childobj = grub_zfs_to_cpu64 ((((dsl_dir_phys_t *)
++			    DN_BONUS (&dn.dn)))->dd_child_dir_zapobj, dn.endian);
++  
++      if ((grub_errno = dnode_get (mosmdn, childobj,
++				   DMU_OT_DSL_DIR_CHILD_MAP, &dn, data)))
++	{
++	  grub_free (bootfs);
++          return (grub_errno);
++	}
++
++      char cname[64]; 
++      grub_memset (cname, 0, sizeof(cname));
++
++      if (zap_value_search (&dn, cname, &dirobj, data))
++	{
++	  grub_free (bootfs);
++          return (GRUB_ERR_BAD_FS);
++	}
++
++      grub_size_t cname_len = grub_strlen(cname);
++      cname[cname_len++] = '/';
++
++      grub_size_t bootfs_len= grub_strlen(bootfs);
++      grub_size_t expected_len = bootfs_len + cname_len;
++      if (expected_len >= buf_size)
++	{
++	    while((buf_size = buf_size * 2) < expected_len);
++	    char *tmp = grub_realloc (bootfs, buf_size);
++	    if (! tmp)
++	      {
++		grub_free (bootfs);
++		return (grub_errno);
++	      }
++	    bootfs = tmp;
++	    grub_memset((bootfs + bootfs_len), 0, (buf_size - bootfs_len));
++	}
++
++      /* create space for parent dataset name */
++      grub_memmove((bootfs + cname_len), bootfs, bootfs_len); 
++      grub_memmove(bootfs, cname, cname_len);
++
++    } while ((dirobj = parentobj) != rootobj);
++
++  /* remove trailing slash */
++  *(bootfs + grub_strlen(bootfs) - 1) = '\0';
++  *bootfsname = bootfs;
++
++  grub_dprintf ("zfs", "get_default_bootfsname: %s\n", *bootfsname);
++  return (0);
++}
++
++/*
+  * Get the default 'bootfs' property value from the rootpool.
+  *
+  */
+ static grub_err_t
+-get_default_bootfsobj (dnode_phys_t * mosmdn, grub_uint64_t * obj,
++get_default_bootfsobj (dnode_end_t * mosmdn, grub_uint64_t * obj,
+ 		       struct grub_zfs_data *data)
+ {
+   grub_uint64_t objnum = 0;
+-  dnode_phys_t *dn;
+-  if (!dn)
+-    return grub_errno;
++  dnode_end_t dn;
+ 
++  grub_dprintf ("zfs", "get_default_bootfsobj called\n");
+   if ((grub_errno = dnode_get (mosmdn, DMU_POOL_DIRECTORY_OBJECT,
+-			       DMU_OT_OBJECT_DIRECTORY, dn, data)))
+-    {
+-      grub_free (dn);
++			       DMU_OT_OBJECT_DIRECTORY, &dn, data)))
+       return (grub_errno);
+-    }
+ 
+   /*
+    * find the object number for 'pool_props', and get the dnode
+    * of the 'pool_props'.
+    */
+-  if (zap_lookup (dn, DMU_POOL_PROPS, &objnum, data))
+-    {
+-      grub_free (dn);
++  if (zap_lookup (&dn, DMU_POOL_PROPS, &objnum, data, 0))
+       return (GRUB_ERR_BAD_FS);
+-    }
+-  if ((grub_errno = dnode_get (mosmdn, objnum, DMU_OT_POOL_PROPS, dn, data)))
+-    {
+-      grub_free (dn);
++
++  if ((grub_errno = dnode_get (mosmdn, objnum, DMU_OT_POOL_PROPS, &dn, data)))
+       return (grub_errno);
+-    }
+-  if (zap_lookup (dn, ZPOOL_PROP_BOOTFS, &objnum, data))
+-    {
+-      grub_free (dn);
++
++  if (zap_lookup (&dn, ZPOOL_PROP_BOOTFS, &objnum, data, 0))
+       return (GRUB_ERR_BAD_FS);
+-    }
+ 
+   if (!objnum)
+-    {
+-      grub_free (dn);
+       return (GRUB_ERR_BAD_FS);
+-    }
+-
++  
+   *obj = objnum;
++
+   return (0);
+ }
+-#endif
++
+ /*
+  * Given a MOS metadnode, get the metadnode of a given filesystem name (fsname),
+  * e.g. pool/rootfs, or a given object number (obj), e.g. the object number
+@@ -3748,6 +4026,8 @@
+   grub_err_t err;
+   struct grub_zfs_data *data;
+ 
++  *label = NULL;
++
+   data = zfs_mount (device);
+   if (! data)
+     return grub_errno;
+@@ -3920,6 +4200,14 @@
+       return -1;
+     }
+
++   /* Enable progress reporting if set */
++   for (unsigned i = 0; i < data->n_devices_attached; i++)
++     {
++       struct grub_disk *disk = data->devices_attached[i].dev->disk;
++       disk->read_hook = file->read_hook;
++       disk->read_hook_data = file->read_hook_data;
++     }
++
+   /*
+    * Entire Dnode is too big to fit into the space available.  We
+    * will need to read it in chunks.  This could be optimized to
+@@ -3995,6 +4283,42 @@
+   zfs_unmount (data);
+   return err;
+ }
++
++grub_err_t
++grub_zfs_defaultbootfsobj (grub_device_t dev, grub_uint64_t *mdnobj)
++{
++  struct grub_zfs_data *data;
++  grub_err_t err;
++
++  data = zfs_mount (dev);
++  if (! data)
++    return grub_errno;
++
++  err = get_default_bootfsobj (&(data->mos), mdnobj, data);
++  zfs_unmount (data);
++
++  return err;
++}
++
++grub_err_t
++grub_zfs_defaultbootfsname (grub_device_t dev, char **bootfsname)
++{
++  grub_uint64_t mdnobj;
++  struct grub_zfs_data *data;
++  grub_err_t err;
++
++  data = zfs_mount (dev);
++  if (! data)
++    return grub_errno;
++
++  err = get_default_bootfsobj (&(data->mos), &mdnobj, data);
++  if (! err)
++    err = get_default_bootfsname(&(data->mos), mdnobj, data, &(*bootfsname));
++
++  zfs_unmount (data);
++
++  return err;
++}
+ 
+ /*
+  * Note: fill_fs_info() uses functions such as make_mdn() that modify
diff -r 68f95e015346 usr/src/grub/patches/0015-zfsinfo.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0015-zfsinfo.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,319 @@
+# Source: Local, carried from 1.99
+# Add zfs-defaultbootfs, include devguid & poolguid in output
+--- old/grub-core/fs/zfs/zfsinfo.c	2024-05-09 08:15:20.341511623 -0700
++++ new/grub-core/fs/zfs/zfsinfo.c	2024-05-10 13:51:14.921577599 -0700
+@@ -195,10 +195,15 @@
+   return GRUB_ERR_NONE;
+ }
+ 
+-static grub_err_t
+-get_bootpath (char *nvlist, char **bootpath, char **devid)
++#ifndef ZVBOOT
++static
++#endif /* ZVBOOT */
++grub_err_t
++get_bootpath (char *nvlist, grub_uint64_t devguid, char **bootpath, char **devid)
+ {
+   char *type = 0;
++  grub_uint64_t curguid;
++  int found;
+ 
+   type = grub_zfs_nvlist_lookup_string (nvlist, ZPOOL_CONFIG_TYPE);
+ 
+@@ -207,16 +212,19 @@
+ 
+   if (grub_strcmp (type, VDEV_TYPE_DISK) == 0)
+     {
+-      *bootpath = grub_zfs_nvlist_lookup_string (nvlist,
+-						 ZPOOL_CONFIG_PHYS_PATH);
+-      *devid = grub_zfs_nvlist_lookup_string (nvlist, ZPOOL_CONFIG_DEVID);
+-      if (!*bootpath || !*devid)
+-	{
+-	  grub_free (*bootpath);
+-	  grub_free (*devid);
++      found = grub_zfs_nvlist_lookup_uint64 (nvlist, ZPOOL_CONFIG_GUID,
++                                             &curguid);
++
++      if (found && curguid != devguid)
++        {
+ 	  *bootpath = 0;
+ 	  *devid = 0;
++	  return GRUB_ERR_NONE;
+ 	}
++      *bootpath = grub_zfs_nvlist_lookup_string (nvlist,
++						 ZPOOL_CONFIG_PHYS_PATH);
++      *devid = grub_zfs_nvlist_lookup_string (nvlist, ZPOOL_CONFIG_DEVID);
++
+       return GRUB_ERR_NONE;
+     }
+ 
+@@ -235,11 +243,17 @@
+ 						       ZPOOL_CONFIG_CHILDREN,
+ 						       i);
+ 
+-	  get_bootpath (child, bootpath, devid);
++	  if (! child)
++	    {
++	      grub_printf_ (N_("Unable to lookup child vdevs for pool: %s\n"), grub_errmsg);
++	      return grub_errno;
++	    }
++
++	  get_bootpath (child, devguid, bootpath, devid);
+ 
+ 	  grub_free (child);
+ 
+-	  if (*bootpath && *devid)
++	  if (*bootpath || *devid)
+ 	    return GRUB_ERR_NONE;
+ 	}
+     }
+@@ -350,9 +364,10 @@
+   char *nv = 0;
+   char *bootpath = 0, *devid = 0;
+   char *fsname;
+-  char *bootfs;
++  char *bootfs = 0;
+   char *poolname;
+-  grub_uint64_t mdnobj;
++  grub_uint64_t mdnobj, devguid, poolguid;
++  int found;
+ 
+   if (argc < 1)
+     return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("one argument expected"));
+@@ -382,30 +397,56 @@
+   if (err)
+     return err;
+ 
++  found = grub_zfs_nvlist_lookup_uint64 (nvlist, ZPOOL_CONFIG_POOL_GUID,
++					    &poolguid);
++  if (!found)
++    {
++      if (!grub_errno)
++	grub_error(GRUB_ERR_BAD_FS, "No pool GUID found");
++      grub_free (nvlist);
++      return grub_errno;
++    }
++
++  found = grub_zfs_nvlist_lookup_uint64 (nvlist, ZPOOL_CONFIG_GUID,
++                                         &devguid);
++  if (!found)
++    {
++       if (!grub_errno)
++         grub_error(GRUB_ERR_BAD_FS, "No vdev GUID found");
++       grub_free (nvlist);
++       return grub_errno;
++    }
++
+   poolname = grub_zfs_nvlist_lookup_string (nvlist, ZPOOL_CONFIG_POOL_NAME);
+   if (!poolname)
+     {
+       if (!grub_errno)
+ 	grub_error (GRUB_ERR_BAD_FS, "No poolname found");
++      grub_free (nvlist);
+       return grub_errno;
+     }
+ 
+   nv = grub_zfs_nvlist_lookup_nvlist (nvlist, ZPOOL_CONFIG_VDEV_TREE);
+ 
+-  if (nv)
+-    get_bootpath (nv, &bootpath, &devid);
+-
++  if (nv && (get_bootpath (nv, devguid, &bootpath, &devid) == GRUB_ERR_NONE))
++   {
++      bootfs = grub_xasprintf ("zfs-bootfs=%s/%llu,zfs-vdevguid=%llu,"
++			   "zfs-poolguid=%llu%s%c%s%c%s%c%s%c", poolname,
++			   (unsigned long long) mdnobj,
++			   (unsigned long long) devguid,
++			   (unsigned long long) poolguid,
++			   bootpath ? ",bootpath=" : "",
++                           bootpath ? '"' : ' ',
++			   bootpath ? : "",
++			   bootpath ? '"' : ' ',
++			   devid ? ",diskdevid=" : "",
++                           devid ? '"' : ' ',
++			   devid ? : "",
++			   devid ? '"' : ' ');
++    }
+   grub_free (nv);
+   grub_free (nvlist);
+ 
+-  bootfs = grub_xasprintf ("zfs-bootfs=%s/%llu%s%s%s%s%s%s",
+-			   poolname, (unsigned long long) mdnobj,
+-			   bootpath ? ",bootpath=\"" : "",
+-			   bootpath ? : "",
+-			   bootpath ? "\"" : "",
+-			   devid ? ",diskdevid=\"" : "",
+-			   devid ? : "",
+-			   devid ? "\"" : "");
+   if (!bootfs)
+     return grub_errno;
+   if (argc >= 2)
+@@ -422,7 +463,152 @@
+ }
+ 
+ 
+-static grub_command_t cmd_info, cmd_bootfs;
++static grub_err_t
++grub_cmd_zfs_defaultbootfs (grub_command_t cmd __attribute__ ((unused)), int argc,
++		     char **args)
++{
++  grub_device_t dev;
++  char *devname = 0;
++  grub_err_t err;
++  char *nvlist = 0;
++  char *nv = 0;
++  char *bootpath = 0, *devid = 0;
++  char *bootfs = 0;
++  char *poolname;
++  char *bootfsname = 0;
++  grub_uint64_t mdnobj, devguid, poolguid;
++  int found;
++
++  if (argc < 1)
++    return grub_error (GRUB_ERR_BAD_ARGUMENT, "variable name required");
++
++  if (argc >= 2)
++    {
++      /* args[0] is the DEVICE name */
++      if (args[0][0] == '(' && args[0][grub_strlen (args[0]) - 1] == ')')
++        {
++          devname = grub_strdup (args[0] + 1);
++          if (devname)
++	    devname[grub_strlen (devname) - 1] = 0;
++        }
++      else
++        devname = grub_strdup (args[0]);
++    }
++  else		/* args[0] is the variable, we'll use root device */
++      devname = grub_strdup(grub_env_get("root"));
++
++  if (grub_errno)
++    {
++      grub_free(devname);
++      return grub_errno;
++    }
++
++  dev = grub_device_open (devname);
++  grub_free (devname);
++  if (!dev)
++    return grub_errno;
++
++  err = grub_zfs_fetch_nvlist (dev, &nvlist);
++  if (!err)
++    err = grub_zfs_defaultbootfsobj (dev, &mdnobj);
++
++  if (err)
++    {
++      grub_device_close (dev);
++      grub_free (nvlist);
++      return err;
++    }
++
++  err = grub_zfs_defaultbootfsname (dev, &bootfsname);
++
++  grub_device_close (dev);
++
++  if (err)
++    {
++      grub_free (nvlist);
++      return err;
++    }
++
++  if (argc >= 3)
++    {
++      found = grub_zfs_nvlist_lookup_uint64 (nvlist, ZPOOL_CONFIG_POOL_GUID,
++					    &poolguid);
++      if (!found)
++	{
++	  if (!grub_errno)
++	    grub_error(GRUB_ERR_BAD_FS, "No pool GUID found");
++	  grub_free (nvlist);
++	  grub_free (bootfsname);
++	  return grub_errno;
++	}
++
++      found = grub_zfs_nvlist_lookup_uint64 (nvlist, ZPOOL_CONFIG_GUID,
++					    &devguid);
++      if (!found)
++	{
++	  if (!grub_errno)
++	    grub_error(GRUB_ERR_BAD_FS, "No vdev GUID found");
++	  grub_free (nvlist);
++	  grub_free (bootfsname);
++	  return grub_errno;
++	}
++
++      poolname = grub_zfs_nvlist_lookup_string (nvlist, ZPOOL_CONFIG_POOL_NAME);
++      if (!poolname)
++	{
++	  if (!grub_errno)
++	    grub_error (GRUB_ERR_BAD_FS, "No poolname found");
++	  grub_free (nvlist);
++	  grub_free (bootfsname);
++	  return grub_errno;
++	}
++
++      nv = grub_zfs_nvlist_lookup_nvlist (nvlist, ZPOOL_CONFIG_VDEV_TREE);
++
++      if (nv && (get_bootpath (nv, devguid, &bootpath, &devid) == GRUB_ERR_NONE))
++        {
++          bootfs = grub_xasprintf ("zfs-bootfs=%s/%llu,zfs-vdevguid=%llu,"
++			          "zfs-poolguid=%llu%s%c%s%c%s%c%s%c", poolname,
++       			          (unsigned long long) mdnobj,
++			          (unsigned long long) devguid,
++			          (unsigned long long) poolguid,
++			          bootpath ? ",bootpath=" : "",
++                                  bootpath ? '"' : ' ',
++			          bootpath ? : "",
++			          bootpath ? '"' : ' ',
++			          devid ? ",diskdevid=" : "",
++                                  devid ? '"' : ' ',
++			          devid ? : "",
++			          devid ? '"' : ' ');
++	  grub_free (nv);
++	  grub_free (poolname);  
++	  grub_free (bootpath);
++	  grub_free (devid);
++	  if (!bootfs)
++	    {
++	      grub_free (nvlist);
++	      return grub_errno;
++	    }
++	  grub_dprintf ("zfs", "bootfs=%s\n", bootfs);
++	  grub_env_set (args[2], bootfs);
++	}
++    }
++
++  grub_dprintf ("zfs", "bootfsname=%s\n", bootfsname);
++
++  if (argc >= 2)
++    grub_env_set (args[1], bootfsname);
++  else
++    grub_env_set (args[0], bootfsname);
++
++  grub_free (nvlist);
++  grub_free (bootfs);
++  grub_free (bootfsname);
++
++  return GRUB_ERR_NONE;
++}
++
++static grub_command_t cmd_info, cmd_bootfs, cmd_defaultbootfs;
+ 
+ GRUB_MOD_INIT (zfsinfo)
+ {
+@@ -432,10 +618,14 @@
+   cmd_bootfs = grub_register_command ("zfs-bootfs", grub_cmd_zfs_bootfs,
+ 				      N_("FILESYSTEM [VARIABLE]"),
+ 				      N_("Print ZFS-BOOTFSOBJ or store it into VARIABLE"));
++  cmd_defaultbootfs = grub_register_command ("zfs-defaultbootfs", grub_cmd_zfs_defaultbootfs,
++				      N_("VARIABLE or zfs-defaultbootfs DEVICE VARIABLE-A or zfs-defaultbootfs DEVICE VARIABLE-A VARIABLE-B"),
++				      N_("Set default bootfs name of root device or given DEVICE to VARIABLE-A or set default bootfsname to VARIABLE-A and ZFS-BOOTFSOBJ to VARIABLE-B"));
+ }
+ 
+ GRUB_MOD_FINI (zfsinfo)
+ {
+   grub_unregister_command (cmd_info);
+   grub_unregister_command (cmd_bootfs);
++  grub_unregister_command (cmd_defaultbootfs);
+ }
diff -r 68f95e015346 usr/src/grub/patches/0016-gzio.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0016-gzio.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,17 @@
+# Source: Local, carried from 1.99
+# Patch for zvboot
+--- old/grub-core/io/gzio.c	2024-04-08 14:44:18.527989295 +0000
++++ new/grub-core/io/gzio.c	2024-04-08 14:44:17.121814101 +0000
+@@ -1192,7 +1192,10 @@
+  * Open a new decompressing object on the top of IO.
+  * Note that this function won't close IO, even if an error occurs.
+  */
+-static grub_file_t
++#ifndef ZVBOOT
++static
++#endif /* ZVBOOT */
++grub_file_t
+ grub_gzio_open (grub_file_t io, enum grub_file_type type)
+ {
+   grub_file_t file;
+
diff -r 68f95e015346 usr/src/grub/patches/0017-sb.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0017-sb.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,27 @@
+# Source: Local, new for 2.12
+# Disable shim lock verifier for Solaris, Verified Boot operates instead
+--- old/grub-core/kern/efi/sb.c	2024-04-08 14:44:18.687545325 +0000
++++ new/grub-core/kern/efi/sb.c	2024-04-08 14:44:17.147275875 +0000
+@@ -135,7 +135,10 @@
+     {
+     /* Files we check. */
+     case GRUB_FILE_TYPE_LINUX_KERNEL:
++/* On Solaris verified boot should be used */
++#ifndef __sun__
+     case GRUB_FILE_TYPE_MULTIBOOT_KERNEL:
++#endif
+     case GRUB_FILE_TYPE_BSD_KERNEL:
+     case GRUB_FILE_TYPE_XNU_KERNEL:
+     case GRUB_FILE_TYPE_PLAN9_KERNEL:
+@@ -144,6 +147,10 @@
+       return GRUB_ERR_NONE;
+ 
+     /* Files that do not affect secureboot state. */
++#ifdef __sun__
++    case GRUB_FILE_TYPE_MULTIBOOT_KERNEL:
++    case GRUB_FILE_TYPE_MULTIBOOT_MODULE:
++#endif
+     case GRUB_FILE_TYPE_NONE:
+     case GRUB_FILE_TYPE_LOOPBACK:
+     case GRUB_FILE_TYPE_LINUX_INITRD:
+
diff -r 68f95e015346 usr/src/grub/patches/0018-hostdisk.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0018-hostdisk.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,14 @@
+# Source: Local, new for 2.12
+# sector count correct from grub_util_get_fd_size already
+--- old/grub-core/kern/emu/hostdisk.c	2024-04-08 14:44:18.676264271 +0000
++++ new/grub-core/kern/emu/hostdisk.c	2024-04-08 14:44:17.172525574 +0000
+@@ -154,7 +154,7 @@
+ 
+     disk->total_sectors = grub_util_get_fd_size (fd, map[drive].device,
+ 						 &disk->log_sector_size);
+-    disk->total_sectors >>= disk->log_sector_size;
++    //disk->total_sectors >>= disk->log_sector_size;
+     disk->max_agglomerate = GRUB_DISK_MAX_MAX_AGGLOMERATE;
+ 
+ #if GRUB_UTIL_FD_STAT_IS_FUNCTIONAL
+
diff -r 68f95e015346 usr/src/grub/patches/0019-pxe.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0019-pxe.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,20 @@
+# Source: Local, carried from 1.99
+# Move net card unregister to fini so mbi gets network config to pass to OS
+--- old/grub-core/net/drivers/i386/pc/pxe.c	2024-04-08 14:44:41.331500406 +0000
++++ new/grub-core/net/drivers/i386/pc/pxe.c	2024-04-08 14:44:38.720159144 +0000
+@@ -329,7 +329,6 @@
+ 		 (void *) GRUB_MEMORY_MACHINE_SCRATCH_ADDR,
+ 		 pxe_rm_entry);
+   pxe_rm_entry = 0;
+-  grub_net_card_unregister (&grub_pxe_card);
+ 
+   return GRUB_ERR_NONE;
+ }
+@@ -415,5 +414,6 @@
+ {
+   grub_pc_net_config = 0;
+   grub_pxe_shutdown (0);
++  grub_net_card_unregister (&grub_pxe_card);
+   grub_loader_unregister_preboot_hook (fini_hnd);
+ }
+
diff -r 68f95e015346 usr/src/grub/patches/0020-sun-hostdisk.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0020-sun-hostdisk.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,14 @@
+# Source: Local, new for 2.12
+# Fix incorrect check for ioctl return
+--- old/grub-core/osdep/sun/hostdisk.c	2024-04-08 14:44:39.875229030 +0000
++++ new/grub-core/osdep/sun/hostdisk.c	2024-04-08 14:44:38.543940946 +0000
+@@ -50,7 +50,7 @@
+   struct dk_minfo minfo;
+   unsigned sector_size, log_sector_size;
+ 
+-  if (!ioctl (fd, DKIOCGMEDIAINFO, &minfo))
++  if (ioctl (fd, DKIOCGMEDIAINFO, &minfo))
+     return -1;
+ 
+   sector_size = minfo.dki_lbsize;
+
diff -r 68f95e015346 usr/src/grub/patches/0021-getroot.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0021-getroot.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,84 @@
+# Source: Local, adapted from 1.99
+# Modify search order for ZFS
+--- old/grub-core/osdep/unix/getroot.c	2024-04-08 14:44:40.713971417 +0000
++++ new/grub-core/osdep/unix/getroot.c	2024-04-08 14:44:38.669588500 +0000
+@@ -397,12 +397,14 @@
+ 	     may be something like /dev/dm-0, but the names under
+ 	     /dev/mapper/ are more human-readable and so we prefer them if
+ 	     we can get them.  */
++#endif
+ 	  if (stat (ent->d_name, &st) < 0)
+ 	    continue;
++#ifdef __linux__
+ 	} else
+-#endif /* __linux__ */
+ 	/* Don't follow other symbolic links.  */
+ 	continue;
++#endif /* __linux__ */
+       }
+ 
+       if (S_ISDIR (st.st_mode))
+@@ -493,6 +495,7 @@
+ grub_guess_root_devices (const char *dir_in)
+ {
+   char **os_dev = NULL;
++  char **zdev = NULL;
+   struct stat st;
+   dev_t dev;
+   char *dir = grub_canonicalize_file_name (dir_in);
+@@ -505,9 +508,6 @@
+     os_dev = grub_find_root_devices_from_mountinfo (dir, NULL);
+ #endif /* __linux__ */
+ 
+-  if (!os_dev)
+-    os_dev = find_root_devices_from_libzfs (dir);
+-
+   if (os_dev)
+     {
+       char **cur;
+@@ -545,7 +545,6 @@
+ 
+   if (stat (dir, &st) < 0)
+     grub_util_error (_("cannot stat `%s': %s"), dir, strerror (errno));
+-  free (dir);
+ 
+   dev = st.st_dev;
+ 
+@@ -556,7 +555,19 @@
+ 
+   if (!os_dev[0])
+     {
++    zdev = find_root_devices_from_libzfs (dir);
++    free (dir);
++    if (zdev)
++      {
+       free (os_dev);
++      return zdev;
++      }
++    }
++
++  free (dir);
++  if (!os_dev[0])
++    {
++      free (os_dev);
+       return 0;
+     }
+ 
+@@ -691,6 +702,8 @@
+     struct stat st;
+     struct extmnttab mnt;
+ 
++    grub_util_info ("finding zpool from dir %s", dir);
++
+     if (stat (dir, &st) != 0)
+       return;
+ 
+@@ -700,6 +713,7 @@
+ 
+     while (getextmntent (mnttab, &mnt, sizeof (mnt)) == 0)
+       {
++	grub_util_info ("checking device for %s", mnt.mnt_special);
+ 	if (makedev (mnt.mnt_major, mnt.mnt_minor) == st.st_dev
+ 	    && !strcmp (mnt.mnt_fstype, "zfs"))
+ 	  {
+
diff -r 68f95e015346 usr/src/grub/patches/0022-kernel.h.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0022-kernel.h.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,14 @@
+# Source: Local, new for 2.12
+# Add ZVBOOT to define GRUB_KERNEL_PRELOAD_SPACE_REUSABLE
+--- old/include/grub/kernel.h	2024-04-08 14:44:40.048921727 +0000
++++ new/include/grub/kernel.h	2024-04-08 14:44:38.693980110 +0000
+@@ -77,7 +77,7 @@
+ #define GRUB_KERNEL_PRELOAD_SPACE_REUSABLE 0
+ #endif
+ 
+-#if defined (GRUB_MACHINE_PCBIOS) || defined (GRUB_MACHINE_COREBOOT) \
++#if defined (ZVBOOT) || defined (GRUB_MACHINE_PCBIOS) || defined (GRUB_MACHINE_COREBOOT) \
+   || defined (GRUB_MACHINE_MULTIBOOT) || defined (GRUB_MACHINE_MIPS_QEMU_MIPS) \
+   || defined (GRUB_MACHINE_MIPS_LOONGSON) || defined (GRUB_MACHINE_ARC) \
+   || (defined (__sparc__) && defined (GRUB_MACHINE_IEEE1275)) \
+
diff -r 68f95e015346 usr/src/grub/patches/0023-msdos_partition.h.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0023-msdos_partition.h.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,21 @@
+# Source: Local, carried from 1.99
+# Define Sun partition types
+--- old/include/grub/msdos_partition.h	2024-04-08 14:44:40.142599989 +0000
++++ new/include/grub/msdos_partition.h	2024-04-08 14:44:38.669595589 +0000
+@@ -48,6 +48,7 @@
+ #define GRUB_PC_PARTITION_TYPE_MINIX		0x80
+ #define GRUB_PC_PARTITION_TYPE_LINUX_MINIX	0x81
+ #define GRUB_PC_PARTITION_TYPE_LINUX_SWAP	0x82
++#define GRUB_PC_PARTITION_LEGACY_SUNIXOS	GRUB_PC_PARTITION_TYPE_LINUX_SWAP
+ #define GRUB_PC_PARTITION_TYPE_EXT2FS		0x83
+ #define GRUB_PC_PARTITION_TYPE_LINUX_EXTENDED	0x85
+ #define GRUB_PC_PARTITION_TYPE_VSTAFS		0x9e
+@@ -55,6 +56,7 @@
+ #define GRUB_PC_PARTITION_TYPE_OPENBSD		0xa6
+ #define GRUB_PC_PARTITION_TYPE_NETBSD		0xa9
+ #define GRUB_PC_PARTITION_TYPE_HFS		0xaf
++#define GRUB_PC_PARTITION_SUNIXOS		0xbf
+ #define GRUB_PC_PARTITION_TYPE_GPT_DISK		0xee
+ #define GRUB_PC_PARTITION_TYPE_LINUX_RAID	0xfd
+ 
+
diff -r 68f95e015346 usr/src/grub/patches/0024-install.h.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0024-install.h.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,23 @@
+# SourceL Local, adapted from 1.99
+# Add root and force_mbr arguments
+--- old/include/grub/util/install.h	2024-05-09 08:15:20.322700308 -0700
++++ new/include/grub/util/install.h	2024-07-05 12:26:06.675000221 -0700
+@@ -199,14 +199,14 @@
+ void
+ grub_util_bios_setup (const char *dir,
+ 		      const char *boot_file, const char *core_file,
+-		      const char *dest, int force,
+-		      int fs_probe, int allow_floppy,
++		      char *root, const char *dest, int force,
++		      int fs_probe, int allow_floppy, int force_mbr,
+ 		      int add_rs_codes, int warn_short_mbr_gap);
+ void
+ grub_util_sparc_setup (const char *dir,
+ 		       const char *boot_file, const char *core_file,
+-		       const char *dest, int force,
+-		       int fs_probe, int allow_floppy,
++		       char *root, const char *dest, int force,
++		       int fs_probe, int allow_floppy, int force_mbr,
+ 		       int add_rs_codes, int warn_short_mbr_gap);
+ 
+ char *
diff -r 68f95e015346 usr/src/grub/patches/0025-dmu.h.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0025-dmu.h.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,54 @@
+# Source: Local, carried from 1.99
+# DMU definitions
+--- old/include/grub/zfs/dmu.h	2024-04-08 14:44:57.294920074 +0000
++++ new/include/grub/zfs/dmu.h	2024-04-08 14:44:55.489894532 +0000
+@@ -1,6 +1,7 @@
+ /*
+  *  GRUB  --  GRand Unified Bootloader
+  *  Copyright (C) 1999,2000,2001,2002,2003,2004  Free Software Foundation, Inc.
++ *  Copyright (c) 2010, 2018 Oracle and/or its affiliates. All rights reserved
+  *
+  *  GRUB is free software; you can redistribute it and/or modify
+  *  it under the terms of the GNU General Public License as published by
+@@ -15,10 +16,6 @@
+  *  You should have received a copy of the GNU General Public License
+  *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+  */
+-/*
+- * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+- * Use is subject to license terms.
+- */
+ 
+ #ifndef	_SYS_DMU_H
+ #define	_SYS_DMU_H
+@@ -122,6 +119,12 @@
+ 	DMU_OT_SA_ATTR_REGISTRATION,	/* ZAP */
+ 	DMU_OT_SA_ATTR_LAYOUTS,		/* ZAP */
+ 	DMU_OT_DSL_KEYCHAIN = 54,
++	DMU_OT_SHARE,			/* UINT64 */
++	DMU_OT_DSL_SHARES,		/* ZAP */
++	DMU_OT_BPMAP_ARRAY,
++	DMU_OT_BPMAP_DEFER,
++	DMU_OT_BPMAP_HEADER,
++	DMU_OT_INTENT_LOG_INMAP,	/* UINT64 */
+ 	DMU_OT_NUMTYPES,
+ 	DMU_OTN_UINT8_DATA = DMU_OT(DMU_BSWAP_UINT8, B_FALSE),
+ 	DMU_OTN_UINT8_METADATA = DMU_OT(DMU_BSWAP_UINT8, B_TRUE),
+@@ -142,6 +145,7 @@
+ 	DMU_OST_ZVOL,
+ 	DMU_OST_OTHER,			/* For testing only! */
+ 	DMU_OST_ANY,			/* Be careful! */
++	DMU_OST_PSEUDO,
+ 	DMU_OST_NUMTYPES
+ } dmu_objset_type_t;
+ 
+@@ -159,6 +163,8 @@
+ #define	DMU_POOL_HISTORY		"history"
+ #define	DMU_POOL_PROPS			"pool_props"
+ #define	DMU_POOL_L2CACHE		"l2cache"
++#define DMU_POOL_BMAP_OBJ		"bpmap-vdev-%llu-%llu"
++#define	DMU_POOL_BPMAP_DEFER		"bpmap_defer_obj"
+ #define	DMU_POOL_FEATURES_FOR_READ	"features_for_read"
+ 
+ #endif	/* _SYS_DMU_H */
+
diff -r 68f95e015346 usr/src/grub/patches/0026-zfs.h.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0026-zfs.h.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,35 @@
+# Source: Local, adapted from 1.99
+# Current SPA_VERSION, declare bootfsobj bootfsname
+--- old/include/grub/zfs/zfs.h	2024-04-08 14:44:57.272998358 +0000
++++ new/include/grub/zfs/zfs.h	2024-04-08 14:44:55.489871133 +0000
+@@ -16,7 +16,7 @@
+  *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+  */
+  /*
+-  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
++  * Copyright (c) 2007, 2024, Oracle and/or its affiliates.
+   */
+ 
+ #ifndef	GRUB_ZFS_HEADER
+@@ -36,8 +36,9 @@
+ /*
+  * On-disk version number.
+  */
++#define SPA_VERSION			52ULL
+ #define	SPA_VERSION_INITIAL		1ULL
+-#define	SPA_VERSION_BEFORE_FEATURES	33ULL
++#define	SPA_VERSION_BEFORE_FEATURES	52ULL
+ #define	SPA_VERSION_FEATURES		5000ULL
+ #define	SPA_VERSION_IS_SUPPORTED(v) \
+ 	(((v) >= SPA_VERSION_INITIAL && (v) <= SPA_VERSION_BEFORE_FEATURES) || \
+@@ -125,6 +126,9 @@
+ grub_err_t grub_zfs_getmdnobj (grub_device_t dev, const char *fsfilename,
+ 			       grub_uint64_t *mdnobj);
+ 
++grub_err_t grub_zfs_defaultbootfsobj (grub_device_t dev, grub_uint64_t *mdnobj);
++grub_err_t grub_zfs_defaultbootfsname (grub_device_t dev, char **bootfsname);
++
+ char *grub_zfs_nvlist_lookup_string (const char *nvlist, const char *name);
+ char *grub_zfs_nvlist_lookup_nvlist (const char *nvlist, const char *name);
+ int grub_zfs_nvlist_lookup_uint64 (const char *nvlist, const char *name,
+
diff -r 68f95e015346 usr/src/grub/patches/0027-zfs_znode.h.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0027-zfs_znode.h.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,24 @@
+# Source: Local, adapted from 1.99
+# ZPL_VERSION
+--- old/include/grub/zfs/zfs_znode.h	2024-04-08 14:44:57.385115328 +0000
++++ new/include/grub/zfs/zfs_znode.h	2024-04-08 14:44:55.489814445 +0000
+@@ -30,7 +30,7 @@
+ #define	ZPL_VERSION_STR		"VERSION"
+ #define	ZFS_SA_ATTRS		"SA_ATTRS"
+ 
+-#define	ZPL_VERSION		5ULL
++#define	ZPL_VERSION		8ULL
+ 
+ #define	ZFS_DIRENT_OBJ(de) BF64_GET(de, 0, 48)
+ 
+@@ -54,7 +54,8 @@
+ 	grub_uint64_t zp_flags;		/* 120 - persistent flags */
+ 	grub_uint64_t zp_uid;		/* 128 - file owner */
+ 	grub_uint64_t zp_gid;		/* 136 - owning group */
+-	grub_uint64_t zp_pad[4];	/* 144 - future */
++	grub_uint64_t zp_zap;		/* 144 - extra attributes */
++	grub_uint64_t zp_pad[3];	/* 152 - future */
+ 	zfs_znode_acl_t zp_acl;		/* 176 - 263 ACL */
+ 	/*
+ 	 * Data may pad out any remaining bytes in the znode buffer, eg:
+
diff -r 68f95e015346 usr/src/grub/patches/0028-grub-install.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0028-grub-install.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,120 @@
+# Source: Local, adapted from 1.99
+# Add --grub-directory and --force-mbr options
+--- old/util/grub-install.c	2024-05-09 08:15:20.415237178 -0700
++++ new/util/grub-install.c	2024-07-08 06:15:31.677639058 -0700
+@@ -61,6 +61,7 @@
+ static char *debug_image = NULL;
+ static char *rootdir = NULL;
+ static char *bootdir = NULL;
++static char *gruboverdir = NULL;
+ static int allow_floppy = 0;
+ static int force_file_id = 0;
+ static char *disk_module = NULL;
+@@ -79,6 +80,7 @@
+ static char *label_bgcolor;
+ static char *product_version;
+ static int add_rs_codes = 1;
++static int force_mbr = 0; 
+ 
+ enum
+   {
+@@ -109,7 +111,9 @@
+     OPTION_LABEL_FONT,
+     OPTION_LABEL_COLOR,
+     OPTION_LABEL_BGCOLOR,
+-    OPTION_PRODUCT_VERSION
++    OPTION_PRODUCT_VERSION,
++    OPTION_FORCE_MBR,
++    OPTION_GRUB_DIRECTORY
+   };
+ 
+ static int fs_probe = 1;
+@@ -171,6 +175,11 @@
+       bootdir = xstrdup (arg);
+       return 0;
+ 
++    case OPTION_GRUB_DIRECTORY:
++      free (gruboverdir);
++      gruboverdir = xstrdup (arg);
++      return 0;
++
+     case OPTION_MACPPC_DIRECTORY:
+       free (macppcdir);
+       macppcdir = xstrdup (arg);
+@@ -233,6 +242,10 @@
+       bootloader_id = xstrdup (arg);
+       return 0;
+ 
++    case OPTION_FORCE_MBR:
++       force_mbr = 1;
++       return 0; 
++
+     case ARGP_KEY_ARG:
+       if (install_device)
+ 	grub_util_error ("%s", _("More than one install device?"));
+@@ -249,6 +262,8 @@
+   GRUB_INSTALL_OPTIONS,
+   {"boot-directory", OPTION_BOOT_DIRECTORY, N_("DIR"),
+    0, N_("install GRUB images under the directory DIR/%s instead of the %s directory"), 2},
++  {"grub-directory", OPTION_GRUB_DIRECTORY, N_("DIR"),
++   OPTION_HIDDEN, 0, 2},
+   {"root-directory", OPTION_ROOT_DIRECTORY, N_("DIR"),
+    OPTION_HIDDEN, 0, 2},
+   {"font", OPTION_FONT, N_("FILE"),
+@@ -302,6 +317,7 @@
+   {"label-color", OPTION_LABEL_COLOR, N_("COLOR"), 0, N_("use COLOR for label"), 2},
+   {"label-bgcolor", OPTION_LABEL_BGCOLOR, N_("COLOR"), 0, N_("use COLOR for label background"), 2},
+   {"product-version", OPTION_PRODUCT_VERSION, N_("STRING"), 0, N_("use STRING as product version"), 2},
++  {"force-mbr", OPTION_FORCE_MBR, 0, 0, N_("[i386-pc ONLY] GRUB first stage will be written to the MBR instead of the PBR"), 0},
+   {0, 0, 0, 0, 0, 0}
+ };
+ 
+@@ -1010,6 +1026,9 @@
+       grub_util_error (_("failed to get canonical path of `%s'"), t);
+     free (t);
+   }
++  if (gruboverdir != NULL)
++    grubdir = gruboverdir;
++
+   device_map = grub_util_path_concat (2, grubdir, "device.map");
+ 
+   if (recheck)
+@@ -1753,7 +1772,7 @@
+ 					      "boot.img");
+ 	grub_install_copy_file (boot_img_src, boot_img, 1);
+ 
+-	grub_util_info ("%sgrub-bios-setup %s %s %s %s %s --directory='%s' --device-map='%s' '%s'",
++	grub_util_info ("%sgrub-bios-setup %s %s %s %s %s %s --directory='%s' --device-map='%s' '%s'",
+ 			/* TRANSLATORS: This is a prefix in the log to indicate that usually
+ 			   a command would be executed but due to an option was skipped.  */
+ 			install_bootsector ? "" : _("NOT RUNNING: "),
+@@ -1762,6 +1781,7 @@
+ 			force ? "--force " : "",
+ 			!fs_probe ? "--skip-fs-probe" : "",
+ 			!add_rs_codes ? "--no-rs-codes" : "",
++			force_mbr ? "--force-mbr" : "",
+ 			platdir,
+ 			device_map,
+ 			install_device);
+@@ -1770,8 +1790,8 @@
+ 	if (install_bootsector)
+ 	  {
+ 	    grub_util_bios_setup (platdir, "boot.img", "core.img",
+-				  install_drive, force,
+-				  fs_probe, allow_floppy, add_rs_codes,
++				  NULL, install_drive, force,
++				  fs_probe, allow_floppy, force_mbr, add_rs_codes,
+ 				  !grub_install_is_short_mbrgap_supported ());
+ 
+ 	    grub_set_install_backup_ponr ();
+@@ -1801,8 +1821,8 @@
+ 	if (install_bootsector)
+ 	  {
+ 	    grub_util_sparc_setup (platdir, "boot.img", "core.img",
+-				   install_drive, force,
+-				   fs_probe, allow_floppy,
++				   NULL, install_drive, force,
++				   fs_probe, allow_floppy, 0,
+ 				   0 /* unused */, 0 /* unused */ );
+ 
+ 	    grub_set_install_backup_ponr ();
diff -r 68f95e015346 usr/src/grub/patches/0029-grub-setup.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0029-grub-setup.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,80 @@
+# Source: Local, adapted from 1.99
+# Add --root-device and --force-mbr options
+--- old/util/grub-setup.c	2024-05-09 08:15:20.400182282 -0700
++++ new/util/grub-setup.c	2024-07-08 06:20:25.811428064 -0700
+@@ -83,6 +83,10 @@
+    N_("use GRUB files in the directory DIR [default=%s]"), 0},
+   {"device-map",  'm', N_("FILE"), 0,
+    N_("use FILE as the device map [default=%s]"), 0},
++  {"root-device", 'r', N_("DEV"),  0,
++   N_("Use DEV as the root device [default=guessed]"), 0},
++  {"force-mbr",   'M', 0,      0,
++   N_("Write the GRUB2 first stage loader to the MBR regardless of the destination"), 0},
+   {"force",       'f', 0,      0,
+    N_("install even if problems are detected"), 0},
+   {"skip-fs-probe",'s',0,      0,
+@@ -130,11 +134,13 @@
+   char *core_file;
+   char *dir;
+   char *dev_map;
++  char *root_dev;
+   int  force;
+   int  fs_probe;
+   int allow_floppy;
+   char *device;
+   int add_rs_codes;
++  int force_mbr;
+ };
+ 
+ static error_t
+@@ -178,6 +184,17 @@
+         arguments->dev_map = xstrdup (arg);
+         break;
+ 
++      case 'M':
++        arguments->force_mbr = 1;
++        break;
++
++      case 'r':
++        if (arguments->root_dev)
++          free (arguments->root_dev);
++
++        arguments->root_dev = xstrdup (arg);
++        break;
++
+       case 'f':
+         arguments->force = 1;
+         break;
+@@ -309,12 +326,23 @@
+       grub_util_info ("Using `%s' as GRUB device", dest_dev);
+     }
+ 
++  if (arguments.root_dev)
++    {
++      root_dev = get_device_name (arguments.root_dev);
++
++      if (! root_dev)
++        grub_util_error (_("invalid root device `%s'"), arguments.root_dev);
++
++      root_dev = xstrdup (root_dev);
++    }
++
+   /* Do the real work.  */
+   GRUB_SETUP_FUNC (arguments.dir ? : DEFAULT_DIRECTORY,
+ 		   arguments.boot_file ? : DEFAULT_BOOT_FILE,
+ 		   arguments.core_file ? : DEFAULT_CORE_FILE,
+-		   dest_dev, arguments.force,
++		   root_dev, dest_dev, arguments.force,
+ 		   arguments.fs_probe, arguments.allow_floppy,
++		   arguments.force_mbr,
+ 		   arguments.add_rs_codes, 0);
+ 
+   /* Free resources.  */
+@@ -326,6 +354,7 @@
+   free (arguments.dir);
+   free (arguments.dev_map);
+   free (arguments.device);
++  free (arguments.root_dev);
+   free (root_dev);
+   free (dest_dev);
+ 
diff -r 68f95e015346 usr/src/grub/patches/0030-setup.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0030-setup.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,98 @@
+# Source: Local, adapted from 1.99
+# Add root and force_mbr options
+--- old/util/setup.c	2024-05-09 08:15:20.368547990 -0700
++++ new/util/setup.c	2024-07-08 06:26:33.509786265 -0700
+@@ -252,17 +252,16 @@
+ void
+ SETUP (const char *dir,
+        const char *boot_file, const char *core_file,
+-       const char *dest, int force,
+-       int fs_probe, int allow_floppy,
++       char *root, const char *dest, int force,
++       int fs_probe, int allow_floppy, int force_mbr,
+        int add_rs_codes __attribute__ ((unused)), /* unused on sparc64 */
+        int warn_small)
+ {
+   char *core_path;
+   char *boot_img, *core_img, *boot_path;
+-  char *root = 0;
+   size_t boot_size, core_size;
+   grub_uint16_t core_sectors;
+-  grub_device_t root_dev = 0, dest_dev, core_dev;
++  grub_device_t root_dev = 0, dest_dev, core_dev, mbr_dev;
+   grub_util_fd_t fp;
+   struct blocklists bl;
+ 
+@@ -311,6 +310,7 @@
+ 
+   core_dev = dest_dev;
+ 
++  if (root == 0)
+   {
+     char **root_devices = grub_guess_root_devices (dir);
+     char **cur;
+@@ -364,12 +364,36 @@
+     for (cur = root_devices; *cur; cur++)
+       free (*cur);
+     free (root_devices);
+-  }
++  } else {
++    /* Open the root device and the destination device.  */
++    grub_util_info ("Opening root");
++    root_dev = grub_device_open (root);
++    if (! root_dev)
++      grub_util_error ("%s", _(grub_errmsg));
++   }
+ 
++
+   grub_util_info ("setting the root device to `%s'", root);
+   if (grub_env_set ("root", root) != GRUB_ERR_NONE)
+     grub_util_error ("%s", grub_errmsg);
+ 
++  if (force_mbr)
++    {
++      char *mbr_dest = strdup(dest);
++      char *comma = strchr(mbr_dest, ',');
++      if (comma)
++        {
++          *comma = 0;
++          mbr_dev = grub_device_open(mbr_dest);
++          if (! mbr_dev)
++            grub_util_error ("%s", grub_errmsg);
++        }
++      else
++        mbr_dev = NULL;
++    }
++  else
++    mbr_dev = NULL;
++
+   {
+ #ifdef GRUB_SETUP_BIOS
+     char *tmp_img;
+@@ -377,7 +401,7 @@
+ 
+     /* Read the original sector from the disk.  */
+     tmp_img = xmalloc (GRUB_DISK_SECTOR_SIZE);
+-    if (grub_disk_read (dest_dev->disk, 0, 0, GRUB_DISK_SECTOR_SIZE, tmp_img))
++    if (grub_disk_read ((mbr_dev ? : dest_dev)->disk, 0, 0, GRUB_DISK_SECTOR_SIZE, tmp_img))
+       grub_util_error ("%s", grub_errmsg);
+ 
+     boot_drive_check = (grub_uint8_t *) (boot_img
+@@ -857,7 +881,8 @@
+ #endif
+ 
+   /* Write the boot image onto the disk.  */
+-  if (grub_disk_write (dest_dev->disk, BOOT_SECTOR,
++  grub_util_info("writing boot image to %s", mbr_dev ? "mbr_dev": "dest_dev");
++  if (grub_disk_write ((mbr_dev ? : dest_dev)->disk, BOOT_SECTOR,
+ 		       0, GRUB_DISK_SECTOR_SIZE, boot_img))
+     grub_util_error ("%s", grub_errmsg);
+ 
+@@ -873,5 +898,7 @@
+   free (boot_img);
+   grub_device_close (dest_dev);
+   grub_device_close (root_dev);
++  if (mbr_dev)
++    grub_device_close (mbr_dev);
+ }
+ 
diff -r 68f95e015346 usr/src/grub/patches/0031-menu_text.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0031-menu_text.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,13 @@
+# Source: Local, new for 2.12
+# Ignore format warnings
+--- old/grub-core/normal/menu_text.c	2024-04-08 14:44:39.823617705 +0000
++++ new/grub-core/normal/menu_text.c	2024-04-08 14:44:38.453040930 +0000
+@@ -27,6 +27,7 @@
+ #include <grub/menu_viewer.h>
+ #include <grub/i18n.h>
+ #include <grub/charset.h>
++#pragma GCC diagnostic ignored "-Wformat" 
+ 
+ static grub_uint8_t grub_color_menu_normal;
+ static grub_uint8_t grub_color_menu_highlight;
+
diff -r 68f95e015346 usr/src/grub/patches/0032-gentpl.py.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0032-gentpl.py.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,31 @@
+# Source: Local, adapted from 1.99
+# Don't install debug modules and images to proto area
+--- old/./gentpl.py      2023-06-13 12:07:22.000000000 +0000
++++ new/./gentpl.py      2024-04-24 16:13:17.635962122 +0000
+@@ -680,7 +680,7 @@
+     name = defn['name']
+     set_canonical_name_suffix(".module")
+
+-    gvar_add("platform_PROGRAMS", name + ".module")
++    gvar_add("noinst_PROGRAMS", name + ".module")
+     gvar_add("MODULE_FILES", name + ".module$(EXEEXT)")
+
+     var_set(cname(defn) + "_SOURCES", platform_sources(defn, platform) + " ## platform sources")
+@@ -708,7 +708,7 @@
+ def kernel(defn, platform):
+     name = defn['name']
+     set_canonical_name_suffix(".exec")
+-    gvar_add("platform_PROGRAMS", name + ".exec")
++    gvar_add("noinst_PROGRAMS", name + ".exec")
+     var_set(cname(defn) + "_SOURCES", platform_startup(defn, platform))
+     var_add(cname(defn) + "_SOURCES", platform_sources(defn, platform))
+     var_set("nodist_" + cname(defn) + "_SOURCES", platform_nodist_sources(defn, platform) + " ## platform nodist sources")
+@@ -747,7 +747,7 @@
+ def image(defn, platform):
+     name = defn['name']
+     set_canonical_name_suffix(".image")
+-    gvar_add("platform_PROGRAMS", name + ".image")
++    gvar_add("noinst_PROGRAMS", name + ".image")
+     var_set(cname(defn) + "_SOURCES", platform_sources(defn, platform))
+     var_set("nodist_" + cname(defn) + "_SOURCES", platform_nodist_sources(defn, platform) + "## platform nodist sources")
+     var_set(cname(defn) + "_LDADD", platform_ldadd(defn, platform))
diff -r 68f95e015346 usr/src/grub/patches/0033-grub-mkconfig.in.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0033-grub-mkconfig.in.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,14 @@
+# Source: Local, adapted from 1.99
+# Add GRUB_BOOTMGMT_DEFAULT_ZPOOL to environment for grub-mkconfig scripts
+--- old/util/grub-mkconfig.in	2024-05-09 08:15:20.443378449 -0700
++++ new/util/grub-mkconfig.in	2024-05-13 11:06:45.979341538 -0700
+@@ -255,7 +255,8 @@
+   GRUB_ENABLE_CRYPTODISK \
+   GRUB_BADRAM \
+   GRUB_OS_PROBER_SKIP_LIST \
+-  GRUB_DISABLE_SUBMENU
++  GRUB_DISABLE_SUBMENU \
++  GRUB_BOOTMGMT_DEFAULT_ZPOOL
+ 
+ if test "x${grub_cfg}" != "x"; then
+   rm -f "${grub_cfg}.new"
diff -r 68f95e015346 usr/src/grub/patches/0034-Add-noescape-argument-to-cmdline-creation.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0034-Add-noescape-argument-to-cmdline-creation.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,399 @@
+# Source: upstream
+From cadef71f275af55740e33a6f6f7f86b5bd004855 Mon Sep 17 00:00:00 2001
+From: Vladimir Serbinenko <phcoder@gmail.com>
+Date: Wed, 19 Jul 2023 15:09:47 +0200
+Subject: [PATCH 1/4] Add "noescape" argument to cmdline creation
+
+If OS parses in a way different from sh-like that GRUB does, escaping does
+more harm than good. Note that allows to specify entire command line in a
+single argument e.g. multiboot --noescape /kernel "a b c".
+
+This is needed to boot Solaris/Illumos on some boot paths that need quotes.
+
+Signed-off-by: Vladimir Serbinenko <phcoder@gmail.com>
+---
+ grub-core/lib/cmdline.c                   | 40 ++++++++++++++---------
+ grub-core/loader/arm/linux.c              |  4 +--
+ grub-core/loader/arm64/xen_boot.c         |  4 +--
+ grub-core/loader/efi/linux.c              |  4 +--
+ grub-core/loader/i386/linux.c             |  2 +-
+ grub-core/loader/i386/multiboot_mbi.c     |  8 ++---
+ grub-core/loader/i386/pc/linux.c          |  2 +-
+ grub-core/loader/i386/xen.c               |  6 ++--
+ grub-core/loader/mips/linux.c             |  4 +--
+ grub-core/loader/multiboot_mbi2.c         |  8 ++---
+ grub-core/loader/powerpc/ieee1275/linux.c |  4 +--
+ grub-core/loader/sparc64/ieee1275/linux.c |  4 +--
+ include/grub/lib/cmdline.h                |  5 +--
+ 13 files changed, 52 insertions(+), 43 deletions(-)
+
+diff --git a/grub-core/lib/cmdline.c b/grub-core/lib/cmdline.c
+index ed0b149dc..715392fac 100644
+--- a/grub-core/lib/cmdline.c
++++ b/grub-core/lib/cmdline.c
+@@ -45,14 +45,14 @@ static unsigned int check_arg (char *c, int *has_space)
+   return size;
+ }
+ 
+-unsigned int grub_loader_cmdline_size (int argc, char *argv[])
++unsigned int grub_loader_cmdline_size (int argc, char *argv[], int noescape)
+ {
+   int i;
+   unsigned int size = 0;
+ 
+   for (i = 0; i < argc; i++)
+     {
+-      size += check_arg (argv[i], 0);
++      size += noescape ? grub_strlen(argv[i]) : check_arg (argv[i], 0);
+       size++; /* Separator space or NULL.  */
+     }
+ 
+@@ -64,16 +64,17 @@ unsigned int grub_loader_cmdline_size (int argc, char *argv[])
+ 
+ grub_err_t
+ grub_create_loader_cmdline (int argc, char *argv[], char *buf,
+-			    grub_size_t size, enum grub_verify_string_type type)
++			    grub_size_t size, enum grub_verify_string_type type,
++			    int noescape)
+ {
+-  int i, space;
++  int i, space = 0;
+   unsigned int arg_size;
+   char *c, *orig_buf = buf;
+ 
+   for (i = 0; i < argc; i++)
+     {
+       c = argv[i];
+-      arg_size = check_arg(argv[i], &space);
++      arg_size = noescape ? grub_strlen(argv[i]) : check_arg(argv[i], &space);
+       arg_size++; /* Separator space or NULL.  */
+ 
+       if (size < arg_size)
+@@ -81,21 +82,28 @@ grub_create_loader_cmdline (int argc, char *argv[], char *buf,
+ 
+       size -= arg_size;
+ 
+-      if (space)
+-	*buf++ = '"';
+-
+-      while (*c)
++      if (noescape)
+ 	{
+-	  if (*c == '\\' || *c == '\'' || *c == '"')
+-	    *buf++ = '\\';
+-
+-	  *buf++ = *c;
+-	  c++;
++	  grub_memcpy(buf, c, arg_size);
++	  buf += arg_size - 1;
+ 	}
++      else
++	{
++	  if (space)
++	    *buf++ = '"';
+ 
+-      if (space)
+-	*buf++ = '"';
++	  while (*c)
++	    {
++	      if (*c == '\\' || *c == '\'' || *c == '"')
++		*buf++ = '\\';
+ 
++	      *buf++ = *c;
++	      c++;
++	    }
++
++	  if (space)
++	    *buf++ = '"';
++	}
+       *buf++ = ' ';
+     }
+ 
+diff --git a/grub-core/loader/arm/linux.c b/grub-core/loader/arm/linux.c
+index 19ddedbc2..6a052a0da 100644
+--- a/grub-core/loader/arm/linux.c
++++ b/grub-core/loader/arm/linux.c
+@@ -375,7 +375,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
+ 
+   grub_loader_set (linux_boot, linux_unload, 0);
+ 
+-  size = grub_loader_cmdline_size (argc, argv);
++  size = grub_loader_cmdline_size (argc, argv, 0);
+   linux_args = grub_malloc (size + sizeof (LINUX_IMAGE));
+   if (!linux_args)
+     {
+@@ -387,7 +387,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
+   grub_memcpy (linux_args, LINUX_IMAGE, sizeof (LINUX_IMAGE));
+   err = grub_create_loader_cmdline (argc, argv,
+ 				    linux_args + sizeof (LINUX_IMAGE) - 1, size,
+-				    GRUB_VERIFY_KERNEL_CMDLINE);
++				    GRUB_VERIFY_KERNEL_CMDLINE, 0);
+   if (err)
+     goto fail;
+ 
+diff --git a/grub-core/loader/arm64/xen_boot.c b/grub-core/loader/arm64/xen_boot.c
+index 26e1472c9..7b55742f5 100644
+--- a/grub-core/loader/arm64/xen_boot.c
++++ b/grub-core/loader/arm64/xen_boot.c
+@@ -345,7 +345,7 @@ xen_boot_binary_load (struct xen_boot_binary *binary, grub_file_t file,
+ 
+   if (argc > 1)
+     {
+-      binary->cmdline_size = grub_loader_cmdline_size (argc - 1, argv + 1);
++      binary->cmdline_size = grub_loader_cmdline_size (argc - 1, argv + 1, 0);
+       binary->cmdline = grub_zalloc (binary->cmdline_size);
+       if (!binary->cmdline)
+ 	{
+@@ -355,7 +355,7 @@ xen_boot_binary_load (struct xen_boot_binary *binary, grub_file_t file,
+ 	}
+       grub_create_loader_cmdline (argc - 1, argv + 1, binary->cmdline,
+ 				  binary->cmdline_size,
+-				  GRUB_VERIFY_KERNEL_CMDLINE);
++				  GRUB_VERIFY_KERNEL_CMDLINE, 0);
+       grub_dprintf ("xen_loader",
+ 		    "Xen_boot cmdline @ %p %s, size: %d\n",
+ 		    binary->cmdline, binary->cmdline, binary->cmdline_size);
+diff --git a/grub-core/loader/efi/linux.c b/grub-core/loader/efi/linux.c
+index bfbd95aee..dc94a9572 100644
+--- a/grub-core/loader/efi/linux.c
++++ b/grub-core/loader/efi/linux.c
+@@ -533,7 +533,7 @@ fallback:
+ 
+   grub_dprintf ("linux", "kernel @ %p\n", kernel_addr);
+ 
+-  cmdline_size = grub_loader_cmdline_size (argc, argv) + sizeof (LINUX_IMAGE);
++  cmdline_size = grub_loader_cmdline_size (argc, argv, 0) + sizeof (LINUX_IMAGE);
+   linux_args = grub_malloc (cmdline_size);
+   if (!linux_args)
+     {
+@@ -544,7 +544,7 @@ fallback:
+   err = grub_create_loader_cmdline (argc, argv,
+ 				    linux_args + sizeof (LINUX_IMAGE) - 1,
+ 				    cmdline_size,
+-				    GRUB_VERIFY_KERNEL_CMDLINE);
++				    GRUB_VERIFY_KERNEL_CMDLINE, 0);
+   if (err)
+     goto fail;
+ 
+diff --git a/grub-core/loader/i386/linux.c b/grub-core/loader/i386/linux.c
+index 977757f2c..66a9a7136 100644
+--- a/grub-core/loader/i386/linux.c
++++ b/grub-core/loader/i386/linux.c
+@@ -1013,7 +1013,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
+ 				      + sizeof (LINUX_IMAGE) - 1,
+ 				      maximal_cmdline_size
+ 				      - (sizeof (LINUX_IMAGE) - 1),
+-				      GRUB_VERIFY_KERNEL_CMDLINE);
++				      GRUB_VERIFY_KERNEL_CMDLINE, 0);
+     if (err)
+       goto fail;
+   }
+diff --git a/grub-core/loader/i386/multiboot_mbi.c b/grub-core/loader/i386/multiboot_mbi.c
+index 11a6e224f..9a98e9bfe 100644
+--- a/grub-core/loader/i386/multiboot_mbi.c
++++ b/grub-core/loader/i386/multiboot_mbi.c
+@@ -665,7 +665,7 @@ grub_multiboot_init_mbi (int argc, char *argv[])
+ 
+   grub_multiboot_free_mbi ();
+ 
+-  len = grub_loader_cmdline_size (argc, argv);
++  len = grub_loader_cmdline_size (argc, argv, 0);
+ 
+   cmdline = grub_malloc (len);
+   if (! cmdline)
+@@ -673,7 +673,7 @@ grub_multiboot_init_mbi (int argc, char *argv[])
+   cmdline_size = len;
+ 
+   return grub_create_loader_cmdline (argc, argv, cmdline,
+-				     cmdline_size, GRUB_VERIFY_KERNEL_CMDLINE);
++				     cmdline_size, GRUB_VERIFY_KERNEL_CMDLINE, 0);
+ }
+ 
+ grub_err_t
+@@ -691,7 +691,7 @@ grub_multiboot_add_module (grub_addr_t start, grub_size_t size,
+   newmod->size = size;
+   newmod->next = 0;
+ 
+-  len = grub_loader_cmdline_size (argc, argv);
++  len = grub_loader_cmdline_size (argc, argv, 0);
+ 
+   newmod->cmdline = grub_malloc (len);
+   if (! newmod->cmdline)
+@@ -703,7 +703,7 @@ grub_multiboot_add_module (grub_addr_t start, grub_size_t size,
+   total_modcmd += ALIGN_UP (len, 4);
+ 
+   err = grub_create_loader_cmdline (argc, argv, newmod->cmdline,
+-				    newmod->cmdline_size, GRUB_VERIFY_MODULE_CMDLINE);
++				    newmod->cmdline_size, GRUB_VERIFY_MODULE_CMDLINE, 0);
+   if (err)
+     {
+       grub_free (newmod);
+diff --git a/grub-core/loader/i386/pc/linux.c b/grub-core/loader/i386/pc/linux.c
+index 4adeee9ae..e2209cdbe 100644
+--- a/grub-core/loader/i386/pc/linux.c
++++ b/grub-core/loader/i386/pc/linux.c
+@@ -345,7 +345,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
+ 				    + GRUB_LINUX_CL_OFFSET + sizeof (LINUX_IMAGE) - 1,
+ 				    maximal_cmdline_size
+ 				    - (sizeof (LINUX_IMAGE) - 1),
+-				    GRUB_VERIFY_KERNEL_CMDLINE);
++				    GRUB_VERIFY_KERNEL_CMDLINE, 0);
+   if (err)
+     goto fail;
+ 
+diff --git a/grub-core/loader/i386/xen.c b/grub-core/loader/i386/xen.c
+index 3b856e842..d24ef151b 100644
+--- a/grub-core/loader/i386/xen.c
++++ b/grub-core/loader/i386/xen.c
+@@ -650,7 +650,7 @@ grub_cmd_xen (grub_command_t cmd __attribute__ ((unused)),
+   err = grub_create_loader_cmdline (argc - 1, argv + 1,
+ 				    (char *) xen_state.next_start.cmd_line,
+ 				    sizeof (xen_state.next_start.cmd_line) - 1,
+-				    GRUB_VERIFY_KERNEL_CMDLINE);
++				    GRUB_VERIFY_KERNEL_CMDLINE, 0);
+   if (err)
+     return err;
+ 
+@@ -910,7 +910,7 @@ grub_cmd_module (grub_command_t cmd __attribute__ ((unused)),
+     return grub_errno;
+   size = grub_file_size (file);
+ 
+-  cmdline_len = grub_loader_cmdline_size (argc - 1, argv + 1);
++  cmdline_len = grub_loader_cmdline_size (argc - 1, argv + 1, 0);
+ 
+   err = grub_relocator_alloc_chunk_addr (xen_state.relocator, &ch,
+ 					 xen_state.max_addr, cmdline_len);
+@@ -919,7 +919,7 @@ grub_cmd_module (grub_command_t cmd __attribute__ ((unused)),
+ 
+   err = grub_create_loader_cmdline (argc - 1, argv + 1,
+ 				    get_virtual_current_address (ch), cmdline_len,
+-				    GRUB_VERIFY_MODULE_CMDLINE);
++				    GRUB_VERIFY_MODULE_CMDLINE, 0);
+   if (err)
+     goto fail;
+ 
+diff --git a/grub-core/loader/mips/linux.c b/grub-core/loader/mips/linux.c
+index 7264ba2b6..dedf61280 100644
+--- a/grub-core/loader/mips/linux.c
++++ b/grub-core/loader/mips/linux.c
+@@ -304,7 +304,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
+ 
+ #ifdef GRUB_MACHINE_MIPS_QEMU_MIPS
+   /* Create kernel command line.  */
+-  size = grub_loader_cmdline_size(argc, argv);
++  size = grub_loader_cmdline_size(argc, argv, 0);
+   params = grub_malloc (size + sizeof (LINUX_IMAGE));
+   if (! params)
+     {
+@@ -314,7 +314,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
+ 
+   grub_memcpy (params, LINUX_IMAGE, sizeof (LINUX_IMAGE));
+   grub_create_loader_cmdline (argc, argv, params + sizeof (LINUX_IMAGE) - 1,
+-			      size, GRUB_VERIFY_KERNEL_CMDLINE);
++			      size, GRUB_VERIFY_KERNEL_CMDLINE, 0);
+ #else
+   linux_argv = extra;
+   argv_off = (grub_uint8_t *) linux_argv - (grub_uint8_t *) playground;
+diff --git a/grub-core/loader/multiboot_mbi2.c b/grub-core/loader/multiboot_mbi2.c
+index 00a48413c..8a81a0359 100644
+--- a/grub-core/loader/multiboot_mbi2.c
++++ b/grub-core/loader/multiboot_mbi2.c
+@@ -1037,7 +1037,7 @@ grub_multiboot2_init_mbi (int argc, char *argv[])
+ 
+   grub_multiboot2_free_mbi ();
+ 
+-  len = grub_loader_cmdline_size (argc, argv);
++  len = grub_loader_cmdline_size (argc, argv, 0);
+ 
+   cmdline = grub_malloc (len);
+   if (! cmdline)
+@@ -1045,7 +1045,7 @@ grub_multiboot2_init_mbi (int argc, char *argv[])
+   cmdline_size = len;
+ 
+   return grub_create_loader_cmdline (argc, argv, cmdline, cmdline_size,
+-				     GRUB_VERIFY_KERNEL_CMDLINE);
++				     GRUB_VERIFY_KERNEL_CMDLINE, 0);
+ }
+ 
+ grub_err_t
+@@ -1062,7 +1062,7 @@ grub_multiboot2_add_module (grub_addr_t start, grub_size_t size,
+   newmod->start = start;
+   newmod->size = size;
+ 
+-  len = grub_loader_cmdline_size (argc, argv);
++  len = grub_loader_cmdline_size (argc, argv, 0);
+ 
+   newmod->cmdline = grub_malloc (len);
+   if (! newmod->cmdline)
+@@ -1074,7 +1074,7 @@ grub_multiboot2_add_module (grub_addr_t start, grub_size_t size,
+   total_modcmd += ALIGN_UP (len, MULTIBOOT_TAG_ALIGN);
+ 
+   err = grub_create_loader_cmdline (argc, argv, newmod->cmdline,
+-				    newmod->cmdline_size, GRUB_VERIFY_MODULE_CMDLINE);
++				    newmod->cmdline_size, GRUB_VERIFY_MODULE_CMDLINE, 0);
+   if (err)
+     {
+       grub_free (newmod->cmdline);
+diff --git a/grub-core/loader/powerpc/ieee1275/linux.c b/grub-core/loader/powerpc/ieee1275/linux.c
+index e6d071508..a6044b970 100644
+--- a/grub-core/loader/powerpc/ieee1275/linux.c
++++ b/grub-core/loader/powerpc/ieee1275/linux.c
+@@ -281,7 +281,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
+       goto out;
+     }
+ 
+-  size = grub_loader_cmdline_size(argc, argv);
++  size = grub_loader_cmdline_size(argc, argv, 0);
+   linux_args = grub_malloc (size + sizeof (LINUX_IMAGE));
+   if (! linux_args)
+     goto out;
+@@ -289,7 +289,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
+   /* Create kernel command line.  */
+   grub_memcpy (linux_args, LINUX_IMAGE, sizeof (LINUX_IMAGE));
+   if (grub_create_loader_cmdline (argc, argv, linux_args + sizeof (LINUX_IMAGE) - 1,
+-				  size, GRUB_VERIFY_KERNEL_CMDLINE))
++				  size, GRUB_VERIFY_KERNEL_CMDLINE, 0))
+     goto out;
+ 
+ out:
+diff --git a/grub-core/loader/sparc64/ieee1275/linux.c b/grub-core/loader/sparc64/ieee1275/linux.c
+index ac2206f3c..de31a0792 100644
+--- a/grub-core/loader/sparc64/ieee1275/linux.c
++++ b/grub-core/loader/sparc64/ieee1275/linux.c
+@@ -332,7 +332,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
+       goto out;
+     }
+ 
+-  size = grub_loader_cmdline_size(argc, argv);
++  size = grub_loader_cmdline_size(argc, argv, 0);
+ 
+   linux_args = grub_malloc (size + sizeof (LINUX_IMAGE));
+   if (! linux_args)
+@@ -341,7 +341,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
+   /* Create kernel command line.  */
+   grub_memcpy (linux_args, LINUX_IMAGE, sizeof (LINUX_IMAGE));
+   if (grub_create_loader_cmdline (argc, argv, linux_args + sizeof (LINUX_IMAGE) - 1,
+-				  size, GRUB_VERIFY_KERNEL_CMDLINE))
++				  size, GRUB_VERIFY_KERNEL_CMDLINE, 0))
+     goto out;
+ 
+ out:
+diff --git a/include/grub/lib/cmdline.h b/include/grub/lib/cmdline.h
+index cdca09b7a..c1210ec21 100644
+--- a/include/grub/lib/cmdline.h
++++ b/include/grub/lib/cmdline.h
+@@ -25,8 +25,9 @@
+ 
+ #define LINUX_IMAGE "BOOT_IMAGE="
+ 
+-unsigned int grub_loader_cmdline_size (int argc, char *argv[]);
++unsigned int grub_loader_cmdline_size (int argc, char *argv[], int noescape);
+ grub_err_t grub_create_loader_cmdline (int argc, char *argv[], char *buf,
+-				       grub_size_t size, enum grub_verify_string_type type);
++				       grub_size_t size, enum grub_verify_string_type type,
++				       int noescape);
+ 
+ #endif /* ! GRUB_CMDLINE_HEADER */
+-- 
+2.42.0
+
diff -r 68f95e015346 usr/src/grub/patches/0035-loader-multiboot-Add-noescape-option.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0035-loader-multiboot-Add-noescape-option.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,266 @@
+# Source: adapted from upstream
+# --noescape option to multiboot loader
+# Locally added feature_noescape variable for grub.cfg dynamic detection
+From bc47b53012d526d85a4ca7f493322094695b193e Mon Sep 17 00:00:00 2001
+From: Vladimir Serbinenko <phcoder@gmail.com>
+Date: Wed, 19 Jul 2023 15:25:14 +0200
+Subject: [PATCH 2/4] loader/multiboot: Add --noescape option
+
+This is needed to boot Solaris/Illumos on some boot paths that need quotes.
+
+Signed-off-by: Vladimir Serbinenko <phcoder@gmail.com>
+---
+ grub-core/loader/i386/multiboot_mbi.c | 13 ++++----
+ grub-core/loader/multiboot.c          | 46 ++++++++++++++++++++-------
+ grub-core/loader/multiboot_mbi2.c     | 12 +++----
+ include/grub/multiboot.h              |  4 +--
+ include/grub/multiboot2.h             |  4 +--
+ 5 files changed, 51 insertions(+), 28 deletions(-)
+
+diff --git a/grub-core/loader/i386/multiboot_mbi.c b/grub-core/loader/i386/multiboot_mbi.c
+index 9a98e9bfe..c7c9daf18 100644
+--- a/grub-core/loader/i386/multiboot_mbi.c
++++ b/grub-core/loader/i386/multiboot_mbi.c
+@@ -659,13 +659,13 @@ grub_multiboot_free_mbi (void)
+ }
+ 
+ grub_err_t
+-grub_multiboot_init_mbi (int argc, char *argv[])
++grub_multiboot_init_mbi (int argc, char *argv[], int no_escape)
+ {
+   grub_ssize_t len = 0;
+ 
+   grub_multiboot_free_mbi ();
+ 
+-  len = grub_loader_cmdline_size (argc, argv, 0);
++  len = grub_loader_cmdline_size (argc, argv, no_escape);
+ 
+   cmdline = grub_malloc (len);
+   if (! cmdline)
+@@ -673,12 +673,12 @@ grub_multiboot_init_mbi (int argc, char *argv[])
+   cmdline_size = len;
+ 
+   return grub_create_loader_cmdline (argc, argv, cmdline,
+-				     cmdline_size, GRUB_VERIFY_KERNEL_CMDLINE, 0);
++				     cmdline_size, GRUB_VERIFY_KERNEL_CMDLINE, no_escape);
+ }
+ 
+ grub_err_t
+ grub_multiboot_add_module (grub_addr_t start, grub_size_t size,
+-			   int argc, char *argv[])
++			   int argc, char *argv[], int no_escape)
+ {
+   struct module *newmod;
+   grub_size_t len = 0;
+@@ -691,7 +691,7 @@ grub_multiboot_add_module (grub_addr_t start, grub_size_t size,
+   newmod->size = size;
+   newmod->next = 0;
+ 
+-  len = grub_loader_cmdline_size (argc, argv, 0);
++  len = grub_loader_cmdline_size (argc, argv, no_escape);
+ 
+   newmod->cmdline = grub_malloc (len);
+   if (! newmod->cmdline)
+@@ -703,7 +703,8 @@ grub_multiboot_add_module (grub_addr_t start, grub_size_t size,
+   total_modcmd += ALIGN_UP (len, 4);
+ 
+   err = grub_create_loader_cmdline (argc, argv, newmod->cmdline,
+-				    newmod->cmdline_size, GRUB_VERIFY_MODULE_CMDLINE, 0);
++				    newmod->cmdline_size, GRUB_VERIFY_MODULE_CMDLINE, no_escape);
++
+   if (err)
+     {
+       grub_free (newmod);
+diff --git a/grub-core/loader/multiboot.c b/grub-core/loader/multiboot.c
+index 94be512c4..851f75334 100644
+--- a/grub-core/loader/multiboot.c
++++ b/grub-core/loader/multiboot.c
+@@ -295,11 +295,14 @@ grub_cmd_multiboot (grub_command_t cmd __attribute__ ((unused)),
+ 
+ #ifndef GRUB_USE_MULTIBOOT2
+   grub_multiboot_quirks = GRUB_MULTIBOOT_QUIRKS_NONE;
++#endif
+   int option_found = 0;
++  int no_escape = 0;
+ 
+   do
+     {
+       option_found = 0;
++#ifndef GRUB_USE_MULTIBOOT2
+       if (argc != 0 && grub_strcmp (argv[0], "--quirk-bad-kludge") == 0)
+ 	{
+ 	  argc--;
+@@ -315,9 +318,17 @@ grub_cmd_multiboot (grub_command_t cmd __attribute__ ((unused)),
+ 	  option_found = 1;
+ 	  grub_multiboot_quirks |= GRUB_MULTIBOOT_QUIRK_MODULES_AFTER_KERNEL;
+ 	}
+-    } while (option_found);
+ #endif
+ 
++      if (argc != 0 && grub_strcmp (argv[0], "--noescape") == 0)
++	{
++	  argc--;
++	  argv++;
++	  option_found = 1;
++	  no_escape = 1;
++	}
++    } while (option_found);
++
+   if (argc == 0)
+     return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+ 
+@@ -328,7 +339,7 @@ grub_cmd_multiboot (grub_command_t cmd __attribute__ ((unused)),
+   grub_dl_ref (my_mod);
+ 
+   /* Skip filename.  */
+-  GRUB_MULTIBOOT (init_mbi) (argc - 1, argv + 1);
++  GRUB_MULTIBOOT (init_mbi) (argc - 1, argv + 1, no_escape);
+ 
+   grub_relocator_unload (GRUB_MULTIBOOT (relocator));
+   GRUB_MULTIBOOT (relocator) = grub_relocator_new ();
+@@ -367,18 +378,29 @@ grub_cmd_module (grub_command_t cmd __attribute__ ((unused)),
+   void *module = NULL;
+   grub_addr_t target;
+   grub_err_t err;
+-  int nounzip = 0;
++  int nounzip = 0, noescape = 0, option_found = 0;
+   grub_uint64_t lowest_addr = 0;
+ 
+-  if (argc == 0)
+-    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+-
+-  if (grub_strcmp (argv[0], "--nounzip") == 0)
++  do
+     {
+-      argv++;
+-      argc--;
+-      nounzip = 1;
+-    }
++      option_found = 0;
++
++      if (argc != 0 && grub_strcmp (argv[0], "--nounzip") == 0)
++	{
++	  argc--;
++	  argv++;
++	  option_found = 1;
++	  nounzip = 1;
++	}
++
++      if (argc != 0 && grub_strcmp (argv[0], "--noescape") == 0)
++	{
++	  argc--;
++	  argv++;
++	  option_found = 1;
++	  noescape = 1;
++	}
++    } while (option_found);
+ 
+   if (argc == 0)
+     return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+@@ -420,7 +442,7 @@ grub_cmd_module (grub_command_t cmd __attribute__ ((unused)),
+       target = 0;
+     }
+ 
+-  err = GRUB_MULTIBOOT (add_module) (target, size, argc - 1, argv + 1);
++  err = GRUB_MULTIBOOT (add_module) (target, size, argc - 1, argv + 1, noescape);
+   if (err)
+     {
+       grub_file_close (file);
+@@ -459,6 +481,9 @@
+                           0, N_("Load a multiboot module."));
+ #endif
+
++  grub_env_set("feature_noescape", "y");
++  grub_env_export("feature_noescape");
++
+   my_mod = mod;
+ }
+
+diff --git a/grub-core/loader/multiboot_mbi2.c b/grub-core/loader/multiboot_mbi2.c
+index 8a81a0359..fcaf3ba56 100644
+--- a/grub-core/loader/multiboot_mbi2.c
++++ b/grub-core/loader/multiboot_mbi2.c
+@@ -1031,13 +1031,13 @@ grub_multiboot2_free_mbi (void)
+ }
+ 
+ grub_err_t
+-grub_multiboot2_init_mbi (int argc, char *argv[])
++grub_multiboot2_init_mbi (int argc, char *argv[], int no_escape)
+ {
+   grub_ssize_t len = 0;
+ 
+   grub_multiboot2_free_mbi ();
+ 
+-  len = grub_loader_cmdline_size (argc, argv, 0);
++  len = grub_loader_cmdline_size (argc, argv, no_escape);
+ 
+   cmdline = grub_malloc (len);
+   if (! cmdline)
+@@ -1045,12 +1045,12 @@ grub_multiboot2_init_mbi (int argc, char *argv[])
+   cmdline_size = len;
+ 
+   return grub_create_loader_cmdline (argc, argv, cmdline, cmdline_size,
+-				     GRUB_VERIFY_KERNEL_CMDLINE, 0);
++				     GRUB_VERIFY_KERNEL_CMDLINE, no_escape);
+ }
+ 
+ grub_err_t
+ grub_multiboot2_add_module (grub_addr_t start, grub_size_t size,
+-			   int argc, char *argv[])
++			    int argc, char *argv[], int no_escape)
+ {
+   struct module *newmod;
+   grub_size_t len = 0;
+@@ -1062,7 +1062,7 @@ grub_multiboot2_add_module (grub_addr_t start, grub_size_t size,
+   newmod->start = start;
+   newmod->size = size;
+ 
+-  len = grub_loader_cmdline_size (argc, argv, 0);
++  len = grub_loader_cmdline_size (argc, argv, no_escape);
+ 
+   newmod->cmdline = grub_malloc (len);
+   if (! newmod->cmdline)
+@@ -1074,7 +1074,7 @@ grub_multiboot2_add_module (grub_addr_t start, grub_size_t size,
+   total_modcmd += ALIGN_UP (len, MULTIBOOT_TAG_ALIGN);
+ 
+   err = grub_create_loader_cmdline (argc, argv, newmod->cmdline,
+-				    newmod->cmdline_size, GRUB_VERIFY_MODULE_CMDLINE, 0);
++				    newmod->cmdline_size, GRUB_VERIFY_MODULE_CMDLINE, no_escape);
+   if (err)
+     {
+       grub_free (newmod->cmdline);
+diff --git a/include/grub/multiboot.h b/include/grub/multiboot.h
+index d8847f753..c8f4b1304 100644
+--- a/include/grub/multiboot.h
++++ b/include/grub/multiboot.h
+@@ -43,9 +43,9 @@ void grub_module (int argc, char *argv[]);
+ void grub_multiboot_set_accepts_video (int val);
+ grub_err_t grub_multiboot_make_mbi (grub_uint32_t *target);
+ void grub_multiboot_free_mbi (void);
+-grub_err_t grub_multiboot_init_mbi (int argc, char *argv[]);
++grub_err_t grub_multiboot_init_mbi (int argc, char *argv[], int noescape);
+ grub_err_t grub_multiboot_add_module (grub_addr_t start, grub_size_t size,
+-				      int argc, char *argv[]);
++				      int argc, char *argv[], int noescape);
+ void grub_multiboot_set_bootdev (void);
+ void
+ grub_multiboot_add_elfsyms (grub_size_t num, grub_size_t entsize,
+diff --git a/include/grub/multiboot2.h b/include/grub/multiboot2.h
+index b90aa6989..fa8006b4d 100644
+--- a/include/grub/multiboot2.h
++++ b/include/grub/multiboot2.h
+@@ -35,9 +35,9 @@ void grub_module2 (int argc, char *argv[]);
+ void grub_multiboot2_set_accepts_video (int val);
+ grub_err_t grub_multiboot2_make_mbi (grub_uint32_t *target);
+ void grub_multiboot2_free_mbi (void);
+-grub_err_t grub_multiboot2_init_mbi (int argc, char *argv[]);
++grub_err_t grub_multiboot2_init_mbi (int argc, char *argv[], int noescape);
+ grub_err_t grub_multiboot2_add_module (grub_addr_t start, grub_size_t size,
+-				      int argc, char *argv[]);
++				      int argc, char *argv[], int noescape);
+ void grub_multiboot2_set_bootdev (void);
+ void
+ grub_multiboot2_add_elfsyms (grub_size_t num, grub_size_t entsize,
+-- 
+2.42.0
+
diff -r 68f95e015346 usr/src/grub/patches/0036-efi.h.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0036-efi.h.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,12 @@
+# Source: Local, carried from 1.99
+# enable smbios support
+--- old/include/grub/efi/efi.h	2024-05-09 08:15:20.427814680 -0700
++++ new/include/grub/efi/efi.h	2024-06-12 13:36:09.497676447 -0700
+@@ -142,6 +142,7 @@
+ 
+ /* Variables.  */
+ extern grub_efi_system_table_t *EXPORT_VAR(grub_efi_system_table);
++extern void *EXPORT_VAR(grub_efi_smbios_ptr);
+ extern grub_efi_handle_t EXPORT_VAR(grub_efi_image_handle);
+ 
+ extern int EXPORT_VAR(grub_efi_is_finished);
diff -r 68f95e015346 usr/src/grub/patches/0037-efi_init.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0037-efi_init.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,55 @@
+# Source: Local, adapted from 1.99
+# Enable smbios support
+--- old/grub-core/kern/efi/init.c	2024-05-09 08:15:20.409612362 -0700
++++ new/grub-core/kern/efi/init.c	2024-06-12 13:12:28.719382371 -0700
+@@ -2,6 +2,7 @@
+ /*
+  *  GRUB  --  GRand Unified Bootloader
+  *  Copyright (C) 2006,2007  Free Software Foundation, Inc.
++ *  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+  *
+  *  GRUB is free software: you can redistribute it and/or modify
+  *  it under the terms of the GNU General Public License as published by
+@@ -101,6 +102,33 @@
+ }
+ #endif
+ 
++/* Pointers to other useful tables */
++void *grub_efi_smbios_ptr;
++
++static void
++grub_efi_table_init(void)
++{
++  grub_guid_t smbios_guid = GRUB_EFI_SMBIOS_TABLE_GUID;
++  grub_efi_uintn_t i;
++
++  if (grub_efi_system_table == 0) {
++     grub_dprintf("efi", "UEFI system pointer is NULL\n");
++     return;
++  }
++
++  for (i = 0; i < grub_efi_system_table->num_table_entries; i++)
++     {
++       grub_efi_configuration_table_t *cfgtblp;
++       cfgtblp = &grub_efi_system_table->configuration_table[i];
++
++       if (grub_memcmp (&smbios_guid, &cfgtblp->vendor_guid,
++            sizeof (grub_guid_t)) == 0)
++          {
++             grub_efi_smbios_ptr = cfgtblp->vendor_table;
++          }
++     }
++}
++
+ grub_addr_t grub_modbase;
+ 
+ __attribute__ ((__optimize__ ("-fno-stack-protector"))) void
+@@ -130,6 +158,8 @@
+ 
+   grub_efidisk_init ();
+ 
++  grub_efi_table_init ();
++
+   grub_efi_register_debug_commands ();
+ }
+ 
diff -r 68f95e015346 usr/src/grub/patches/0038-multiboot_mbi2.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0038-multiboot_mbi2.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,101 @@
+# Source: Local, adapted from 1.99
+# Enable smbios support
+--- old/grub-core/loader/multiboot_mbi2.c	2024-06-12 10:43:16.663675487 -0700
++++ new/grub-core/loader/multiboot_mbi2.c	2024-06-12 14:04:03.449773423 -0700
+@@ -41,6 +41,10 @@
+ #include <grub/efi/efi.h>
+ #endif
+ 
++#if defined (GRUB_MACHINE_PCBIOS) || defined (GRUB_MACHINE_EFI) || defined (GRUB_MACHINE_MULTIBOOT) || defined (GRUB_MACHINE_QEMU)
++#include <grub/i386/pc/smbios.h>
++#endif
++
+ #if defined (GRUB_MACHINE_PCBIOS) || defined (GRUB_MACHINE_COREBOOT) || defined (GRUB_MACHINE_MULTIBOOT) || defined (GRUB_MACHINE_QEMU)
+ #include <grub/i386/pc/vbe.h>
+ #define HAS_VGA_TEXT 1
+@@ -186,6 +190,7 @@
+ 	      case MULTIBOOT_TAG_TYPE_EFI32_IH:
+ 	      case MULTIBOOT_TAG_TYPE_EFI64_IH:
+ 	      case MULTIBOOT_TAG_TYPE_LOAD_BASE_ADDR:
++              case MULTIBOOT_TAG_TYPE_SMBIOS:
+ 		break;
+ 
+ 	      default:
+@@ -393,7 +398,48 @@
+   return err;
+ }
+ 
++static struct grub_smbios_entry_point *
++grub_smbios_get_entry_point(void)
++{
++#if defined (GRUB_MACHINE_EFI)
++  if (grub_efi_smbios_ptr)
++    {
++      if (grub_byte_checksum (grub_efi_smbios_ptr,
++	  sizeof (struct grub_smbios_entry_point)) == 0)
++	return (grub_efi_smbios_ptr);
++      else
++	grub_dprintf("multiboot_loader", "SMBIOS table checksum is not 0");
++    }
++#elif defined (GRUB_MACHINE_PCBIOS)
++  grub_uint8_t *ptr;
++  /* On BIOS systems, we need to scan memory from 0xF0000-0xFFFFF for the
++     anchor. */
++  grub_dprintf ("smbios", "Looking for SMBIOS anchor. Scanning 0xF0000\n");
++  for (ptr = (grub_uint8_t *) 0xf0000; ptr < (grub_uint8_t *) 0x100000;
++       ptr += 16)
++    {
++      if (grub_memcmp (ptr, "_SM_", 4) == 0
++          && grub_byte_checksum (ptr,
++                 sizeof (struct grub_smbios_entry_point)) == 0)
++        return (struct grub_smbios_entry_point *) ptr;
++    }
++#endif
++  return 0;
++}
++
+ static grub_size_t
++smbios_size(void)
++{
++  struct grub_smbios_entry_point *eps = grub_smbios_get_entry_point();
++
++  if (!eps)
++    return 0;
++
++  return ALIGN_UP (sizeof (struct multiboot_tag_smbios)
++                   + eps->ep_length, MULTIBOOT_TAG_ALIGN);
++}
++
++static grub_size_t
+ acpiv2_size (void)
+ {
+ #if GRUB_MACHINE_HAS_ACPI
+@@ -455,6 +501,7 @@
+ 		+ sizeof (struct grub_acpi_rsdp_v10), MULTIBOOT_TAG_ALIGN)
+     + ALIGN_UP (sizeof (struct multiboot_tag_load_base_addr), MULTIBOOT_TAG_ALIGN)
+     + acpiv2_size ()
++    + smbios_size ()
+     + net_size ()
+ #ifdef GRUB_MACHINE_EFI
+     + ALIGN_UP (sizeof (struct multiboot_tag_efi32), MULTIBOOT_TAG_ALIGN)
+@@ -893,6 +940,20 @@
+   }
+ #endif
+ 
++  {
++    struct grub_smbios_entry_point *eps;
++    if ((eps = grub_smbios_get_entry_point()) != 0)
++    {
++      struct multiboot_tag_smbios *tag;
++      tag = (struct multiboot_tag_smbios *) ptrorig;
++      tag->type = MULTIBOOT_TAG_TYPE_SMBIOS;
++      tag->size = sizeof (struct multiboot_tag_smbios) + eps->ep_length;
++      grub_memcpy(tag->entry_point, eps, eps->ep_length);
++      ptrorig += ALIGN_UP (tag->size, MULTIBOOT_TAG_ALIGN)
++	  / sizeof (grub_properly_aligned_t);
++    }
++  }
++
+ #if defined (GRUB_MACHINE_EFI) && defined (__i386__)
+   {
+     struct multiboot_tag_efi32 *tag = (struct multiboot_tag_efi32 *) ptrorig;
diff -r 68f95e015346 usr/src/grub/patches/0039-multiboot2.h.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0039-multiboot2.h.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,16 @@
+# Source: Local, adapted from 1.99
+# Enable smbios support
+--- old/include/multiboot2.h	2022-03-14 08:01:24.000000000 -0700
++++ new/include/multiboot2.h	2024-06-12 18:45:39.795475970 -0700
+@@ -354,10 +354,7 @@
+ {
+   multiboot_uint32_t type;
+   multiboot_uint32_t size;
+-  multiboot_uint8_t major;
+-  multiboot_uint8_t minor;
+-  multiboot_uint8_t reserved[6];
+-  multiboot_uint8_t tables[0];
++  multiboot_uint8_t entry_point[0];
+ };
+ 
+ struct multiboot_tag_old_acpi
diff -r 68f95e015346 usr/src/grub/patches/0040-view.c.patch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/patches/0040-view.c.patch	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,13 @@
+# Source Local, carried from 1.99
+# display version in graphic mode menu
+--- old/grub-core/gfxmenu/view.c	2024-05-09 08:15:20.325406035 -0700
++++ new/grub-core/gfxmenu/view.c	2024-06-27 10:43:57.245186440 -0700
+@@ -100,7 +100,7 @@
+   view->desktop_image_v_align = GRUB_VIDEO_BITMAP_V_ALIGN_CENTER;
+   view->desktop_color = default_bg_color;
+   view->terminal_box = grub_gfxmenu_create_box (0, 0);
+-  view->title_text = grub_strdup (_("GRUB Boot Menu"));
++  view->title_text = grub_xasprintf (_("GNU GRUB version %s"), PACKAGE_VERSION);
+   view->progress_message_text = 0;
+   view->theme_path = 0;
+ 
diff -r 68f95e015346 usr/src/grub/src/build-zvmm/Makefile
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/build-zvmm/Makefile	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,255 @@
+# GRUB  --  GRand Unified Bootloader
+# Copyright (c) 2011, 2024, Oracle and/or its affiliates.
+#
+# GRUB is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# GRUB is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+
+include $(SRC)/Makefile.master
+
+BUILDDIR=$(BUILDTOP)/usr/src/grub
+BUILDDIR_REL=$(BUILDTOP_REL)/usr/src/grub
+
+.KEEP_STATE_FILE:	$(BUILDDIR)/.make.state.$(MACH)
+
+all	:= TARGET = all
+clean	:= TARGET = clean
+clobber	:= TARGET = clobber
+install	:= TARGET = install
+
+GRUB2_SRC_REL	= $(BUILDDIR_REL)/grub-2.12 
+GRUB2_CORE	= $(GRUB2_SRC_REL)/grub-core
+KERN_DIR	= $(GRUB2_CORE)/kern
+FS_DIR		= $(GRUB2_CORE)/fs
+DISK_DIR	= $(GRUB2_CORE)/disk
+IO_DIR		= $(GRUB2_CORE)/io
+PART_DIR	= $(GRUB2_CORE)/partmap
+ZVBOOT_DIR	= $(GRUB2_SRC_REL)/contrib/zvboot
+STUB_DIR	= $(GRUB2_SRC_REL)/contrib/zvboot/stub
+VBOOT_DIR	= $(GRUB2_SRC_REL)/contrib/vboot
+ELFSIGNRANGE_DIR	= $(GRUB2_SRC_REL)/contrib/vboot/elfsignrange
+LIB_DIR		= $(GRUB2_CORE)/lib/
+LIBGCRYPT_CIPHER_DIR	= $(GRUB2_CORE)/lib/libgcrypt-grub/cipher
+LIBGCRYPT_MPI_DIR	= $(GRUB2_CORE)/lib/libgcrypt-grub/mpi
+LIBGCRYPT_SRC_DIR	= $(GRUB2_CORE)/lib/libgcrypt-grub/src
+LIBGCRYPT_WRAP_DIR	= $(GRUB2_CORE)/lib/libgcrypt_wrap
+BUILD_ZVMM	= $(GRUB2_SRC_REL)/build-zvmm
+ZVBOOT		= $(BUILDDIR)/zvboot
+
+CC = /usr/gcc/13/bin/gcc
+
+all: $(ZVBOOT)
+
+ZVBOOT_OBJS_CORE =	\
+	stubs.o		\
+	zvblk.o		\
+	zvcons.o	\
+	zv_asm_$(MACH64).o \
+	zv_mem_$(MACH64).o \
+	zvgrub.o	\
+	zvload.o	\
+	verify.o	\
+	verify_zvboot.o	\
+	verify_elf.o	\
+	verify_rsa.o	\
+	gnasher.o
+
+ZVBOOT_OBJS_ELFSIGNRANGE = \
+	elfsignrange.o
+
+ZVBOOT_OBJS_STUB =	\
+	stub_gpt.o	\
+	stub_iso9660.o	\
+	stub_msdos.o	\
+	stub_sun.o	\
+	stub_sunpc.o	\
+	stub_ufs.o	\
+	stub_zfs.o
+
+ZVBOOT_OBJS_FS =	\
+	device.o	\
+	disk.o		\
+	err.o		\
+	file.o		\
+	fs.o		\
+	fshelp.o	\
+	gzio.o		\
+	list.o		\
+	memdisk.o	\
+	misc.o		\
+	mm.o		\
+	partition.o	\
+	zfsinfo.o	\
+	zfs_fletcher.o	\
+	zfs_lzjb.o	\
+	zfs_lz4.o	\
+	zfs_sha256.o
+
+ZVBOOT_OBJS_LIBGCRYPT =	\
+	crc.o		\
+	crypto.o	\
+	sha256.o	\
+	mpi-add.o	\
+	mpi-bit.o	\
+	mpi-cmp.o	\
+	mpi-div.o	\
+	mpi-gcd.o	\
+	mpi-inline.o	\
+	mpi-inv.o	\
+	mpi-mod.o	\
+	mpi-mpow.o	\
+	mpi-mul.o	\
+	mpi-pow.o	\
+	mpicoder.o	\
+	mpih-div.o	\
+	mpih-mul.o	\
+	mpiutil.o	\
+	mpih-add1.o	\
+	mpih-lshift.o	\
+	mpih-mul1.o	\
+	mpih-mul2.o	\
+	mpih-mul3.o	\
+	mpih-rshift.o	\
+	mpih-sub1.o
+
+ZVBOOT_OBJS_LIBGCRYPT_WRAP = mem.o
+
+
+ZVBOOT_OBJS = $(ZVBOOT_OBJS_CORE:%=$(BUILDDIR)/%) \
+	$(ZVBOOT_OBJS_ELFSIGNRANGE:%=$(BUILDDIR)/%) \
+	$(ZVBOOT_OBJS_STUB:%=$(BUILDDIR)/%) \
+	$(ZVBOOT_OBJS_FS:%=$(BUILDDIR)/%) \
+	$(ZVBOOT_OBJS_LIBGCRYPT:%=$(BUILDDIR)/%) \
+	$(ZVBOOT_OBJS_LIBGCRYPT_WRAP:%=$(BUILDDIR)/%)
+
+FOSS_BUILD =
+$(NOT_FOSS_BUILD)FOSS_BUILD = $(POUND_SIGN)
+$(FOSS_BUILD)USE_INTERNAL_CERT = $(POUND_SIGN)
+
+links_amd64:
+	$(INS_CMD.symlink) ./x86_64 \
+		$(BUILDDIR)/grub-2.12/include/grub/cpu
+
+links: links_$(MACH64)
+
+LIBGCC_amd64=
+LIBGCC=$(LIBGCC_$(MACH64))
+
+$(ZVBOOT_OBJS): 
+
+$(ZVBOOT): links $(ZVBOOT_OBJS) $(ZVBOOT_DIR)/Mapfile.zvboot.$(MACH64)
+	$(LD) -64 -dn -e _start -M $(ZVBOOT_DIR)/Mapfile.zvboot.$(MACH64) \
+		-o $@ $(ZVBOOT_OBJS) $(LIBGCC)
+	$(POST_PROCESS)
+
+clean: $(FRC)
+	$(RM) $(ZVBOOT_OBJS) $(BUILDDIR)/include/grub/cpu
+
+clobber: $(FRC)
+	$(RM) $(ZVBOOT)
+
+install: all
+
+FRC:
+
+FLAGS_CC = -nostdlib -static-libgcc -Wall -c -m64 -Os -D$(MACH64) \
+	-Wno-unknown-pragmas -std=gnu99 -fno-builtin -mno-sse
+DEFINES_CC = -D_KERNEL -D_BOOT -D_ZVBOOT -DZVBOOT
+$(USE_INTERNAL_CERT)DEFINES_CC += -DUSE_INTERNAL_CERT
+
+GCC_INCLUDES_CMD = $(CC) -print-file-name=include
+GCC_INCLUDES = $(GCC_INCLUDES_CMD:sh)
+amd64_INCLUDES_CC = \
+	-I$(SRC_REL)/uts/i86pc \
+	-I$(SRC_REL)/uts/intel
+SYS_INCLUDES = \
+	$($(MACH64)_INCLUDES_CC) \
+	-I$(SRC_REL)/uts/common \
+	-I$(ELFSIGNRANGE_DIR)
+INCLUDES_GRUB = -Iinclude -I../include -I. -I$(GRUB2_CORE) -I$(GRUB2_SRC_REL) -I$(ZVBOOT_DIR) -I$(VBOOT_DIR) \
+	-I$(GRUB2_SRC_REL)/include \
+	-isystem $(GCC_INCLUDES)
+INCLUDES_CC = $(SYS_INCLUDES) $(INCLUDES_GRUB)
+$(USE_INTERNAL_CERT)$(BUILDDIR)/verify.o := INCLUDES_CC += -I$(ELFSIGN_MATERIAL)
+
+INCLUDES_CIPHER = -I$(LIBGCRYPT_SRC_DIR) -I$(LIB_DIR)/libgcrypt_wrap -I$(LIB_DIR)/posix_wrap -I../include/grub/gcrypt
+INCLUDES_LIBGCRYPT = -I$(LIBGCRYPT_SRC_DIR) -I$(LIBGCRYPT_MPI_DIR) \
+	-I$(LIB_DIR)/libgcrypt-grub/random
+DEFINES_LIBGCRYPT = -D_GCRYPT_IN_LIBGCRYPT=1
+
+$(BUILDDIR)/verify_rsa.o := INCLUDES_CC += $(INCLUDES_LIBGCRYPT)
+
+INCLUDES_STUB = -I$(FS_DIR) -I$(FS_DIR)/zfs -I$(PART_DIR)
+
+amd64_FLAGS_AS = -m64
+FLAGS_AS = -P $($(MACH64)_FLAGS_AS)
+DEFINES_AS = $(DEFINES_CC) -D_ASM
+
+amd64_INCLUDES_AS = -I$(SRC_REL)/uts/intel
+INCLUDES_AS += $($(MACH64)_INCLUDES_AS)
+
+$(BUILDDIR)/%.o:	$(ZVBOOT_DIR)/%.s
+	$(AS) $(FLAGS_AS) $(DEFINES_AS) $(INCLUDES_AS) -o $@ $<
+
+$(BUILDDIR)/%.o:	$(ZVBOOT_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(INCLUDES_CC) -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(VBOOT_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(INCLUDES_CC) -D_ELF64 -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(ELFSIGNRANGE_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(INCLUDES_CC) -D_ELF64 -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(STUB_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(INCLUDES_CC) $(INCLUDES_STUB) -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(KERN_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(INCLUDES_CC) -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(FS_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(INCLUDES_CC) -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(FS_DIR)/zfs/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(INCLUDES_CC) -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(DISK_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(INCLUDES_CC) -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(IO_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(INCLUDES_CC) -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(PART_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(INCLUDES_CC) -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(LIBGCRYPT_CIPHER_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(DEFINES_LIBGCRYPT) $(INCLUDES_CIPHER) $(INCLUDES_CC) \
+            -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(LIBGCRYPT_MPI_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(DEFINES_LIBGCRYPT) \
+	    $(INCLUDES_LIBGCRYPT) $(INCLUDES_CC) $(INCLUDES_CIPHER) -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(LIBGCRYPT_MPI_DIR)/generic/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(DEFINES_LIBGCRYPT) \
+	    $(INCLUDES_LIBGCRYPT) -I$(LIBGCRYPT_MPI_DIR) $(INCLUDES_CC) -o $@ $<
+
+$(BUILDDIR)/%.o:	$(LIBGCRYPT_SRC_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(DEFINES_LIBGCRYPT) \
+	    $(INCLUDES_LIBGCRYPT) $(INCLUDES_CC) -o $@ $<
+
+$(BUILDDIR)/%.o:	$(LIBGCRYPT_WRAP_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(DEFINES_LIBGCRYPT) \
+	    $(INCLUDES_LIBGCRYPT) $(INCLUDES_CC) -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
+$(BUILDDIR)/%.o:	$(LIB_DIR)/%.c
+	$(CC) $(FLAGS_CC) $(DEFINES_CC) $(INCLUDES_CC) -DGRUB_FILE=\"$(<F)\" -o $@ $<
+
diff -r 68f95e015346 usr/src/grub/src/build-zvmm/config.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/build-zvmm/config.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,22 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define NESTED_FUNC_ATTR
+
+/* gcc generates calls to `__enable_execute_stack'. */
+#define	NEED_ENABLE_EXECUTE_STACK	1
diff -r 68f95e015346 usr/src/grub/src/build-zvmm/include/grub/machine/time.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/build-zvmm/include/grub/machine/time.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,17 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
diff -r 68f95e015346 usr/src/grub/src/conf/mapfile-0.map
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/conf/mapfile-0.map	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,36 @@
+#
+#  GRUB  --  GRand Unified Bootloader
+#  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+#
+#  GRUB is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation, either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  GRUB is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+$mapfile_version 2
+
+HDR_NOALLOC;
+
+LOAD_SEGMENT text {
+	FLAGS = READ WRITE EXECUTE;
+        VADDR = 0;
+        PADDR = 0;
+
+        ASSIGN_SECTION {
+                FLAGS = ALLOC;
+        };
+        OS_ORDER = .text;
+};
+
+CAPABILITY {
+        HW = ;
+};
diff -r 68f95e015346 usr/src/grub/src/conf/mapfile-100000.map
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/conf/mapfile-100000.map	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,36 @@
+#
+#  GRUB  --  GRand Unified Bootloader
+#  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+#
+#  GRUB is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation, either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  GRUB is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+$mapfile_version 2
+
+HDR_NOALLOC;
+
+LOAD_SEGMENT text {
+	FLAGS = READ WRITE EXECUTE;
+        VADDR = 0x100000;
+        PADDR = 0x100000;
+
+        ASSIGN_SECTION {
+                FLAGS = ALLOC;
+        };
+	OS_ORDER = .text;
+};
+
+CAPABILITY {
+        HW = ;
+};
diff -r 68f95e015346 usr/src/grub/src/conf/mapfile-6000.map
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/conf/mapfile-6000.map	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,36 @@
+#
+#  GRUB  --  GRand Unified Bootloader
+#  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+#
+#  GRUB is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation, either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  GRUB is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+$mapfile_version 2
+
+HDR_NOALLOC;
+
+LOAD_SEGMENT text {
+	FLAGS = READ WRITE EXECUTE;
+        VADDR = 0x6000;
+        PADDR = 0x6000;
+
+        ASSIGN_SECTION {
+                FLAGS = ALLOC;
+        };
+        OS_ORDER = .text;
+};
+
+CAPABILITY {
+        HW = ;
+};
diff -r 68f95e015346 usr/src/grub/src/conf/mapfile-7c00.map
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/conf/mapfile-7c00.map	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,36 @@
+#
+#  GRUB  --  GRand Unified Bootloader
+#  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+#
+#  GRUB is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation, either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  GRUB is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+$mapfile_version 2
+
+HDR_NOALLOC;
+
+LOAD_SEGMENT text {
+	FLAGS = READ WRITE EXECUTE;
+        VADDR = 0x7c00;
+        PADDR = 0x7c00;
+
+        ASSIGN_SECTION {
+                FLAGS = ALLOC;
+        };
+        OS_ORDER = .text;
+};
+
+CAPABILITY {
+        HW = ;
+};
diff -r 68f95e015346 usr/src/grub/src/conf/mapfile-8000.map
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/conf/mapfile-8000.map	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,36 @@
+#
+#  GRUB  --  GRand Unified Bootloader
+#  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+#
+#  GRUB is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation, either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  GRUB is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+$mapfile_version 2
+
+HDR_NOALLOC;
+
+LOAD_SEGMENT text {
+	FLAGS = READ WRITE EXECUTE;
+        VADDR = 0x8000;
+        PADDR = 0x8000;
+
+        ASSIGN_SECTION {
+                FLAGS = ALLOC;
+        };
+        OS_ORDER = .text;
+};
+
+CAPABILITY {
+        HW = ;
+};
diff -r 68f95e015346 usr/src/grub/src/conf/mapfile-8200.map
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/conf/mapfile-8200.map	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,37 @@
+#
+#  GRUB  --  GRand Unified Bootloader
+#  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+#
+#  GRUB is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation, either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  GRUB is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+$mapfile_version 2
+
+HDR_NOALLOC;
+
+LOAD_SEGMENT text {
+	FLAGS = READ WRITE EXECUTE;
+	VADDR = 0x8200;
+	PADDR = 0x8200;
+
+        ASSIGN_SECTION {
+                FLAGS = ALLOC;
+        };
+        OS_ORDER = .text;
+};
+
+
+CAPABILITY {
+	HW = ;
+};
diff -r 68f95e015346 usr/src/grub/src/conf/mapfile-9000.map
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/conf/mapfile-9000.map	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,36 @@
+#
+#  GRUB  --  GRand Unified Bootloader
+#  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+#
+#  GRUB is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation, either version 3 of the License, or
+#  (at your option) any later version.
+#
+#  GRUB is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+$mapfile_version 2
+
+HDR_NOALLOC;
+
+LOAD_SEGMENT text {
+        FLAGS = READ WRITE EXECUTE;
+	VADDR = 0x9000;
+	PADDR = 0x9000;
+
+	ASSIGN_SECTION {
+		FLAGS = ALLOC;
+	};
+        OS_ORDER = .text;
+};
+
+CAPABILITY {
+	HW = ;
+};
diff -r 68f95e015346 usr/src/grub/src/contrib/vboot/README
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/vboot/README	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,28 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+README
+------
+
+Source files in this directory are for Solaris Verified Boot.
+They verify the RSA signature contained in an ELF file, which should be
+the initial Solaris boot module, "unix".
+
+This is common source for GRUB2 zvboot (X86 Kernel Zones) and
+x86_64-efi/verified_boot.mod (X86 UEFI mode) and is used for both,
+depending on whether ZVBOOT or EFI_VBOOT is defined.
diff -r 68f95e015346 usr/src/grub/src/contrib/vboot/elfsignrange/_elfsignrange.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/vboot/elfsignrange/_elfsignrange.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,69 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __ELFSIGNRANGE_DOT_H
+#define	__ELFSIGNRANGE_DOT_H
+
+#include <sys/types.h>
+#include <sys/machelf.h>
+#include <sys/elfsignrange.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* Define _ELF64 and non_ELF6 mappings for routine that follows */
+#if	defined(_ELF64)
+#define	_elf_sign_range		_elf64_sign_range
+#else
+#define	_elf_sign_range		_elf32_sign_range
+#endif
+
+/* Machine and class specific ELF interfaces - available to libelf and krtld */
+extern	int	_elf_sign_range(elf_sign_range_cb_func, Ehdr *,
+		    Phdr *, Shdr *, size_t, Elf_Signrange, void *);
+
+/*
+ * Provide a simple summing implementation.  This provides a means of generating
+ * a DT_CHECKSUM, and is probably of little interest to anyone else.  However,
+ * for now this implementation is designed to be available for both kernel and
+ * userland use, as a simple means of testing a checksum/signature framework
+ * between the two.
+ */
+#define	_ELF_MSW(l)	(((l) >> 16) & 0x0000ffffL)
+#define	_ELF_LSW(l)	((l) & 0x0000ffffL)
+
+/* Checksum data structure supplied as cookie to checksum routines */
+typedef struct {
+	char	*ecs_base;
+	long	ecs_sum;
+	uint_t	ecs_flags;
+} _Elf_Checksum_desc_t;
+
+/* elf_sign_range_cb_func() callback */
+extern void	_elf_checksum_callback(size_t, size_t, void *);
+/* Checksum cookie finalization */
+extern void	_elf_checksum_fini(void *);
+/* Checksum cookie initialization - supplied object base address and flags */
+extern void	_elf_checksum_init(void *, char *, uint_t);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif /* __ELFSIGNRANGE_DOT_H */
diff -r 68f95e015346 usr/src/grub/src/contrib/vboot/elfsignrange/elfsignrange.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/vboot/elfsignrange/elfsignrange.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,518 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* LINTLIBRARY */
+
+#include	<sys/machelf.h>
+#include	<sys/elf.h>
+#include	<sys/types.h>
+
+#if	!defined(_KERNEL) && !defined(_BOOT)
+#include	<stddef.h>
+#include	<_elfsignrange.h>
+#else
+#include	<sys/sysmacros.h>
+#include	<elfsignrange/_elfsignrange.h>
+#endif
+
+#if	!defined(_KERNEL) && !defined(_BOOT) && defined(ELF_SIGN_RANGE_DEBUG)
+#include	<stdio.h>
+#define		DBG_CALLBACK(a, o, s)	_Dbg_callback(a, o, s)
+#else
+#define		DBG_CALLBACK(a, o, s)
+#endif
+
+
+#if	defined(_ELF64)
+#if	!defined(_KERNEL) && !defined(_BOOT) && defined(ELF_SIGN_RANGE_DEBUG)
+void
+_Dbg_callback(char *addr, size_t offset, size_t size)
+{
+	(void) printf("  callback: addr 0x%llx: offset 0x%llx:%llu - "
+	    "0x%llx:%llu, cnt 0x%llx:%llu\n", EC_NATPTR(addr),
+	    EC_XWORD(offset), EC_XWORD(offset),
+	    EC_XWORD(offset + size), EC_XWORD(offset + size),
+	    EC_XWORD(size), EC_XWORD(size));
+}
+#endif
+
+/* Define a simple checksum capability (stolen from libcmd) */
+void
+_elf_checksum_init(void *cookie, char *base, uint_t flags)
+{
+	_Elf_Checksum_desc_t	*ecsp = (_Elf_Checksum_desc_t *)cookie;
+
+	ecsp->ecs_base = base;
+	ecsp->ecs_sum = 0;
+	ecsp->ecs_flags = flags;
+}
+
+void
+_elf_checksum_callback(size_t offset, size_t size, void *cookie)
+{
+	_Elf_Checksum_desc_t	*ecsp = (_Elf_Checksum_desc_t *)cookie;
+	char			*addr = ecsp->ecs_base + offset;
+
+	if (size == 0)
+		return;
+
+	DBG_CALLBACK(addr, offset, size);
+
+	while (size--)
+		ecsp->ecs_sum += *addr++ & 0xff;
+}
+
+void
+_elf_checksum_fini(void *cookie)
+{
+	_Elf_Checksum_desc_t	*ecsp = (_Elf_Checksum_desc_t *)cookie;
+	long			_sum, sum = ecsp->ecs_sum;
+
+	_sum = _ELF_LSW(sum) + _ELF_MSW(sum);
+	ecsp->ecs_sum = ((ushort_t)(_ELF_LSW(_sum) + _ELF_MSW(_sum)));
+}
+#endif
+
+/*
+ * Determine whether a section should be skipped.
+ *
+ * When processing ELF_SR_RELOBJ, any SHT_SUNW_SIGNATURE section data is always
+ * omitted from the address range, as the data can differ even when the rest of
+ * the file contents remain unchanged.  Note, objects can contain more than one
+ * SHT_SUNW_SIGNATURE section.  Sections named .SUNW_signature and .SUNW_fips
+ * have this same type.  Both of these sections are skipped.
+ *
+ * SHT_DYNAMIC and SHT_SUNW_ancillary sections are omitted when calculating
+ * an ELF checksum, as these sections are updated with the checksums when the
+ * file is being created by ld(1).
+ */
+static int
+skip_section(Shdr *shdr, boolean_t skip_checksum)
+{
+	if (shdr->sh_type == SHT_SUNW_SIGNATURE)
+		return (1);
+
+	if (skip_checksum &&
+	    ((shdr->sh_flags & SHF_SUNW_ABSENT) == 0) &&
+	    ((shdr->sh_type == SHT_DYNAMIC) ||
+	    (shdr->sh_type == SHT_SUNW_ancillary)))
+		return (1);
+
+	return (0);
+}
+
+/*
+ * Low level, machine and class specific function to return the important
+ * memory ranges of an ELF file.  This core functionality can be compiled
+ * twice to create both _ELF64 and non_ELF64 variants, and thus provides the
+ * interfaces:
+ *
+ *	_elf32_sign_range()
+ *	_elf64_sign_range()
+ *
+ * Ehdr points to the ELF files ELF header
+ * Phdr points to the ELF files array of Program headers
+ * Shdr points to the ELF files array of Section headers
+ *
+ * There are a some assumptions made in regards ELF layout that relate to
+ * existing practice, and the use of libelf.  The Program Header table (Phdr[])
+ * is assumed to follow the Elf Header (Ehdr[]).  The Sections (Scn) follow the
+ * Program Header table.  The Section Header Table (Shdr[]) is at the end of
+ * the file, and follows the sections.  Although libelf creates this layout,
+ * ELF does not dictate it.  For instance, files exist where the Section Header
+ * table can be located between sections.  The GNU objcopy utility has been
+ * known to create files in this manner.
+ *
+ * The most optimal use of elf_sign_range (where the number of memory ranges
+ * conveyed to the caller is kept to a minimum) is achieved when any
+ * SHT_SUNW_signature section is the last section of the file, and the Section
+ * Header table follows the Sections.  The creation of this optimal layout is
+ * the responsibility of the tools used to add signature information.
+ */
+int
+_elf_sign_range(elf_sign_range_cb_func cb, Ehdr *ehdr, Phdr *phdr, Shdr *shdr,
+    size_t msize, Elf_Signrange type, void *cookie)
+{
+	Phdr		*nphdr, *fphdr = NULL, *lphdr = NULL;
+	Shdr		*nshdr;
+	size_t		offset, size;
+	uint_t		num, shnum;
+	int		sig;
+	boolean_t	process_segments, skip_checksum, skip_signature;
+	boolean_t	extended_sections = _B_FALSE;
+
+	/* If there's no Ehdr, bail */
+	if (ehdr == NULL)
+		return (0);
+
+	/*
+	 * Determine whether to drive the range processing using segments or
+	 * sections from the ELF file type.
+	 */
+	switch (ehdr->e_type) {
+	case ET_EXEC:
+	case ET_DYN:
+		process_segments = _B_TRUE;
+		break;
+	case ET_REL:
+	case ET_SUNW_ANCILLARY:
+		process_segments = _B_FALSE;
+		break;
+	default:
+		return (0);
+	}
+
+	/* Catch a whole file request first */
+	if (type == ELF_SR_FILE) {
+		if (msize)
+			(*cb)(0, msize, cookie);
+		return (1);
+	}
+
+	/*
+	 * Adjust the default processing if necessary from the sign range type.
+	 */
+	switch (type) {
+	case ELF_SR_SIGNED_INTERPRET:
+		skip_checksum = _B_FALSE;
+		skip_signature = _B_FALSE;
+		break;
+	case ELF_SR_INTERPRET:
+		skip_checksum = _B_FALSE;
+		skip_signature = _B_TRUE;
+		break;
+	case ELF_SR_RELOBJ:
+		process_segments = _B_FALSE;
+		skip_checksum = _B_FALSE;
+		skip_signature = _B_TRUE;
+		break;
+	case ELF_SR_CHECKSUM:
+		skip_checksum = _B_TRUE;
+		skip_signature = _B_TRUE;
+		break;
+	default:
+		return (0);
+	}
+
+	/*
+	 * Determine the information within an ELF header that can be verified.
+	 *
+	 * Dynamic objects only have their allocatable sections mapped into
+	 * memory, and these segments are all that need to be verified.  Thus,
+	 * there is some flexibility in that non-allocatable sections can be
+	 * added or removed, and need never be part of a files verification.
+	 * Relocatable objects have all their sections, besides any signature
+	 * section verified.  However, signature sections can be added after
+	 * the original file is built.
+	 *
+	 * Omit the e_shoff element to allow for section modification.
+	 * Capture the range ehdr -> ehdr->e_shoff.
+	 */
+	size = offsetof(Ehdr, e_shoff);
+	if (size > msize)
+		return (0);
+	(*cb)(0, size, cookie);
+
+	/* Reset the offset to the next element ehdr->e_flags */
+	offset = offsetof(Ehdr, e_flags);
+
+	/*
+	 * Omit the e_shum and e_shstrndx elements to allow for section addition
+	 * or deletion, and the possibility that either action could modify the
+	 * Section Header String Table offset.  These two elements are the last
+	 * elements of the Ehdr.
+	 * Capture the range ehdr->e_flags -> ehdr->e_shnum.
+	 */
+	size = offsetof(Ehdr, e_shnum) - offset;
+	if ((offset + size) > msize)
+		return (0);
+	(*cb)(offset, size, cookie);
+
+	/* Reset the offset to the end of the Ehdr */
+	offset = sizeof (Ehdr);
+
+	if (process_segments) {
+		uint_t	phnum = ehdr->e_phnum;
+
+		/*
+		 * Process a dynamic executable or shared object.  If there is
+		 * no Phdr[], something is odd.
+		 */
+		if (phdr == NULL)
+			return (0);
+
+		/*
+		 * If the program header number is PN_XNUM, then the actual
+		 * number must be obtained from Shdr[0].
+		 */
+		if (phnum == PN_XNUM) {
+			if ((shdr == NULL) ||
+			    ((phnum = shdr[0].sh_info) == 0))
+				return (0);
+		}
+
+		/*
+		 * Scan the Phdr[]'s to determine the address range of the
+		 * loadable segments.
+		 */
+		for (num = 0, nphdr = phdr; num < phnum; num++, nphdr++) {
+			/* Ignore any segment that has no backing data */
+			if (nphdr->p_filesz == 0)
+				continue;
+
+			if (nphdr->p_type == PT_DYNAMIC) {
+				if (skip_checksum) {
+					/*
+					 * Under ELF_SR_CHECKSUM omit this
+					 * Phdr[] data range, and return the
+					 * range collected up until the start
+					 * of this Phdr[].
+					 */
+					size = (size_t)nphdr->p_offset - offset;
+					if ((offset + size) > msize)
+						return (0);
+					if (size)
+						(*cb)(offset, size, cookie);
+
+					/*
+					 * Reset the offset to the end of the
+					 * PT_DYNAMIC data.
+					 */
+					offset = (size_t)(nphdr->p_offset) +
+					    (size_t)(nphdr->p_filesz);
+				}
+				continue;
+			}
+
+			if (nphdr->p_type != PT_LOAD)
+				continue;
+
+			/* Keep track of the first and last PT_LOAD segments */
+			if ((fphdr == NULL) ||
+			    (nphdr->p_offset < fphdr->p_offset))
+				fphdr = nphdr;
+			if ((lphdr == NULL) ||
+			    (nphdr->p_offset >= lphdr->p_offset))
+				lphdr = nphdr;
+		}
+
+		/* If there are no loadable segments, something is odd */
+		if (fphdr == NULL)
+			return (0);
+
+		/*
+		 * In theory, the order of Ehdr, Phdr[]'s and the sections the
+		 * Phdr[]'s capture, could provide a number of combinations.
+		 * But, existing practice has Phdr[]'s following the Ehdr.
+		 * For userland dynamic objects, the first PT_LOAD segment
+		 * captures the Ehdr and Phdr[]'s.  For a kernel a.out, the
+		 * Ehdr and Phdr[]'s can be before the sections that are
+		 * captured by the Phdr[] PT_LOAD range, and are not included
+		 * in the Phdr[] PT_LOAD range.
+		 *
+		 * To keep life really simple, we continue the range from the
+		 * end of the Ehdr's processing, and continue to the end of
+		 * the last PT_LOAD.
+		 */
+		if (offset) {
+			size = (size_t)lphdr->p_offset +
+			    (size_t)lphdr->p_filesz - offset;
+			if ((offset + size) > msize)
+				return (0);
+			if (size)
+				(*cb)(offset, size, cookie);
+		}
+	}
+
+	/*
+	 * If this is a dynamic object, and this is not a
+	 * ELF_SR_SIGNED_INTERPRET request, we're done.
+	 */
+	if (process_segments && (skip_signature == _B_TRUE))
+		return (1);
+
+	/*
+	 * If this is relocatable object or kernel module, we're going to
+	 * essentially capture the whole file.  If this is a dynamic object
+	 * then we're only looking for any SHT_SUNW_SIGNATURE section.
+	 *
+	 * If there is no Shdr[], something is odd.
+	 */
+	if (shdr == NULL)
+		return (0);
+
+	/*
+	 * If the section header number is 0, then the actual number must be
+	 * obtained from Shdr[0].
+	 */
+	if ((shnum = ehdr->e_shnum) == 0) {
+		if ((ehdr->e_shoff == 0) ||
+		    ((shnum = shdr[0].sh_size) == 0))
+			return (0);
+
+		extended_sections = _B_TRUE;
+	}
+
+	/*
+	 * Scan the section headers to find the end range.  Note, if this is a
+	 * kernel module that contains a Phdr[], this range will be captured
+	 * after the Ehdr and before the first Shdr[].
+	 */
+	for (num = 0, nshdr = shdr; num < shnum; num++, nshdr++) {
+		/*
+		 * If we're processing a dynamic object, we're only interested
+		 * in collecting the data for any SHT_SUNW_SIGNATURE section.
+		 * Note, if the section has already have been captured during
+		 * Phdr[] processing, ignore it.
+		 */
+		if (process_segments) {
+			offset = (size_t)nshdr->sh_offset;
+
+			if ((nshdr->sh_type == SHT_SUNW_SIGNATURE) &&
+			    ((fphdr && (offset < (size_t)fphdr->p_offset)) ||
+			    (lphdr && (offset > (size_t)lphdr->p_offset)))) {
+				size = (size_t)nshdr->sh_size;
+
+				if ((offset + size) > msize)
+					return (0);
+				if (size)
+					(*cb)(offset, size, cookie);
+			}
+			continue;
+		}
+
+		/*
+		 * Reset the offset if it has been cleared from processing a
+		 * previously skipped section.
+		 */
+		if (offset == 0)
+			offset = (size_t)nshdr->sh_offset;
+
+		if (skip_section(nshdr, skip_checksum)) {
+			/*
+			 * Omit this section, and return the range collected up
+			 * until the start of this section.
+			 */
+			size = (size_t)nshdr->sh_offset - offset;
+			if ((offset + size) > msize)
+				return (0);
+			if (size)
+				(*cb)(offset, size, cookie);
+
+			/*
+			 * Clear the offset, so that it can be assigned to the
+			 * next section.
+			 */
+			offset = 0;
+		}
+	}
+
+	/* If we're processing a dynamic object, we're done */
+	if (process_segments)
+		return (1);
+
+	/*
+	 * Scan the Shdr[] entries themselves, rather than the data the section
+	 * headers point to.
+	 */
+	if (offset == 0)
+		offset = (size_t)ehdr->e_shoff;
+
+	/*
+	 * Collect all elements of the Shdr[] until a SHT_SUNW_SIGNATURE section
+	 * is found.  This section header should be skipped completely, as it
+	 * may not have existed in the file when the original hash was created.
+	 * Any sections that follow a SHT_SUNW_SIGNATURE section have their
+	 * sh_offset skipped.  This allows the SHT_SUNW_SIGNATURE section to be
+	 * added or to have changed size.  The most optimal layout for a signed
+	 * file is for the SHT_SUNW_SIGNATURE to be the last section.
+	 */
+	for (sig = 0, num = 0, nshdr = shdr; num < shnum; num++, nshdr++) {
+
+		if (offset == 0) {
+			offset = (size_t)(ehdr->e_shoff) +
+			    (size_t)(num * sizeof (Shdr));
+		}
+
+		/*
+		 * If extended sections exist, skip the sh_size (e_shnum) and
+		 * the sh_link (e_shstrndx) of Shdr[0].
+		 */
+		if (extended_sections == _B_TRUE) {
+			size = (size_t)(ehdr->e_shoff) +
+			    offsetof(Shdr, sh_size) - offset;
+			if ((offset + size) > msize)
+				return (0);
+			if (size)
+				(*cb)(offset, size, cookie);
+
+			/* Reset the offset to follow sh_link */
+			offset = (size_t)(ehdr->e_shoff) +
+			    offsetof(Shdr, sh_link);
+			extended_sections = _B_FALSE;
+
+		} else if (nshdr->sh_type == SHT_SUNW_SIGNATURE) {
+			size = (size_t)(ehdr->e_shoff) +
+			    (size_t)(num * sizeof (Shdr)) - offset;
+			if ((offset + size) > msize)
+				return (0);
+			if (size)
+				(*cb)(offset, size, cookie);
+
+			/* Reset the offset to capture next the next section */
+			offset = 0;
+			sig++;
+
+		} else if (sig) {
+			/*
+			 * If a SHT_SUNW_SIGNATURE Shdr[] has been found, then
+			 * any sections that follow may be at a different
+			 * offset, should the SHT_SUNW_SIGNATURE section get
+			 * rewritten and change size.  If SHT_SUNW_SIGNATURE
+			 * sections are fixed length, none of this is necessary.
+			 *
+			 * Optimally, a SHT_SUNW_SIGNATURE section should be the
+			 * last section of a file, which would result in this
+			 * code not being exercised.
+			 */
+			size = (size_t)(ehdr->e_shoff) +
+			    (size_t)(num * sizeof (Shdr)) +
+			    offsetof(Shdr, sh_offset) - offset;
+			if ((offset + size) > msize)
+				return (0);
+			if (size)
+				(*cb)(offset, size, cookie);
+
+			/* Reset the offset to the following element */
+			offset = (size_t)(ehdr->e_shoff) +
+			    (size_t)(num * sizeof (Shdr)) +
+			    offsetof(Shdr, sh_size);
+		}
+	}
+
+	/* Flush out the range remaining to the end of that last Shdr */
+	if (offset) {
+		size = (size_t)(ehdr->e_shoff) +
+		    (size_t)(num * sizeof (Shdr)) - offset;
+		if ((offset + size) > msize)
+			return (0);
+		if (size)
+			(*cb)(offset, size, cookie);
+	}
+	return (1);
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/vboot/verify.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/vboot/verify.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,185 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Verify the elfsign(1) signature for the initial Solaris unix module.
+ * Extract policy settings and keys.
+ *
+ * No ELF- or crypto-specific code should be in this file.
+ *
+ * ZVBOOT
+ *   Define this for use by GRUB2 Solaris kernel zones zvboot loader to
+ *   verify the unix module signature.
+ *
+ * EFI_VBOOT
+ *   Define this for use by the GRUB2 multiboot loader to
+ *   verify the unix module signature.
+ */
+
+#include <sys/types.h>
+#include <sys/verified_boot.h>	/* Verified Boot types */
+#include "verify.h"
+
+#include <grub/misc.h>		/* grub_str*() and other useful utilities */
+#include <grub/mm.h>		/* grub_*alloc* and other memory management */
+
+#include <grub/dl.h>
+GRUB_MOD_LICENSE("GPLv3+");
+
+#if defined(ZVBOOT)
+#include "zvcons.h"		/* panic(), console I/O */
+#elif defined(EFI_VBOOT)
+/* Invoke a panic by returning a non-0 value: */
+#define	panic(...)	grub_printf("PANIC: ");  grub_printf(__VA_ARGS__); \
+			return (1)
+#endif	/* ZVBOOT, EFI_VBOOT */
+
+
+/*
+ * Default, hard-coded keys
+ * default_modulus	is the modulus from
+ *			/etc/certs/elfsign/Oracle_Solaris_2017.pem.
+ *			This is for the current Solaris version.
+ * s11_modulus		is the modulus from /etc/certs/elfsign/ORCLS11SE.
+ *			This is for Solaris 11. Some non-ON Oracle
+ *			software is signed with this key.
+ * s12_modulus		is the modulus from /etc/certs/elfsign/ORCLS12SE.
+ *			This is for Solaris 12.
+ * internal_modulus	is the modulus from /etc/certs/elfsign/INTERNALSE.
+ *			This is for developer builds only.
+ */
+#include <sys/verify_key.h>
+#ifdef USE_INTERNAL_CERT
+#include <sys/verify_key2.h>
+#endif
+
+/* Internal key storage values (not for use in firmware or virtual APIs) */
+#define	ADDITIONAL_KEYS		1	/* ORCLS12SE */
+#define	MAX_KEYS_INTERNAL	(MAX_VERIFY_PUBLIC_KEYS_V1 + ADDITIONAL_KEYS)
+
+/*
+ * Return the policies and elfsign public key(s).
+ * On failure, only add the default keys.
+ * The default policy is 'warning' set by the caller.
+ */
+static void
+verify_get_settings(verified_boot_cert_t *certs, uint_t max_key_count,
+    uint_t *key_count, verify_policy_t *boot_policy)
+{
+	/* Copy default, hard-coded keys */
+	grub_memcpy(certs[*key_count].key, default_modulus,
+	    VERIFY_MODULUS_LEN);
+	grub_memcpy(certs[*key_count].dn_hash, default_dn_hash,
+	    VERIFY_DN_HASH_LEN);
+#ifdef	VERBOSE_VBOOT_DEBUG
+	grub_dprintf(DBGLABEL,
+	    "verify_get_settings: Oracle_Solaris_2017.pem key:\n");
+	vboot_hex_print(&(*certs)[*key_count].key, VERIFY_MODULUS_LEN);
+#endif
+	(*key_count)++;
+
+	grub_memcpy(certs[*key_count].key, s11_modulus,
+	    VERIFY_MODULUS_LEN);
+	grub_memcpy(certs[*key_count].dn_hash, s11_dn_hash,
+	    VERIFY_DN_HASH_LEN);
+#ifdef	VERBOSE_VBOOT_DEBUG
+	grub_dprintf(DBGLABEL, "verify_get_settings: ORCLS11SE key:\n");
+	vboot_hex_print(&(*certs)[*key_count].key, VERIFY_MODULUS_LEN);
+#endif
+	(*key_count)++;
+
+	grub_memcpy(certs[*key_count].key, s12_modulus,
+	    VERIFY_MODULUS_LEN);
+	grub_memcpy(certs[*key_count].dn_hash, s12_dn_hash,
+	    VERIFY_DN_HASH_LEN);
+#ifdef	VERBOSE_VBOOT_DEBUG
+	grub_dprintf(DBGLABEL, "verify_get_settings: ORCLS12SE key:\n");
+	vboot_hex_print(&(*certs)[*key_count].key, VERIFY_MODULUS_LEN);
+#endif
+	(*key_count)++;
+
+#ifdef USE_INTERNAL_CERT
+	/* INTERNALSE key for in-house Solaris development builds only */
+	grub_memcpy(certs[*key_count].key, internal_modulus,
+	    VERIFY_MODULUS_LEN);
+	grub_memcpy(certs[*key_count].dn_hash, internal_dn_hash,
+	    VERIFY_DN_HASH_LEN);
+#ifdef	VERBOSE_VBOOT_DEBUG
+	grub_dprintf(DBGLABEL, "verify_get_settings: INTERNALSE key:\n");
+	vboot_hex_print(&(*certs)[*key_count].key, VERIFY_MODULUS_LEN);
+#endif
+	(*key_count)++;
+#endif /* USE_INTERNAL_CERT */
+
+	(void) verify_get_settings_hv(certs, max_key_count, key_count,
+	    boot_policy);
+
+	grub_dprintf(DBGLABEL, "verify_get_settings: "
+	    "have %d total keys with policy %d\n",
+	    *key_count, *boot_policy);
+}
+
+
+/*
+ * Verify an elfsign signature for a file.
+ * For signature failures, ignore, print a warning message, or panic
+ * depending on the boot_policy setting.
+ * Return 0 on success, non-zero on failure.
+ */
+int
+verify_module(const unsigned char *file)
+{
+	verify_policy_t		boot_policy = VERIFY_EFI_DEFAULT;
+	uint_t			key_count = 0;
+	verified_boot_cert_t	certs[MAX_KEYS_INTERNAL];
+	int			rc = 0;
+
+	grub_memset(certs, 0, sizeof (verify_public_certs_t));
+	verify_get_settings(&certs[0], MAX_KEYS_INTERNAL,
+	    &key_count, &boot_policy);
+
+	if (boot_policy == VERIFY_NONE)
+		return (0);
+
+	/* Verify elfsign signature in ELF file module */
+	if ((rc = verify_module_signature(file, certs, key_count))
+	    != 0) {
+		grub_dprintf(DBGLABEL, "verify_module: UNIX kernel image "
+		    "verification failed; rc = %d.\n", rc);
+	} else {
+		grub_dprintf(DBGLABEL, "verify_module: UNIX kernel image "
+		    "verification successful\n");
+		return (0);
+	}
+
+	switch (boot_policy) {
+	case VERIFY_ENFORCE:
+		/* Fatal-level messages must have NO prefix: */
+		grub_printf("Signature verification of UNIX kernel image "
+		    "failed; boot-policy is set to \"enforce\".\n");
+		panic("Unable to boot: boot-policy is set to \"enforce\".\n");
+	case VERIFY_WARNING:
+		/* Non-fatal messages must have a WARNING: or NOTICE: prefix: */
+		grub_printf("WARNING: Signature verification of "
+		    "UNIX kernel image failed\n");
+		break;
+	default:
+		panic("Invalid Verified Boot policy value %d\n", boot_policy);
+	}
+	return (0);
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/vboot/verify.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/vboot/verify.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,116 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Internal header file for use in GRUB zvboot or multiboot.
+ *
+ * ZVBOOT
+ *   Define this for use by GRUB2 Solaris kernel zones zvboot loader to
+ *   verify the unix module signature.
+ *
+ * EFI_VBOOT
+ *   Define this for use by the GRUB2 multiboot loader to
+ *   verify the unix module signature.
+ */
+
+#ifndef _VERIFY_H
+#define	_VERIFY_H
+
+#include <sys/types.h>
+#include <sys/verified_boot.h>	/* Verified Boot types */
+
+#include <grub/mm.h>		/* grub_*alloc* and other memory management */
+#include <grub/misc.h>		/* grub_str*() and other useful utilities */
+#include <grub/time.h>		/* grub_sleep(), for debugging */
+
+#if defined(EFI_VBOOT)		/* multiboot2 for GRUB UEFI mode */
+#define	DBGLABEL		"vboot"
+#include <grub/file.h>		/* grub_file_t defintions and functions */
+#include <ctype.h>
+
+#ifdef _BIG_ENDIAN
+#define	htonl(x) (x)
+#else
+#define	htonl(x) (((uint32_t)(x) << 24) | (((uint32_t)(x) << 8) & 0xff0000) | \
+	(((uint32_t)(x) >> 8) & 0xff00) | ((uint32_t)(x)  >> 24))
+#endif
+
+#elif defined(ZVBOOT)		/* zvboot for Kernel Zones */
+#define	DBGLABEL		"zvboot"
+#else
+#error	"ZVBOOT or EFI_VBOOT needs to be defined."
+#endif	/* ZVBOOT, EFI_VBOOT */
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#define	vboot_alloc(size)	grub_malloc(size)
+#define	vboot_free(buf, size)	grub_free(buf)
+#define	bcopy(src, dst, n)	grub_memcpy((dst), (src), (n))
+#define	bcmp(s1, s2, n)		grub_memcmp((s1), (s2), (n))
+#define	bzero(s, n)		grub_memset((s), 0, (n))
+#define	strchr(s, c)		grub_strchr((s), (c))
+#define	strncpy(dst, src, n)	grub_strncpy((dst), (src), (n))
+
+#define	VBOOT_DEBUG(...)	grub_dprintf(DBGLABEL, __VA_ARGS__)
+#define	VBOOT_ERROR(...)	grub_printf(__VA_ARGS__)
+#define	VBOOT_NOTICE(...)	grub_printf(__VA_ARGS__)
+
+#define	VERIFY_EFI_DEFAULT	VERIFY_WARNING
+
+#define	BOOT_POLICY_STRING(n)	((n) == 1 ? "none" : ((n) == 2 ? "warning" : \
+	((n) == 3 ? "enforce" : "unknown")))
+
+/* verify_zvboot.c or verify_efi.c */
+extern int verify_get_settings_hv(verified_boot_cert_t *certs,
+    uint_t max_cert_count, uint_t *cert_count, verify_policy_t *boot_policy);
+
+/* verify_elf.c */
+extern void vboot_hex_print(const void *data, size_t length);
+extern void vboot_char_print(const void *data, size_t length);
+extern int verify_module_signature(const uchar_t *file,
+    verified_boot_cert_t *certs, uint_t num_keys);
+
+/* verify_rsa.c */
+extern int verify_signature_against_keys(verified_boot_cert_t *certs,
+    unsigned int num_keys, const unsigned char *signature,
+    size_t sig_len, const unsigned char *dn_hash,
+    const unsigned char *data, size_t data_len);
+
+/* verify.c */
+extern int verify_module(const unsigned char *file);
+
+#if defined(EFI_VBOOT)
+/* verify_efi.c */
+extern int multiboot2_verify_module(grub_file_t file);
+
+/* verify_cert.c */
+extern int get_decoded_keys_from_image(uchar_t *sbuf, uint64_t buffer_size,
+    const char *cert_pathname, uchar_t **key);
+
+/* verify_base64.c */
+extern ssize_t b64_decode(void *outbuf, size_t outbufsz, const char *inbuf,
+    const char *alpha, uint64_t flags);
+#endif
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _VERIFY_H */
diff -r 68f95e015346 usr/src/grub/src/contrib/vboot/verify_base64.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/vboot/verify_base64.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,126 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Base64 decoding function using 65 printable US-ASCII characters.
+ * Defined in https://www.ietf.org/rfc/rfc4648.txt
+ * For use only with Solaris Verified Boot verification.
+ */
+
+#include <sys/types.h>
+#include <string.h>
+#ifdef EFI_VBOOT
+#include "verify.h"
+#endif
+
+static inline boolean_t
+is_base64(unsigned char c)
+{
+	return ((c >= '0' && c <= '9') ||
+	    (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
+	    (c == '+') || (c == '/'));
+}
+
+
+/*
+ * Decode printable characters, using the base64 algorithm.
+ * Encoded string must be NUL-terminated.
+ */
+ssize_t
+b64_decode(void *outbuf, size_t outbufsz, const char *inbuf, const char *alpha,
+    uint64_t flags)
+{
+	static const char *b64_digits =
+	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+	uchar_t		*decoded_str = (uchar_t *)outbuf;
+	uchar_t		*encoded_str = (uchar_t *)inbuf;
+	size_t		i = 0;
+	size_t		j = 0;
+	size_t		encoded_index = 0;
+	ssize_t		decoded_index = 0;
+	uchar_t		u, array4[4], array3[3];
+	char		*p;
+
+	if ((alpha != NULL) || (flags != 0)) {
+		return (-1);
+	}
+
+	while ((u = encoded_str[encoded_index]) != '\0') {
+		if (!is_base64(u)) {
+			encoded_index++;
+			continue;
+		}
+		if (decoded_index > outbufsz) {
+			return (-1);
+		}
+
+		array4[i++] = encoded_str[encoded_index++];
+		if (i == 4) {
+			for (i = 0; i < 4; i++) {
+				p = strchr(b64_digits, (char)array4[i]);
+				if (p == NULL) {
+					return (-1);
+				}
+
+				/* save base64 index */
+				array4[i] = p - b64_digits;
+			}
+
+			array3[0] = (array4[0] << 2) +
+			    ((array4[1] & 0x30) >> 4);
+			array3[1] = ((array4[1] & 0xf) << 4) +
+			    ((array4[2] & 0x3c) >> 2);
+			array3[2] = ((array4[2] & 0x3) << 6) +
+			    array4[3];
+
+			for (i = 0; i < 3; i++) {
+				decoded_str[decoded_index++] = array3[i];
+			}
+
+			i = 0;
+		}
+	}
+
+	if (i != 0) {
+		/* fill in the rest with zero */
+		for (j = i; j < 4; j++)
+			array4[j] = 0;
+
+		for (j = 0; j < 4; j++) {
+			p = strchr(b64_digits, (char)array4[j]);
+			if (p == NULL) {
+				return (-1);
+			}
+
+			array4[j] = p - b64_digits;
+		}
+
+		array3[0] = (array4[0] << 2) +
+		    ((array4[1] & 0x30) >> 4);
+		array3[1] = ((array4[1] & 0xf) << 4) +
+		    ((array4[2] & 0x3c) >> 2);
+		array3[2] = ((array4[2] & 0x3) << 6) +
+		    array4[3];
+
+		for (j = 0; j < (i - 1); j++) {
+			decoded_str[decoded_index++] = array3[j];
+		}
+	}
+
+	return (decoded_index);
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/vboot/verify_cert.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/vboot/verify_cert.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,538 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ * Copyright (c) 2003, 2024, Oracle and/or its affiliates.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Read and parse RSA X.509 certificates.
+ * For use only with Solaris Verified Boot verification.
+ *
+ * Modified from several libkmf and other files.
+ */
+
+#include <sys/types.h>
+#include <sys/stdbool.h>
+#include <sys/note.h>
+#include <sys/verified_boot.h>
+
+#ifdef EFI_VBOOT
+#include "verify.h"
+
+#else
+#include <sys/byteorder.h>	/* htonl() */
+#include <sys/systm.h>		/* kernel bcopy() definition, strchr() */
+#include <sys/kobj_impl.h>	/* internal bcopy() implementation */
+#include "vboot/vboot.h"
+#endif	/* EFI_VBOOT */
+
+/* BER-encoded ASN.1 object tag identifiers */
+#define	BER_INTEGER			0x02
+#define	BER_BIT_STRING			0x03
+#define	BER_CONSTRUCTED_SEQUENCE	0x30
+#define	BER_CONSTRUCTED_SET		0x31
+
+#define	BEGIN_CERT			"-----BEGIN"
+
+typedef int32_t ber_tag_t;
+
+
+/* Skip over a BER tag (type, length, value). */
+static ber_tag_t
+ber_skip_tag(uchar_t **sbuf, size_t *len, size_t max_len)
+{
+	ber_tag_t	tag;
+	uchar_t		lc;
+	size_t		noctects, diff;
+	uint32_t	netlen;
+
+	/* Assume no big tag */
+	tag = lc = **sbuf;
+	(*sbuf)++;
+
+	*len = 0;
+	netlen = 0;
+	lc = **sbuf;
+	(*sbuf)++;
+
+	if ((lc & 0x80) != 0) {	/* long-form length */
+		noctects = (lc & 0x7f);
+		if (noctects > sizeof (ber_tag_t)) {
+			return (-1);
+		}
+		diff = sizeof (ber_tag_t) - noctects;
+		bcopy(*sbuf, (uchar_t *)&netlen + diff, noctects);
+		*sbuf += noctects;
+		*len = htonl(netlen);
+	} else {		/* short-form length */
+		*len = lc;
+	}
+
+	if (*len > max_len) {
+		VBOOT_DEBUG("BER len %ld for tag 0x%x > max_len %ld\n",
+		    *len, tag, max_len);
+		*len = 0;
+		return (-1);
+	}
+
+	return (tag);
+}
+
+
+/* Get the length for a tag. */
+static size_t
+calc_taglen(ber_tag_t tag)
+{
+	int		i;
+	uint32_t	mask;
+
+	/* Find first non-zero byte in tag. */
+	for (i = sizeof (ber_tag_t) - 1; i > 0; i--) {
+		mask = (0xffffff << (i * 8));
+		if ((tag & mask) != 0) {
+			break;
+		}
+	}
+
+	return (i + 1);
+}
+
+
+/* Get the length of the length field. */
+static size_t
+calc_lenlen(size_t len)
+{
+	if (len <= 0x7f) {
+		return (1);
+	} else if (len <= 0xff) {
+		return (2);
+	} else if (len <= 0xffff) {
+		return (3);
+	} else if (len <= 0xffffff) {
+		return (4);
+	} else {
+		return (5);
+	}
+}
+
+
+/* Get the cert's valid date range (not before, not after). */
+static void
+get_validity(uchar_t **sbuf, size_t max_len)
+{
+	uchar_t		*buf, *tmpbuf;
+	ber_tag_t	ber_tag = 0;
+	size_t		ber_len = 0;
+
+	tmpbuf = buf  = *sbuf;
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	buf = tmpbuf;
+
+	if (ber_tag != BER_CONSTRUCTED_SEQUENCE) { /* skip */
+		return;
+	}
+
+	/* BER '{tata}' */
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	buf += ber_len;
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	buf += ber_len;
+
+	*sbuf = buf;
+}
+
+
+/* Get the Relative Distinguished Name, RDN. */
+static void
+get_rdn(uchar_t **sbuf, size_t max_len)
+{
+	uchar_t		*buf, *tmpbuf;
+	ber_tag_t	ber_tag = 0;
+	size_t		ber_len = 0;
+
+	buf = *sbuf;
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+
+	tmpbuf = buf;
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	buf = tmpbuf;
+
+	while (ber_tag == BER_CONSTRUCTED_SET) {
+		ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+
+		/* skip over the set */
+		buf += ber_len;
+		tmpbuf = buf;
+		ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+		buf = tmpbuf;
+	}
+
+	*sbuf = buf;
+}
+
+
+/* Get the signing algorithm's OID. */
+static void
+get_algoid(uchar_t **sbuf, size_t max_len)
+{
+	uchar_t		*buf, *tmpbuf;
+	ber_tag_t	ber_tag = 0;
+	size_t		ber_len = 0;
+	size_t		size;
+
+	tmpbuf = buf = *sbuf;
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	buf = tmpbuf;
+
+	size = ber_len + calc_taglen(ber_tag) +
+	    calc_lenlen(ber_len);
+	buf += size;
+	*sbuf = buf;
+}
+
+
+/* Extract the SPKI (Simple Public Key Infrastructure) data from the cert. */
+static int
+extract_spki_from_decoded_cert(uchar_t *decoded, uchar_t **ret,
+    size_t *ret_len, size_t max_len)
+{
+	uchar_t		*tmpbuf, *spki;
+	uchar_t		*buf = decoded;
+	ber_tag_t	ber_tag = 0;
+	size_t		ber_len = 0;
+
+	/* Sequence header - skip tag */
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+
+	/* Extract to-be-signed (TBS) data. */
+	/* BER '{' - skip tag */
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+
+	/* BER 't' - peek tag */
+	tmpbuf = buf;
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	buf = tmpbuf;
+
+	/* Get version number, if present. */
+	if (ber_tag == 0xa0) {
+		/* BER 'T' - skip tag */
+		ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+
+		/* BER 'i' - read int */
+		ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+		buf += ber_len;
+	}
+
+	/* Get serial number. */
+	/* BER 'I' - read bigint */
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	if (ber_tag != BER_INTEGER) {
+		VBOOT_DEBUG("tag is not BER_INTEGER\n");
+		return (1);
+	}
+	buf += ber_len;
+
+	/* Get signature algorithm, CA DN, validity dates, DN. */
+	get_algoid(&buf, max_len);
+	get_rdn(&buf, max_len);
+	get_validity(&buf, max_len);
+	get_rdn(&buf, max_len);
+
+	/* BER '{' - skip tag */
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	if (ber_len > max_len) {
+		VBOOT_DEBUG("ber_len %ld > max_len %ld\n", ber_len, max_len);
+		return (1);
+	}
+
+	get_algoid(&buf, max_len);
+
+	/* BER 'B}' - get string */
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	if (ber_tag == BER_BIT_STRING) {
+		spki = vboot_alloc(ber_len);
+		bcopy(buf, spki, ber_len);
+	} else {
+		VBOOT_DEBUG("tag is not BER_BIT_STRING\n");
+		return (3);
+	}
+
+	*ret = spki;
+	*ret_len = ber_len;
+
+	return (0);
+}
+
+
+/*
+ * Extract the RSA public key modulus from the SPKI data.
+ * KeyParts has modulus at index 0 and pub exp at index 1.
+ * Allocated memory at ret must be freed by caller.
+ * Return 0 on success, otherwise non-zero.
+ */
+static int
+extract_rsa_public_key_modulus_from_spki(uchar_t *spki, size_t spki_size,
+    uchar_t **ret, size_t *ret_len)
+{
+	uchar_t		*modulus;
+	uchar_t		*buf = spki;
+	ber_tag_t	ber_tag;
+	size_t		ber_len;
+	size_t		max_len = spki_size;
+
+	/* Strip leading 0's */
+	while ((*buf == 0x00) && (spki_size > 0)) {
+		buf++;
+		spki_size--;
+	}
+
+	/* The first sequence is '{' */
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	if (ber_len > max_len) {
+		VBOOT_DEBUG("ber_len %ld > max_len %ld\n", ber_len, max_len);
+		return (1);
+	}
+
+	/* The second sequence is 'I' */
+	ber_tag = ber_skip_tag(&buf, &ber_len, max_len);
+	if (ber_len > max_len) {
+		VBOOT_DEBUG("ber_len %ld > max_len %ld\n", ber_len, max_len);
+		return (1);
+	}
+	if (ber_tag != BER_INTEGER) {
+		VBOOT_DEBUG("tag is not BER_INTEGER\n");
+		return (1);
+	}
+
+	/* Strip leading 0's if the high-order bit is set. */
+	while ((*buf == 0x00) && (ber_len > 0) && ((buf[1] & 0x80) != 0)) {
+		buf++;
+		ber_len--;
+	}
+	modulus = vboot_alloc(ber_len);
+	(void) bcopy(buf, modulus, ber_len);
+
+	*ret = modulus;
+	*ret_len = ber_len;
+
+	return (0);
+}
+
+
+/*
+ * Determine if this is a binary DER format cert.
+ * Otherwise, assume it's an ASCII PEM format file.
+ */
+static bool
+is_der_format(const uchar_t *cert, size_t size)
+{
+	size_t	value_len, cert_len, i;
+
+	if ((size < 2) || (cert[0] != 0x30)) {
+		return (false);
+	}
+
+	if ((cert[1] & 0x80) == 0) {		/* short-form length */
+		cert_len = cert[1] & 0x7f;
+		size -= 2;
+	} else {				/* long-form length */
+		value_len = cert[1] & 0x7f;
+		cert_len = 0;
+
+		/* Ensure range doesn't overflow */
+		if (size < 2 + value_len) {
+			VBOOT_DEBUG("DER value length check failed "
+			    "(value_len=%lu, size=%lu)\n", value_len, size);
+			return (false);
+		}
+
+		for (i = 2; i < (2 + value_len); i++) {
+			cert_len = (cert_len << 8) + cert[i];
+		}
+		size -= (2 + value_len);
+	}
+
+	if (cert_len != size) {
+		VBOOT_DEBUG("DER length check failed (len=%lu, size=%lu)\n",
+		    cert_len, size);
+		return (false);
+	}
+
+	return (true);
+}
+
+
+/*
+ * Given an in-memory image of a elfsign X.509 certificate file,
+ * extract the RSA-2048 public key modulus value in binary.
+ * Allocated memory at *key must be freed by caller.
+ */
+int
+get_decoded_keys_from_image(uchar_t *sbuf, size_t buffer_size,
+    const char *cert_pathname, uchar_t **key)
+{
+	uchar_t		*encoded;
+	uchar_t		*decoded = NULL;
+	uchar_t		*spki = NULL;
+	uchar_t		*modulus = NULL;
+	size_t		i, j;
+	ssize_t		decoded_size = 0;
+	size_t		spki_size = 0;
+	size_t		modulus_size = 0;
+	int		rv;
+
+	/* Sanity check */
+	if (buffer_size == 0) {
+		VBOOT_DEBUG("Empty cert file: %s\n", cert_pathname);
+		return (3);
+	}
+
+	if (!is_der_format(sbuf, buffer_size)) {
+		/*
+		 * PEM format file. Convert to binary.
+		 * Locate the BEGIN and END lines and copy lines in between.
+		 */
+		uchar_t		*tmpbuf;
+		size_t		tmp_size;
+
+		encoded = vboot_alloc(buffer_size);
+
+		/* Flush everything up to -----BEGIN */
+		for (i = 0; (i < buffer_size - sizeof (BEGIN_CERT)) &&
+		    (bcmp(&sbuf[i], BEGIN_CERT, sizeof (BEGIN_CERT) - 1) != 0);
+		    ++i) {
+			;
+		}
+		if (i == buffer_size - sizeof (BEGIN_CERT)) { /* no BEGIN */
+			VBOOT_DEBUG("No X.509 certificate found in file %s\n",
+			    cert_pathname);
+			vboot_free(encoded, buffer_size);
+			return (9);
+		}
+
+		while ((sbuf[i] != '\n') && (i < buffer_size)) {
+			++i;
+		}
+		++i;
+		if (i == buffer_size) { /* no BEGIN line */
+			VBOOT_DEBUG("No X.509 certificate found in file %s\n",
+			    cert_pathname);
+			vboot_free(encoded, buffer_size);
+			return (9);
+		}
+
+		/* Copy encoded data between BEGIN and END CERTIFICATE lines */
+		j = 0;
+		while ((sbuf[i] != '-') && (i < buffer_size)) {
+			encoded[j++] = sbuf[i++];
+		}
+		if ((j == 0) || (i == buffer_size)) { /* no END CERTIFICATE */
+			VBOOT_DEBUG("No X.509 certificate found in file %s\n",
+			    cert_pathname);
+			vboot_free(encoded, buffer_size);
+			return (10);
+		}
+
+		/* No need to decode the new line at the end */
+		tmp_size = (((j + 3) / 4) * 3);
+		if (tmp_size > buffer_size) {
+			VBOOT_DEBUG("Cert strlen %ld > buffer size %ld\n",
+			    tmp_size, buffer_size);
+			vboot_free(encoded, buffer_size);
+			return (11);
+		}
+		tmpbuf = vboot_alloc(tmp_size);
+
+		encoded[j] = '\0';
+		decoded_size = b64_decode(tmpbuf, tmp_size, (char *)encoded,
+		    NULL, 0);
+		vboot_free(encoded, buffer_size);
+		if (decoded_size <= 0) {
+			VBOOT_DEBUG("b64_decode failed for file %s; rc %ld\n",
+			    cert_pathname, decoded_size);
+			vboot_free(tmpbuf, tmp_size);
+			return (12);
+		} else if (decoded_size > buffer_size) {
+			VBOOT_DEBUG("Decoded size %ld > buffer size %ld\n",
+			    decoded_size, buffer_size);
+			vboot_free(tmpbuf, tmp_size);
+			return (18);
+		}
+
+		/* Check the decoded format's cert len */
+		if (!is_der_format(tmpbuf, decoded_size)) {
+			VBOOT_DEBUG("DER format check failed for file %s\n",
+			    cert_pathname);
+			vboot_free(tmpbuf, tmp_size);
+			return (13);
+		}
+
+		/* Allocate the exact decoded size and copy to it */
+		decoded = vboot_alloc(decoded_size);
+		bcopy(tmpbuf, decoded, decoded_size);
+		vboot_free(tmpbuf, tmp_size);
+
+		sbuf = decoded;
+		buffer_size = decoded_size;
+	}
+
+#ifdef	VERBOSE_VBOOT_DEBUG
+	VBOOT_DEBUG("Decoded output, %lu bytes:\n", buffer_size);
+	vboot_hex_print((unsigned char *)sbuf, buffer_size);
+#endif
+
+	/* Convert decoded data to SPKI */
+	rv = extract_spki_from_decoded_cert(sbuf, &spki, &spki_size,
+	    buffer_size);
+	vboot_free(decoded, decoded_size);
+	if (rv != 0) {
+		VBOOT_DEBUG("DecodeSignedCertificate failed, cert file %s\n",
+		    cert_pathname);
+		return (15);
+	}
+
+#ifdef	VERBOSE_VBOOT_DEBUG
+	VBOOT_DEBUG("SPKI output, %d bytes:\n", spki_size);
+	vboot_hex_print((unsigned char *)spki, spki_size);
+#endif
+
+	rv = extract_rsa_public_key_modulus_from_spki(spki, spki_size,
+	    &modulus, &modulus_size);
+	vboot_free(spki, spki_size);
+	if (rv != 0) {
+		VBOOT_DEBUG("ExtractSPKI_RSA failed, cert file %s\n",
+		    cert_pathname);
+		return (16);
+	}
+
+	/* Check modulus length */
+	if (modulus_size != VERIFY_MODULUS_LEN) {
+		VBOOT_DEBUG("Key length is not 256 bytes, cert file %s\n",
+		    cert_pathname);
+		vboot_free(modulus, modulus_size);
+		return (17);
+	}
+
+#ifdef	VERBOSE_VBOOT_DEBUG
+	VBOOT_DEBUG("Modulus output, %d bytes:\n", modulus_size);
+	vboot_hex_print((unsigned char *)modulus, modulus_size);
+#endif
+
+	*key = modulus;
+
+	VBOOT_DEBUG("get_decoded_keys_from_image(%s) OK\n", cert_pathname);
+	return (0);
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/vboot/verify_efi.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/vboot/verify_efi.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,424 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2017, 2024, Oracle and/or its affiliates.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * X86 GRUB UEFI-specific functions for Solaris Verified Boot.
+ *
+ * No ELF- or crypto-specific code should be in this file.
+ */
+
+#ifndef EFI_VBOOT
+#error	"EFI_VBOOT needs to be defined."
+#endif
+#ifndef GRUB_MACHINE_EFI
+#error	"GRUB_MACHINE_EFI needs to be defined."
+#endif
+
+#include <sys/types.h>
+#include <sys/verified_boot.h>	/* Verified Boot types */
+#include "verify.h"
+
+#include <grub/misc.h>		/* grub_str*() and other useful utilities */
+#include <grub/mm.h>		/* grub_*alloc* and other memory management */
+#include <grub/file.h>		/* grub_file_t defintions and functions */
+#include <grub/env.h>		/* grub_env_get() */
+#include <grub/time.h>		/* grub_sleep(), for debugging */
+#include <grub/verify.h>
+
+#include <grub/efi/efi.h>	/* grub_efi_* types and functions for UEFI */
+#include <grub/efi/api.h>	/* GRUB_EFI_* constants */
+#include <grub/efi/sb.h>
+
+#define	SIGNATURE_DATABASE	"db"
+#define	MIN_DER_HEADER_LEN	2
+
+/* GUID definitions */
+#define	GUIDS_EQUAL(s1, s2)	(bcmp((s1), (s2), sizeof (*(s1))) == 0)
+#define	EFI_IMAGE_SECURITY_DATABASE_GUID {0xd719b2cb, 0x3d3a, 0x4596, \
+	{0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f}}
+#define	EFI_X509_GUID {0xa5c059a1, 0x94e4, 0x4aa7, \
+	{0x87, 0xb5, 0xab, 0x15, 0x5c, 0x2b, 0xf0, 0x72}}
+#define	EFI_RSA2048_GUID {0x3c5766e8, 0x269c, 0x4e34, \
+	{0xaa, 0x14, 0xed, 0x77, 0x6e, 0x85, 0xb3, 0xb6}}
+#define	EFI_PKCS7_GUID {0x4aafd29d, 0x68df, 0x49ee, \
+	{0x8a, 0xa9, 0x34, 0x7d, 0x37, 0x56, 0x65, 0xa7}}
+#define	EFI_CERT_SHA256_GUID {0xc1c41626, 0x504c, 0x4092, \
+	{0xac, 0xa9, 0x41, 0xf9, 0x36, 0x93, 0x43, 0x28}}
+#define	EFI_MICROSOFT_KEK_CA_2011_GUID {0x77fa9abd, 0x0359, 0x4d32, \
+	{0xbd, 0x60, 0x28, 0xf4, 0xe7, 0x8f, 0x78, 0x4b}}
+
+/* UEFI certificate and signature definitions */
+#pragma GCC diagnostic ignored "-Wpacked-not-aligned"
+#pragma pack(1) /* disable alignment */
+typedef struct _efi_signature_data {
+	grub_guid_t	SignatureOwner;
+	uchar_t		SignatureData[];
+} efi_signature_data;
+
+typedef struct _efi_signature_list {
+	grub_guid_t	SignatureType;
+	uint32_t	SignatureListSize;
+	uint32_t	SignatureHeaderSize; /* 0 */
+	uint32_t	SignatureSize; /* includes GUID size */
+} efi_signature_list;
+#pragma pack()
+
+int efi_verify_module(grub_file_t);
+void grub_vboot_verifier_setup(void);
+
+/* Access the boot_policy EFI SecureBoot variable and determine boot_policy. */
+static verify_policy_t
+verify_get_boot_policy(void)
+{
+	uchar_t		*secure_boot;
+	grub_size_t	secure_boot_size = 0;
+	int		secure_boot_enabled = 0;
+	grub_guid_t	global_guid = GRUB_EFI_GLOBAL_VARIABLE_GUID;
+	const char	*boot_policy_str;
+	verify_policy_t	boot_policy = VERIFY_EFI_DEFAULT;
+	grub_efi_status_t status;
+
+	/* See if Secure Boot is enabled by reading EFI variable SecureBoot. */
+	status  = grub_efi_get_variable("SecureBoot", &global_guid,
+	    &secure_boot_size, (void **) &secure_boot);
+	if ((status == GRUB_EFI_SUCCESS) && (secure_boot != NULL) && (secure_boot_size != 0) &&
+	    (*secure_boot != 0)) {
+		secure_boot_enabled = 1;
+	}
+	grub_dprintf(DBGLABEL, "SecureBoot %sabled (%u, len %lu)\n",
+	    secure_boot_enabled ? "en" : "dis", secure_boot ? *secure_boot : 0,
+	    secure_boot_size);
+	grub_free(secure_boot);
+
+	/* Read and validate boot_policy variable, if present. */
+	boot_policy_str = grub_env_get("boot_policy");
+	if (boot_policy_str != NULL) {
+		if (grub_strcmp(boot_policy_str, "enforce") == 0) {
+			boot_policy = VERIFY_ENFORCE;
+		} else if (grub_strcmp(boot_policy_str, "warning") == 0) {
+			boot_policy = VERIFY_WARNING;
+		} else if (grub_strcmp(boot_policy_str, "none") == 0) {
+			boot_policy = VERIFY_NONE;
+		} else {
+			grub_printf("Unrecognized boot_policy=%s "
+			    "ignored.\n", boot_policy_str);
+		}
+	} else if (secure_boot_enabled) { /* Secure Boot default */
+		boot_policy = VERIFY_ENFORCE;
+		grub_dprintf(DBGLABEL,
+		    "Default SecureBoot boot_policy=enforce.\n");
+	} else { /* non-Secure Boot default */
+		boot_policy = VERIFY_EFI_DEFAULT;
+		grub_dprintf(DBGLABEL,
+		    "Non-SecureBoot default boot_policy=%d\n", boot_policy);
+	}
+
+	/* In Secure Boot mode, the boot_policy must be enforce. */
+	if (secure_boot_enabled) {
+		if (boot_policy != VERIFY_ENFORCE) {
+			boot_policy = VERIFY_ENFORCE;
+			grub_dprintf(DBGLABEL, "boot_policy overridden in "
+			    "Secure Boot mode to boot_policy=enforce.\n");
+		}
+	}
+
+	grub_dprintf(DBGLABEL, "SecureBoot %sabled, boot_policy=%s\n",
+	    secure_boot_enabled ? "en" : "dis",
+	    BOOT_POLICY_STRING(boot_policy));
+
+	return (boot_policy);
+}
+
+
+/* Convert a 128-bit GUID to a formatted hex string. */
+static const char *
+guid_str(const grub_guid_t *guid)
+{
+	static char	buf[40];
+
+	(void) grub_snprintf(buf, sizeof (buf),
+	    "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+	    guid->data1, guid->data2, guid->data3,
+	    guid->data4[0], guid->data4[1], guid->data4[2], guid->data4[3],
+	    guid->data4[4], guid->data4[5], guid->data4[6], guid->data4[7]);
+	return (buf);
+}
+
+
+/*
+ * Access the X.509 certificate in the db database.
+ * Return 0 if OK.
+ * Otherwise return non-zero for other errors.
+ */
+static int
+verify_get_certs(verified_boot_cert_t *certs, uint_t max_key_count,
+    uint_t *key_count)
+{
+	static const grub_guid_t	efi_security_db_guid =
+	    EFI_IMAGE_SECURITY_DATABASE_GUID;
+	static const grub_guid_t	x509_guid = EFI_X509_GUID;
+	static const grub_guid_t	rsa2048_guid = EFI_RSA2048_GUID;
+	static const grub_guid_t	pkcs7_guid = EFI_PKCS7_GUID;
+	static const grub_guid_t	cert_sha256_guid = EFI_CERT_SHA256_GUID;
+	static const grub_guid_t	microsoft_kek_ca_2011_guid =
+	    EFI_MICROSOFT_KEK_CA_2011_GUID;
+	grub_size_t		data_size = 0;
+	grub_ssize_t		remainder, cert_size;
+	uchar_t			*data, *key, *key_buf;
+	const char		*cert_type, *guid_strp;
+	efi_signature_list	*cert_list;
+	efi_signature_data	*cert;
+	grub_guid_t		guid;
+	int			rv, cert_index;
+	grub_efi_status_t	status;
+
+	grub_dprintf(DBGLABEL, "verify_get_certs() called\n");
+
+	status = grub_efi_get_variable(SIGNATURE_DATABASE, &efi_security_db_guid,
+	    &data_size, (void **)&data);
+	if (status == GRUB_EFI_SUCCESS) {
+		cert_list = (efi_signature_list *)data;
+	} else {
+		grub_dprintf(DBGLABEL, "no data in the db database\n");
+		return (1);
+	}
+
+	/* A UEFI signature db consists of zero or more signature lists. */
+	for (cert_list = (efi_signature_list *)data, remainder = data_size;
+	    remainder > 0;
+	    remainder -= cert_list->SignatureListSize,
+	    cert_list = (efi_signature_list *)((uchar_t *)cert_list +
+	    cert_list->SignatureListSize)) {
+
+		/* For Verified Boot, we're only interested in X.509 certs */
+		if (!GUIDS_EQUAL(&cert_list->SignatureType, &x509_guid)) {
+			if (GUIDS_EQUAL(&cert_list->SignatureType,
+			    &rsa2048_guid)) {
+				cert_type = "RSA-2048";
+			} else if (GUIDS_EQUAL(&cert_list->SignatureType,
+			    &pkcs7_guid)) {
+				cert_type = "PKCS-7";
+			} else if (GUIDS_EQUAL(&cert_list->SignatureType,
+			    &cert_sha256_guid)) {
+				cert_type = "SHA-256";
+			} else { /* unknown */
+				cert_type = guid_str(&cert_list->SignatureType);
+			}
+			grub_dprintf(DBGLABEL, "Skipping unsupported "
+			    "SignatureType %s.\n", cert_type);
+			continue;
+		}
+
+		/* Look at each cert in this signature list */
+		for (cert = (efi_signature_data *)((uchar_t *)cert_list +
+		    sizeof (efi_signature_list) +
+		    cert_list->SignatureHeaderSize);
+		    (uchar_t *)cert < ((uchar_t *)cert_list +
+		    cert_list->SignatureListSize);
+		    cert = (efi_signature_data *)((uchar_t *)cert +
+		    cert_list->SignatureSize)) {
+
+			guid = cert->SignatureOwner;
+			guid_strp = guid_str(&guid);
+			cert_size = cert_list->SignatureSize -
+			    sizeof (grub_guid_t);
+
+			if (cert_size <= MIN_DER_HEADER_LEN) { /* skip */
+				grub_dprintf(DBGLABEL,
+				    "Skipping undersized cert %s, size %ld\n",
+				    guid_strp, cert_size);
+				continue;
+			}
+
+			/* Filter-out certs irrelevant to Verified Boot */
+			if (GUIDS_EQUAL(&guid, &microsoft_kek_ca_2011_guid)) {
+				continue;
+			}
+
+			grub_dprintf(DBGLABEL, "cert %s, size %lu\n",
+			    guid_strp, cert_size);
+
+			/* Extract the public key from the X.509 cert */
+			rv = get_decoded_keys_from_image(
+			    &cert->SignatureData[0], cert_size,
+			    guid_strp, &key);
+			if (rv == 0) {
+				cert_index = *key_count;
+				grub_dprintf(DBGLABEL,
+				    "get_decoded_keys_from_image(%s), "
+				    "key %d, OK\n", guid_strp, cert_index);
+				if (cert_index < max_key_count) {
+					key_buf = certs[cert_index].key;
+					bcopy(key, key_buf,
+					    VERIFY_MODULUS_LEN);
+					vboot_free(key, VERIFY_MODULUS_LEN);
+					bzero(certs[cert_index].dn_hash,
+					    VERIFY_DN_HASH_LEN);
+#ifdef	VERBOSE_VBOOT_DEBUG
+					grub_dprintf(DBGLABEL,
+					    "key %d from file %s:\n",
+					    cert_index, cert_pathname);
+					vboot_hex_print(key_buf,
+					    VERIFY_MODULUS_LEN);
+#endif
+					++*key_count;
+				} else {
+					grub_printf("Key %d ignored; "
+					    "exceeded maximum of %u keys\n",
+					    cert_index, max_key_count);
+					goto ret;
+				}
+			} else {
+				grub_dprintf(DBGLABEL,
+				    "get_decoded_keys_from_image(%s) "
+				    "FAILED; rv=%d\n", guid_strp, rv);
+			}
+		}
+	}
+
+ret:
+	grub_dprintf(DBGLABEL, "verify_get_certs() returning; key_count=%u\n",
+	    *key_count);
+	grub_free(data);
+	return (0);
+}
+
+
+/*
+ * Get keys and policy information from X86 UEFI.
+ */
+int
+verify_get_settings_hv(verified_boot_cert_t *certs, uint_t max_key_count,
+    uint_t *key_count, verify_policy_t *policy)
+{
+	*policy = verify_get_boot_policy();
+
+	return (verify_get_certs(certs, max_key_count, key_count));
+}
+
+
+/*
+ * Verify an elfsign signature in an ELF file:
+ * Allocate memory for an ELF file and read the entire file into memory.
+ * Verify the elfsign signature in the file, if any.
+ * Free the file memory before returning.
+ * Called from multiboot_mbi2.c#grub_multiboot_load().
+ * Return 0 on success, non-zero on failure.
+ * Returning non-zero causes GRUB to go back to the GRUB boot menu.
+ */
+int
+efi_verify_module(grub_file_t file)
+{
+	grub_off_t		file_size;
+	grub_properly_aligned_t	*file_buffer;
+	grub_ssize_t		len_read;
+	grub_err_t		err;
+
+	file_size = grub_file_size(file);
+	if (file_size == GRUB_FILE_SIZE_UNKNOWN) {
+		grub_dprintf(DBGLABEL, "efi_verify_module: "
+		    "UNIX file size unknown\n");
+		return (GRUB_ERR_FILE_READ_ERROR);
+	}
+	grub_dprintf(DBGLABEL, "efi_verify_module: "
+	    "UNIX file size = 0x%lx\n", file_size);
+
+	file_buffer = grub_malloc(file_size);
+	if (file_buffer == NULL) {
+		grub_dprintf(DBGLABEL, "efi_verify_module: "
+		    "cannot allocate buffer for UNIX\n");
+		return (GRUB_ERR_OUT_OF_MEMORY);
+	}
+
+	if ((grub_file_seek(file, 0)) == (grub_off_t)-1) {
+		grub_dprintf(DBGLABEL, "efi_verify_module: "
+		    "cannot seek UNIX file to 0\n");
+		err = GRUB_ERR_FILE_READ_ERROR;
+		goto err_ret;
+	}
+
+	len_read = grub_file_read(file, file_buffer, file_size);
+	if (len_read < (grub_ssize_t)file_size) {
+		grub_dprintf(DBGLABEL, "efi_verify_module: "
+		    "short length 0x%lx read from file UNIX\n", len_read);
+		err = GRUB_ERR_FILE_READ_ERROR;
+		goto err_ret;
+	}
+
+	err = verify_module((uchar_t *)file_buffer);
+
+err_ret:
+	grub_free(file_buffer);
+	return (err);
+}
+
+static grub_err_t
+vboot_verifier_write (void *context __attribute__ ((unused)), void *buf, grub_size_t size)
+{
+        return (verify_module((uchar_t *) buf));
+}
+
+static grub_err_t
+vboot_verifier_init (grub_file_t io __attribute__ ((unused)),
+			 enum grub_file_type type,
+			 void **context __attribute__ ((unused)),
+			 enum grub_verify_flags *flags)
+{
+
+  switch (type & GRUB_FILE_TYPE_MASK)
+    {
+    /* We only verify the kernel */
+    case GRUB_FILE_TYPE_MULTIBOOT_KERNEL:
+      *flags = GRUB_VERIFY_FLAGS_SINGLE_CHUNK;
+      return GRUB_ERR_NONE;
+
+    /* Other files. */
+    default:
+      *flags = GRUB_VERIFY_FLAGS_SKIP_VERIFICATION;
+      return GRUB_ERR_NONE;
+    }
+}
+
+struct grub_file_verifier vboot_verifier =
+  {
+    .name = "vboot_verifier",
+    .init = vboot_verifier_init,
+    .write = vboot_verifier_write
+  };
+
+void
+grub_vboot_verifier_setup (void)
+{
+  grub_dprintf(DBGLABEL, "Registering vboot_verifier\n");
+
+  /* Enforce vboot_verifier. */
+  grub_verifier_register (&vboot_verifier);
+
+  grub_env_set ("vboot", "y");
+  grub_env_export ("vboot");
+}
+
+GRUB_MOD_INIT (verified_boot)
+{
+  grub_vboot_verifier_setup();
+}
+
+GRUB_MOD_FINI (verified_boot)
+{
+  grub_verifier_unregister (&vboot_verifier);
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/vboot/verify_elf.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/vboot/verify_elf.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,699 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2015, 2024, Oracle and/or its affiliates.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Verify the elfsign(1) signature for the initial Solaris unix module.
+ * Calculate the ELF digest and extract the ELF signature.
+ *
+ * No Kernel Zone-specific code should be in this file.
+ */
+
+#include <sys/types.h>
+#include <sys/stdbool.h>
+#define	ELF_TARGET_ALL		/* include both X86 and SPARC ELF specifics */
+#include <sys/elf.h>
+#include <sys/sha2.h>		/* SHA256_DIGEST_LENGTH, SHA512_DIGEST_LENGTH */
+#include <sys/note.h>
+
+#include <grub/misc.h>		/* grub_str*() and other useful utilities */
+#include <grub/mm.h>		/* grub_*alloc* and other memory management */
+#include <grub/crypto.h>	/* crypto and digest functions */
+
+#include <sys/verified_boot.h>		/* Verified Boot types */
+#include "verify.h"
+
+#ifndef	_ELF64
+#define	_ELF64			/* Required to define _elf64_sign_range() */
+#endif
+#include "elfsignrange/_elfsignrange.h"
+
+#define	EMPTY_SIGNATURE_SECTION_SIZE	8
+
+/* Get number of sections. For extended sections, get from shdr[0].sh_size. */
+#define	GET_SHNUM(ehdrp, shdrp) \
+	((ehdrp)->e_shstrndx != SHN_XINDEX ? (ehdrp)->e_shnum : \
+	(shdrp)[0].sh_size)
+/* Get string table section. For extended sections, get from shdr[0].sh_link. */
+#define	GET_SHSTRNDX(ehdrp, shdrp) \
+	((ehdrp)->e_shstrndx != SHN_XINDEX ? (ehdrp)->e_shstrndx : \
+	(shdrp)[0].sh_link)
+
+/* Return a pointer to a byte offset into the ELF file */
+#define	ELF_GET_PTR(base, off)		(void *)((uchar_t *)(base) + (off))
+
+/* Unknown size, so use a generous maximum */
+#define	MAX_KERNEL_MODULE	0x10000000
+
+/*
+ * Use this to pass parameters to elfsignrange callback functions.
+ * In the future when multiple digest algorithms are supported, that
+ * will have to be added to this callback function too.
+ */
+typedef struct {
+	uchar_t		*elf_file;
+	size_t		cur_size;
+	size_t		sig_offset;
+	size_t		sig_size;
+	SHA2_CTX	ctx;
+} elf_callback_data_t;
+
+/*
+ * Print the filename and elfsign hash string for a module (for debugging).
+ * Called by verify_hash_legacy().
+ */
+#ifdef	VERBOSE_VBOOT_DEBUG
+static void
+verify_print_es_hash(const char *function, const uchar_t *hash, size_t hash_len)
+{
+	char	digest_string[SHA256_DIGEST_LENGTH * 2 + 1];
+	int	i;
+
+	if (hash_len > SHA256_DIGEST_LENGTH) {
+		hash_len = SHA256_DIGEST_LENGTH;
+	}
+
+	/* Convert hex digits to ASCII characters */
+	for (i = 0; i < hash_len; ++i) {
+		grub_snprintf(digest_string + i * 2, 3, "%02x",
+		    hash[i]);
+	}
+	digest_string[i * 2] = '\0';
+
+	/* Print message */
+	grub_dprintf(DBGLABEL, "%s: hash = %s\n", function, digest_string);
+}
+#endif
+
+
+/* Print binary data in hexadecimal (for debugging) */
+void
+vboot_hex_print(const void *data, size_t length)
+{
+#define	BYTES_PER_LINE	32
+	int		i, j;
+	char		linebuf[81];
+	int		line_limit, remaining;
+
+	for (i = 0; i < length; i += line_limit) {
+		remaining = length - i;
+		line_limit = (remaining > BYTES_PER_LINE) ?
+		    BYTES_PER_LINE : remaining;
+
+		for (j = 0; j < line_limit; ++j) {
+			(void) grub_snprintf(linebuf + j * 2, 3, "%02x",
+			    ((unsigned char *)data)[i + j]);
+		}
+		linebuf[j * 2] = '\0';
+		grub_dprintf(DBGLABEL, "  %s\n", linebuf);
+	}
+}
+
+/* Print ASCII characters in binary data (otherwise ".") (for debugging) */
+void
+vboot_char_print(const void *data, size_t length)
+{
+#define	CHARS_PER_LINE	64
+	int	i, j;
+	char	linebuf[81];
+	int	line_limit, remaining;
+
+	for (i = 0; i < length; i += line_limit) {
+		remaining = length - i;
+		line_limit = (remaining > CHARS_PER_LINE) ?
+		    CHARS_PER_LINE : remaining;
+
+		for (j = 0; j < line_limit; ++j) {
+			char	dbyte = ((char *)data)[i + j];
+			linebuf[j] = grub_isprint(dbyte) ? dbyte : '.';
+		}
+		linebuf[j] = '\0';
+		grub_dprintf(DBGLABEL, "  %s\n", linebuf);
+	}
+}
+
+/*
+ * Sanity self-test for SHA-256.
+ * Return 0 for pass, non-zero for fail.
+ *
+ * SHA Test data from NIST Cryptographic Algorithm Validation Program (CAVP).
+ * Test vector "SHA256ShortMsg.rsp Len = 512" downloaded from
+ * http://csrc.nist.gov/groups/STM/cavp/documents/shs/shabytetestvectors.zip
+ */
+static int
+verify_signature_self_test_sha256(void)
+{
+	/* Divide data arbitrarily to test two SHA256Update operations: */
+	static const uchar_t sha256_testdata1[53] = {0x5a, 0x86, 0xb7, 0x37,
+	    0xea, 0xea, 0x8e, 0xe9, 0x76, 0xa0, 0xa2, 0x4d, 0xa6, 0x3e, 0x7e,
+	    0xd7, 0xee, 0xfa, 0xd1, 0x8a, 0x10, 0x1c, 0x12, 0x11, 0xe2, 0xb3,
+	    0x65, 0x0c, 0x51, 0x87, 0xc2, 0xa8, 0xa6, 0x50, 0x54, 0x72, 0x08,
+	    0x25, 0x1f, 0x6d, 0x42, 0x37, 0xe6, 0x61, 0xc7, 0xbf, 0x4c, 0x77,
+	    0xf3, 0x35, 0x39, 0x03, 0x94};
+	static const uchar_t sha256_testdata2[11] = {
+	    0xc3, 0x7f, 0xa1, 0xa9, 0xf9, 0xbe, 0x83, 0x6a, 0xc2, 0x85, 0x09};
+	static const uchar_t sha256_digest[SHA256_DIGEST_LENGTH] = {
+	    0x42, 0xe6, 0x1e, 0x17, 0x4f, 0xbb, 0x38, 0x97, 0xd6, 0xdd, 0x6c,
+	    0xef, 0x3d, 0xd2, 0x80, 0x2f, 0xe6, 0x7b, 0x33, 0x19, 0x53, 0xb0,
+	    0x61, 0x14, 0xa6, 0x5c, 0x77, 0x28, 0x59, 0xdf, 0xc1, 0xaa};
+
+	grub_uint8_t	sha256_ctx[GRUB_MD_SHA256->contextsize];
+	uchar_t		digest[SHA256_DIGEST_LENGTH];
+	int		r;
+
+	/* Test SHA-256 */
+	GRUB_MD_SHA256->init(sha256_ctx);
+	GRUB_MD_SHA256->write(sha256_ctx, sha256_testdata1,
+	    sizeof (sha256_testdata1));
+	GRUB_MD_SHA256->write(sha256_ctx, sha256_testdata2,
+	    sizeof (sha256_testdata2));
+	GRUB_MD_SHA256->final(sha256_ctx);
+	grub_memcpy(digest, GRUB_MD_SHA256->read(sha256_ctx),
+	    GRUB_MD_SHA256->mdlen);
+
+#ifdef	VERBOSE_VBOOT_DEBUG
+	verify_print_es_hash("verify_signature_self_test_sha256", digest,
+	    GRUB_MD_SHA256->mdlen);
+#endif
+
+	r = grub_memcmp(digest, sha256_digest, SHA256_DIGEST_LENGTH);
+	if (r != 0) {
+		grub_dprintf(DBGLABEL,
+		    "verify_signature_self_test_sha256 failed\n");
+	}
+
+	return (r);
+}
+
+
+/*
+ * Detect overlap between data offset and length and the signature section
+ * offset and length.
+ * Return 0 if OK (no overlap).
+ * Return 1 if there's overlap, along with information about the
+ * non-overlapping parts, if any.
+ */
+static int
+verify_detect_overlap(size_t data_off, size_t data_len, size_t sig_off,
+    size_t sig_len, size_t *prefix_off, size_t *prefix_len,
+    size_t *postfix_off, size_t *postfix_len)
+{
+	size_t	data_end = data_off + data_len - 1;
+	size_t	sig_end = sig_off + sig_len - 1;
+
+	*prefix_off = *prefix_len = *postfix_off = *postfix_len = 0;
+
+	if (data_off == 0 || data_len == 0 || sig_off == 0 ||
+	    sig_len <= EMPTY_SIGNATURE_SECTION_SIZE ||
+	    sig_len > SIG_MAX_LENGTH) {
+		return (0); /* no valid signature or not enough information */
+	} else if ((data_end < sig_off) || (data_off > sig_end)) {
+		return (0); /* no overlap! */
+	}
+
+	/* Now that we know we have overlap, specify the overlap regions */
+	grub_dprintf(DBGLABEL, "verify_detect_overlap: detected overlap with "
+	    "signature section at offset=%#zx, length=%#zx, end=%#zx",
+	    sig_off, sig_len, sig_end);
+	if ((data_off == sig_off) && (data_len == sig_len)) {
+		grub_dprintf(DBGLABEL, "verify_detect_overlap: "
+		    "exact overlap with signature section detected");
+	} else {
+		if (data_end >= sig_off) {
+			grub_dprintf(DBGLABEL, "verify_detect_overlap: "
+			    "data end >= sign begin");
+		}
+		if (data_off <= sig_end) {
+			grub_dprintf(DBGLABEL, "verify_detect_overlap: "
+			    "data begin <= sign end");
+		}
+	}
+
+	/* Calculate non-overlapping regions, if any */
+	if (data_off < sig_off) {
+		*prefix_off = data_off;
+		*prefix_len = sig_off - data_off;
+		grub_dprintf(DBGLABEL, "verify_detect_overlap: "
+		    "prefix %#zx, len %#zx, end %#zx",
+		    *prefix_off,  *prefix_len,
+		    *prefix_off + *prefix_len - 1);
+	}
+	if (data_end > sig_end) {
+		*postfix_off = sig_end + 1;
+		*postfix_len = data_end - sig_end;
+		grub_dprintf(DBGLABEL, "verify_detect_overlap: "
+		    "postfix %#zx, len %#zx, end %#zx",
+		    *postfix_off, *postfix_len,
+		    *postfix_off + *postfix_len - 1);
+	}
+
+	return (1);
+}
+
+
+/*
+ * Callback function for elfsignrange() for accumulating the digest.
+ * Pass parameters via the opaque elf_callback_data_t pointer, udata.
+ *
+ * To handle corrupt/incorrect ELF files, we exclude data that overlaps the
+ * signature section region of the file, if any.
+ */
+static void
+verify_digest_callback(size_t src_off, size_t size, void *udata)
+{
+	elf_callback_data_t	*cb_data = (elf_callback_data_t *)udata;
+	size_t			prefix_off = 0;
+	size_t			prefix_len = 0;
+	size_t			postfix_off = 0;
+	size_t			postfix_len = 0;
+
+	grub_dprintf(DBGLABEL, "vboot_digest_callback"
+	    "(src_off 0x%lx, size 0x%lx, end 0x%lx, udata %p)\n",
+	    (unsigned long)src_off, (unsigned long)size,
+	    (unsigned long)src_off + size - 1, udata);
+	if (size == 0) {
+		return; /* nothing to do */
+	}
+
+	if (verify_detect_overlap(src_off, size, cb_data->sig_offset,
+	    cb_data->sig_size, &prefix_off, &prefix_len,
+	    &postfix_off, &postfix_len) != 0) {
+		/* Handle parts that are not overlapping, if any */
+		if (prefix_len != 0) {
+			grub_dprintf(DBGLABEL, "verify_digest_callback: "
+			    "processing non-overlapping part before signature");
+			verify_digest_callback(prefix_off, prefix_len, udata);
+		}
+		if (postfix_len != 0) {
+			grub_dprintf(DBGLABEL, "verify_digest_callback: "
+			    "processing non-overlapping part after signature");
+			verify_digest_callback(postfix_off, postfix_len,
+			    udata);
+		}
+
+	} else {
+		GRUB_MD_SHA256->write(&cb_data->ctx,
+		    ELF_GET_PTR(cb_data->elf_file, src_off), size);
+		cb_data->cur_size += size;
+	}
+}
+
+
+/*
+ * Calculate the elfsign hash of the ELF sections using elfsignrange.
+ * Return 0 on success, else non-zero.
+ */
+static int
+verify_hash_elfsignrange(filesig_vers_t filesig_version, const Elf64_Ehdr *hdr,
+    const Elf64_Shdr *shdrs, const Elf64_Phdr *phdrs, const uchar_t *elf_file,
+    uchar_t *hash, size_t sig_offset, size_t sig_len)
+{
+	Elf_Signrange		range_type;
+	elf_callback_data_t	cb_data = {NULL, 0, 0, 0, {0}};
+	int			ret = 0;
+
+	/* Convert elfsign version to elfsignrange range type */
+	switch (filesig_version) {
+	case FILESIG_VERSION7_INTERPRET:
+		range_type = ELF_SR_INTERPRET;
+		break;
+	case FILESIG_VERSION9_RELOBJ:
+		range_type = ELF_SR_RELOBJ;
+		break;
+	default:
+		grub_dprintf(DBGLABEL, "verify_hash_elfsignrange: "
+		    "unsupported version %u\n", filesig_version);
+		return (-1);
+	}
+
+	/*
+	 * Calculate hash using elfsignrange callbacks that determine
+	 * what regions are hashed.
+	 */
+	grub_memset(&cb_data.ctx, 0, sizeof (&cb_data.ctx));
+	GRUB_MD_SHA256->init(&cb_data.ctx);
+	cb_data.elf_file = (uchar_t *)elf_file;
+	cb_data.sig_offset = sig_offset;
+	cb_data.sig_size = sig_len;
+
+	grub_dprintf(DBGLABEL, "verify_hash_elfsignrange: "
+	    "calling _elf64_sign_range(%srange %u)\n",
+	    ((phdrs != NULL) ? "phdrs, " : ""), range_type);
+
+	if (_elf64_sign_range(verify_digest_callback, (Elf64_Ehdr *)hdr,
+	    (Elf64_Phdr *)phdrs, (Elf64_Shdr *)shdrs, MAX_KERNEL_MODULE,
+	    range_type, &cb_data) == 0) {
+		grub_dprintf(DBGLABEL, "verify_hash_elfsignrange: "
+		    "_elf64_sign_range(range %u) failed\n", range_type);
+		ret = -1;
+	}
+
+	GRUB_MD_SHA256->final(&cb_data.ctx);
+	grub_memcpy(hash, GRUB_MD_SHA256->read(&cb_data.ctx),
+	    GRUB_MD_SHA256->mdlen);
+
+	/* Cleanup */
+	grub_dprintf(DBGLABEL, "verify_hash_elfsignrange:  hash value is\n");
+	vboot_hex_print(hash, SHA256_DIGEST_LENGTH);
+
+	grub_memset(&cb_data.ctx, 0, sizeof (&cb_data.ctx));
+
+	/* Sanity check */
+	if (cb_data.cur_size == 0) {
+		grub_dprintf(DBGLABEL, "verify_hash_elfsign_range: "
+		    "No data parsed by gelf_sign_range()\n");
+	}
+	grub_dprintf(DBGLABEL, "verify_hash_elfsignrange: "
+	    "processed %lu bytes\n", cb_data.cur_size);
+	return (ret);
+}
+
+
+/*
+ * Calculate the elfsign hash of ELF sections using the legacy range algorithm.
+ * Only elfsign version 5 (SHA-256) is supported here.
+ * Called by verify_module_signature().
+ */
+static void
+verify_hash_legacy(filesig_vers_t filesig_version, const Elf64_Ehdr *hdr,
+    uchar_t *hash, const char *shstrtab, const uchar_t *elf_file)
+{
+#ifndef VERBOSE_VBOOT_DEBUG
+	_NOTE(ARGUNUSED(shstrtab));
+#endif
+	size_t		shn, shnum;
+	Elf64_Shdr	*shdrs = (Elf64_Shdr *)(ELF_GET_PTR(elf_file,
+	    hdr->e_shoff));
+	Elf64_Shdr	*shp;
+	grub_uint8_t	sha256_ctx[GRUB_MD_SHA256->contextsize];
+
+	if (filesig_version != FILESIG_VERSION5) {
+		grub_dprintf(DBGLABEL, "elfsign signature version %u "
+		    "is not supported.\n", filesig_version);
+		return;
+	}
+
+	/* Initialize digest computation */
+	grub_memset(sha256_ctx, 0, sizeof (sha256_ctx));
+	GRUB_MD_SHA256->init(sha256_ctx);
+
+	/*
+	 * Examine each ELF section header.
+	 * Skip section 0 which is required to be empty.
+	 */
+	shnum = GET_SHNUM(hdr, shdrs);
+	for (shn = 1; shn < shnum; ++shn) {
+		shp = (Elf64_Shdr *)((char *)shdrs + (shn * hdr->e_shentsize));
+
+		/* Skip empty, SHT_NOBITS, and SHT_SUNW_SIGNATURE sections */
+		if ((shp->sh_size == 0) || (shp->sh_type == SHT_NOBITS) ||
+		    (shp->sh_type == SHT_SUNW_SIGNATURE)) {
+#ifdef	VERBOSE_VBOOT_DEBUG
+			grub_dprintf(DBGLABEL,
+			    "verify_hash_legacy: skipping section %s\n",
+			    shstrtab + shp->sh_name);
+#endif
+			continue;
+		}
+
+#ifdef	VERBOSE_VBOOT_DEBUG
+		grub_dprintf(DBGLABEL, "verify_hash_legacy: Section %d: ", shn);
+		grub_dprintf(DBGLABEL, "type %u, ", shp->sh_type);
+		grub_dprintf(DBGLABEL, "addr %lx, ", shp->sh_addr);
+		grub_dprintf(DBGLABEL, "size 0x%lx, ", shp->sh_size);
+		grub_dprintf(DBGLABEL, "name %s\n", shstrtab + shp->sh_name);
+#endif
+
+		GRUB_MD_SHA256->write(sha256_ctx,
+		    ELF_GET_PTR(elf_file, shp->sh_offset), shp->sh_size);
+	}
+
+	GRUB_MD_SHA256->final(sha256_ctx);
+	grub_memcpy(hash, GRUB_MD_SHA256->read(sha256_ctx),
+	    GRUB_MD_SHA256->mdlen);
+
+#ifdef	VERBOSE_VBOOT_DEBUG
+	verify_print_es_hash("verify_hash_legacy", hash,
+	    GRUB_MD_SHA256->mdlen);
+#endif
+}
+
+
+/* Calculate the SHA-256 hash of some data, specifically the DN */
+static void
+verify_hash_dn(uchar_t *dn_hash, uchar_t *dn, size_t dn_len)
+{
+	grub_uint8_t    sha256_ctx[GRUB_MD_SHA256->contextsize];
+
+	GRUB_MD_SHA256->init(sha256_ctx);
+	GRUB_MD_SHA256->write(sha256_ctx, dn, dn_len);
+	GRUB_MD_SHA256->final(sha256_ctx);
+	grub_memcpy(dn_hash, GRUB_MD_SHA256->read(sha256_ctx),
+	    VERIFY_DN_HASH_LEN);
+}
+
+/*
+ * Verify the that the module matches the signature in the
+ * .SUNW_SIGNATURE section for the module, if it exists.
+ *
+ * Return 0 if verified, non-0 if not verified.
+ *
+ * Called by verify_module().
+ */
+int
+verify_module_signature(const uchar_t *elf_file,
+    verified_boot_cert_t *certs, uint_t num_keys)
+{
+	Elf64_Ehdr		hdr;
+	Elf64_Shdr		*shdrs, *shp;
+	Elf64_Phdr		*phdrs = NULL;
+	union {
+		char			cdata[SIG_MAX_LENGTH];
+		filesignatures_t	filesig;
+	} *buf = NULL;
+	size_t			shstrlen, phdrslen;
+	char			*shstrtab = NULL;
+	uint_t			signature_count = 0; /* should end up == 1 */
+	size_t			sig_offset, sig_size_only;
+	filesig_vers_t		filesig_version;
+	size_t			shn, shnum, shstrndx;
+	uchar_t			*dn = NULL;
+	uchar_t			*sig = NULL;
+	char			*sig_oid = NULL;
+	size_t			dn_len, sig_len, sig_oid_len;
+	uchar_t			dn_hash[VERIFY_DN_HASH_LEN];
+	uchar_t			elf_hash[SHA256_DIGEST_LENGTH] = {0};
+	int			r, ret;
+	static bool		first_time = true;
+
+	if (first_time) {
+		/* Perform one-time self tests */
+		if (verify_signature_self_test_sha256() != 0) {
+			grub_dprintf(DBGLABEL, "Error: "
+			    "Failed verify_signature_self_test_sha256.\n");
+			return (1);
+		}
+		first_time = false;
+	}
+
+	/* Get ELF header */
+	grub_memcpy(&hdr, ELF_GET_PTR(elf_file, 0), sizeof (hdr));
+
+	/* ELF file format sanity checks */
+	VERIFY_SANITY_CHECK_ELF_HDR(VBOOT_DEBUG, &hdr, MAX_KERNEL_MODULE, r);
+	if (r != 0) {
+		VERIFY_SANITY_UNIX_WANBOOT_ELF_HDR(VBOOT_DEBUG, &hdr, r);
+	}
+	if (r != 0) {
+		return (2);
+	}
+
+	/* Get ELF section header */
+	shdrs = (Elf64_Shdr *)ELF_GET_PTR(elf_file, hdr.e_shoff);
+	shnum = GET_SHNUM(&hdr, shdrs);
+	shstrndx = GET_SHSTRNDX(&hdr, shdrs);
+
+	/* Get ELF section table length and pointer */
+	shp = (Elf64_Shdr *)((char *)shdrs + shstrndx * hdr.e_shentsize);
+	shstrlen = shp->sh_size;
+
+	shstrtab = (char *)ELF_GET_PTR(elf_file, shp->sh_offset);
+
+	/* Get ELF Program header (if any) */
+	phdrslen = (size_t)hdr.e_phnum * hdr.e_phentsize;
+	if (phdrslen > 0) {
+		phdrs = (Elf64_Phdr *)ELF_GET_PTR(elf_file, hdr.e_phoff);
+		grub_dprintf(DBGLABEL, "Phdr found; length %lu",
+		    (long unsigned)phdrslen);
+	}
+
+	/*
+	 * Search the ELF section table for the SUNW_SIGNATURE section.
+	 * Skip section 0 which is required to be empty.
+	 */
+	for (shn = 1; shn < shnum; ++shn) {
+		shp = (Elf64_Shdr *)((char *)shdrs + (shn * hdr.e_shentsize));
+
+		if (shp->sh_type != SHT_SUNW_SIGNATURE)
+			continue;
+
+		if ((shp->sh_flags & SHF_ALLOC) != 0) {
+			grub_dprintf(DBGLABEL, "verify_module_signature: "
+			    "Error: memory-resident signature section %lu\n",
+			    shn);
+			ret = 3;
+			goto cleanup;
+		}
+
+		if ((shp->sh_size != 0) &&
+		    (shp->sh_name < shstrlen) &&
+		    (grub_strncmp(shstrtab + shp->sh_name,
+		    ELF_SIGNATURE_SECTION,
+		    sizeof (ELF_SIGNATURE_SECTION)) == 0) &&
+		    ((shp->sh_flags & SHF_SUNW_ABSENT) == 0)) {
+			/* hit!--signature found */
+			++signature_count;
+			break;
+		}
+	}
+
+	if (signature_count == 0) {
+		grub_dprintf(DBGLABEL, "verify_module_signature: Error: "
+		    "kernel module is not signed with elfsign(1)\n");
+		ret = 4;
+		goto cleanup;
+	} else if (signature_count != 1) {
+		grub_dprintf(DBGLABEL, "verify_module_signature: Error: "
+		    "kernel module has multiple ELF signature sections\n");
+		ret = 5;
+		goto cleanup;
+	}
+
+	/* Sanity check signature section size and allocate memory for it. */
+	sig_size_only = shp->sh_size;
+	sig_offset = shp->sh_offset;
+	if ((sig_size_only > SIG_MAX_LENGTH) || (sig_size_only == 0)) {
+		grub_dprintf(DBGLABEL, "verify_module_signature: Error: "
+		    ".SUNW_SIGNATURE length error %lu\n",
+		    (long unsigned)sig_size_only);
+		ret = 6;
+		goto cleanup;
+	}
+
+	buf = grub_malloc(sig_size_only);
+
+	/* Copy elfsign signature section to an aligned buffer */
+	grub_memcpy(buf->cdata, ELF_GET_PTR(elf_file, sig_offset),
+	    sig_size_only);
+
+	/*
+	 * Extract information from .SUNW_SIGNATURE section.
+	 */
+	filesig_version = buf->filesig.filesig_sig.filesig_version;
+
+#ifdef VERBOSE_VBOOT_DEBUG
+	/* Print information from .SUNW_SIGNATURE section. */
+	grub_dprintf(DBGLABEL, "verify_module_signature: "
+	    "filesig_version is 0x%x\n", filesig_version);
+	grub_dprintf(DBGLABEL, "verify_module_signature: Dumping "
+	    "SHT_SUNW_SIGNATURE section (length %ld):\n", sig_size_only);
+	vboot_hex_print(buf->cdata, sig_size_only);
+	vboot_char_print(buf->cdata, sig_size_only);
+#endif
+
+	/*
+	 * Check elfsign version.
+	 * Elfsign versions 1-4, 6 are not supported for Solaris Verified Boot.
+	 * Version 5 works with Solaris Verified Boot back to S11.2.
+	 */
+	switch (filesig_version) {
+	case FILESIG_VERSION5:
+	case FILESIG_VERSION7_INTERPRET:
+	case FILESIG_VERSION9_RELOBJ:
+		break;
+	default:
+		grub_dprintf(DBGLABEL, "verify_module_signature: Error: "
+		    "elfsign signature version %u not supported;",
+		    filesig_version);
+		ret = 7;
+		goto cleanup;
+	}
+
+	/*
+	 * Extract DN, signature, OID, & lengths from .SUNW_SIGNATURE section.
+	 */
+	dn_len = buf->filesig.filesig_sig.filesig_v3_dnsize;
+	dn = (uchar_t *)&buf->filesig.filesig_sig.filesig_v3_data[0];
+	sig_len = buf->filesig.filesig_sig.filesig_v3_sigsize;
+	sig = (uchar_t *)&buf->filesig.filesig_sig.filesig_v3_data[dn_len];
+	sig_oid_len = buf->filesig.filesig_sig.filesig_v3_oidsize;
+	sig_oid = (char *)&buf->filesig.filesig_sig.filesig_v3_data[
+	    dn_len + sig_len];
+
+	/* Sanity check signature block */
+	VERIFY_SANITY_CHECK_SIGNATURE_SECTION(VBOOT_DEBUG, sig_offset, sig,
+	    sig_len, dn, dn_len, sig_oid, sig_oid_len, MAX_KERNEL_MODULE, r);
+	if (r != 0) {
+		ret = 8;
+		goto cleanup;
+	}
+
+	/* Check hash algorithm OID */
+	if (grub_strncmp(sig_oid, OID_SHA256WITHRSAENCRYPTION, sig_oid_len)
+	    != 0) {
+		grub_dprintf(DBGLABEL, "verify_module_signature: unexpected "
+		    "OID %s; expected %s for elfsign signature version %u\n",
+		    sig_oid, OID_SHA256WITHRSAENCRYPTION, filesig_version);
+		ret = 11;
+		goto cleanup;
+	}
+
+	verify_hash_dn(dn_hash, dn, dn_len);
+
+	/*
+	 * Calculate elfsign hash.
+	 */
+	if (filesig_version >= ELFSIGN_RANGE_BASE) {
+		if (verify_hash_elfsignrange(filesig_version, &hdr,
+		    shdrs, phdrs, elf_file, elf_hash,
+		    sig_offset, sig_size_only) != 0) {
+			ret = 12;
+			goto cleanup;
+		}
+	} else {
+		verify_hash_legacy(filesig_version, &hdr, elf_hash, shstrtab,
+		    elf_file);
+	}
+
+	/*
+	 * Now that we have the elfsign hash, signature, and keys,
+	 * verify the hash against the signature using one or more public keys.
+	 */
+	if (verify_signature_against_keys(certs, num_keys, sig, sig_len,
+	    dn_hash, elf_hash, sizeof (elf_hash)) != 0) {
+		ret = 13;
+		goto cleanup;
+	}
+
+	ret = 0; /* success */
+
+cleanup:
+	if (buf != NULL)
+		grub_free(buf);
+
+	return (ret);
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/vboot/verify_rsa.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/vboot/verify_rsa.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,374 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2015, 2024, Oracle and/or its affiliates.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Verify elfsign RSA-2048 signature using libgcrypt MPI
+ * (arbitrary precision or "bignum") functions.
+ * The actual SHA-256 digest used here is computed beforehand.
+ *
+ * Libgcrypt MPI documentation:
+ * http://www.gnupg.org/documentation/manuals/gcrypt/MPI-library.html
+ */
+
+#include <sys/types.h>
+#include <sys/stdbool.h>
+#include <gcrypt.h>		/* gcry_mpi_* */
+#include <sys/verified_boot.h>	/* VERIFY_MODULUS_LEN */
+#include "verify.h"
+#include <grub/misc.h>		/* grub_str*() and other useful utilities */
+
+#define	MIN_PKCS1_PADLEN	11
+
+/*
+ * RSA-2048 public key modulus for testing.
+ * The modulus "n" must match the "n" in the private key.
+ */
+static const unsigned char raw_test_modulus[] = {
+	0xc3, 0xa1, 0xab, 0x2c, 0x88, 0x01, 0x48, 0x4f,
+	0x62, 0x4a, 0x35, 0x8e, 0x3d, 0x95, 0x32, 0xe4,
+	0x7a, 0x48, 0x68, 0x66, 0xb8, 0x92, 0x01, 0x9d,
+	0xe7, 0x25, 0xd8, 0x75, 0xbb, 0xe3, 0x60, 0xa0,
+	0xd0, 0x06, 0x2d, 0xbd, 0x98, 0xc9, 0x8b, 0xd2,
+	0x69, 0x04, 0xc0, 0x28, 0x1f, 0x2f, 0xd0, 0xd6,
+	0x47, 0x71, 0x82, 0x78, 0x62, 0x35, 0x1e, 0xa8,
+	0x9d, 0xb4, 0x7c, 0x66, 0x05, 0x25, 0x77, 0xf2,
+	0x9b, 0x7b, 0xaf, 0x8d, 0xfa, 0x5d, 0x34, 0xee,
+	0xec, 0xb4, 0xc4, 0xb2, 0xb1, 0x76, 0x35, 0xf9,
+	0x47, 0xdd, 0xd1, 0xc0, 0xb9, 0xb3, 0xd6, 0x70,
+	0xaf, 0x0c, 0x48, 0x9f, 0x7c, 0xce, 0xb5, 0x04,
+	0xf3, 0x73, 0xdc, 0x2c, 0x26, 0x47, 0xd9, 0x46,
+	0x28, 0x52, 0xff, 0x70, 0x08, 0x03, 0x4e, 0xa6,
+	0x72, 0x62, 0x53, 0xfe, 0x87, 0x8e, 0x44, 0x86,
+	0x73, 0xb6, 0x5d, 0xe7, 0xf8, 0xea, 0xf8, 0x1f,
+	0x46, 0xb6, 0x5b, 0xcb, 0x90, 0x74, 0x62, 0xf4,
+	0xad, 0xf6, 0x24, 0xe8, 0xa9, 0x2f, 0x53, 0xd0,
+	0x09, 0x43, 0x41, 0x9a, 0x5b, 0xf1, 0xcf, 0xb4,
+	0x0c, 0x54, 0x16, 0xda, 0x66, 0x53, 0xa9, 0x48,
+	0x69, 0xa8, 0xe5, 0x15, 0x08, 0x89, 0xc9, 0xbc,
+	0x2e, 0x82, 0xdb, 0x87, 0x29, 0x98, 0x60, 0x34,
+	0x59, 0xda, 0x34, 0xf8, 0x26, 0x1e, 0xa8, 0x4a,
+	0x49, 0xa0, 0xe3, 0xa2, 0xeb, 0x37, 0x63, 0xfe,
+	0x2c, 0x21, 0x9d, 0x9c, 0x1f, 0xac, 0x45, 0xba,
+	0x0e, 0x4c, 0x59, 0xb3, 0xb5, 0xed, 0xc4, 0xcf,
+	0xd6, 0xf7, 0xa8, 0x93, 0xd2, 0x8c, 0xac, 0x8f,
+	0xbd, 0xb9, 0x80, 0xef, 0x17, 0x26, 0x0a, 0xe0,
+	0x68, 0xb0, 0xd4, 0x18, 0x2b, 0x86, 0xf2, 0x8b,
+	0xa6, 0xf7, 0x1b, 0xa7, 0xa0, 0x4f, 0xb5, 0xad,
+	0x1b, 0xcc, 0x3a, 0x4b, 0x5d, 0xf7, 0x82, 0xf4,
+	0xf1, 0xb2, 0xa5, 0x18, 0x03, 0xdf, 0x4b, 0x0d};
+
+static const unsigned char hash_unpadded_test_data[] = {
+	0xd1, 0x2d, 0xf9, 0x27, 0xc9, 0x6b, 0xdd, 0x47,
+	0xb8, 0xc0, 0x30, 0x78, 0xfd, 0xe6, 0x6f, 0x8b,
+	0x6c, 0xfa, 0x5b, 0x62, 0xd7, 0xb2, 0xc9, 0x51,
+	0x2c, 0x48, 0x94, 0xa3, 0x93, 0x36, 0xcb, 0x79};
+
+/* Test signature for the above key and data */
+static const unsigned char raw_test_signature[] = {
+	0xae, 0x42, 0xc8, 0xf7, 0x57, 0xb4, 0x73, 0xe6,
+	0xef, 0x11, 0x32, 0x0e, 0xc3, 0xb5, 0x36, 0x9a,
+	0xb0, 0x25, 0x7e, 0xfd, 0x71, 0xa0, 0x49, 0x4b,
+	0x09, 0x5d, 0xee, 0x95, 0x49, 0xd7, 0xc0, 0x48,
+	0x5f, 0x9a, 0x52, 0x70, 0x30, 0xa9, 0x48, 0xbf,
+	0xae, 0x3c, 0x07, 0xc4, 0xdd, 0x7e, 0xa0, 0x43,
+	0xac, 0x54, 0xf7, 0x5b, 0x21, 0x5d, 0xc4, 0xe2,
+	0x5d, 0xf6, 0xca, 0xd3, 0xbe, 0x20, 0xac, 0xda,
+	0xb4, 0xec, 0xd6, 0x04, 0x9f, 0x02, 0x37, 0xcc,
+	0x37, 0x29, 0x34, 0xb9, 0x37, 0x39, 0x4a, 0xa9,
+	0xe1, 0xfd, 0xfe, 0xfc, 0x60, 0x84, 0x1e, 0x17,
+	0x5d, 0x54, 0xf4, 0x24, 0xb7, 0xcf, 0x6f, 0x99,
+	0xff, 0xfa, 0xfb, 0xb3, 0x0a, 0x43, 0xab, 0x12,
+	0x24, 0x90, 0x3e, 0xde, 0xfb, 0xed, 0x37, 0xa1,
+	0x03, 0x1a, 0x41, 0xf9, 0x2f, 0xc4, 0x85, 0x28,
+	0xb2, 0x62, 0x0e, 0x94, 0xb6, 0xf6, 0xda, 0x22,
+	0x32, 0xce, 0xbc, 0x4d, 0x76, 0xc7, 0x0c, 0x68,
+	0x11, 0xf0, 0xd9, 0x91, 0x14, 0x02, 0x76, 0xde,
+	0x9f, 0x6f, 0x9e, 0xb8, 0x04, 0x9e, 0x40, 0x4b,
+	0xfa, 0xed, 0x05, 0x0b, 0x1e, 0x94, 0x27, 0xe9,
+	0xd3, 0x9e, 0x1c, 0x72, 0x22, 0x8c, 0x36, 0x9e,
+	0x70, 0xe5, 0x13, 0x28, 0x17, 0x4a, 0xb5, 0x83,
+	0xfc, 0x50, 0x58, 0xb4, 0x8c, 0xba, 0x67, 0x97,
+	0xd2, 0x2f, 0x51, 0x0e, 0x5a, 0xbb, 0xf0, 0xea,
+	0x6e, 0xc0, 0xee, 0x15, 0xb6, 0x4a, 0x28, 0x5f,
+	0x75, 0x6f, 0xaa, 0xec, 0x80, 0xba, 0x08, 0xf8,
+	0xde, 0x2c, 0x8a, 0xff, 0x51, 0x28, 0xe3, 0xac,
+	0x27, 0xaa, 0xa6, 0xce, 0x47, 0xe0, 0x66, 0x26,
+	0xc7, 0x3d, 0x80, 0xc8, 0x60, 0x28, 0xbf, 0x4b,
+	0xd3, 0xe4, 0x56, 0x1f, 0x4b, 0x94, 0x16, 0xc0,
+	0x64, 0xd4, 0x8a, 0x2d, 0x09, 0x9e, 0x93, 0xf3,
+	0xd9, 0xcf, 0xba, 0xd2, 0xe2, 0xb7, 0x89, 0x48};
+
+
+/*
+ * pad_data_to_signature_length()
+ * Prepend padding to data in PKCS#1 format prior to verifying a signature.
+ * The PKCS#1 EME-PKCS1-v1_5 padding format for signatures is:
+ *	0x00, 0x01, 0xff, . . ., 0xff, 0x00, (original unpadded data)
+ */
+static int
+pad_data_to_signature_length(unsigned char *padded_buffer, size_t buff_len,
+    const unsigned char *data, size_t data_len)
+{
+	ssize_t		start = buff_len - data_len;
+
+	/* Sanity checks */
+	if ((buff_len > VERIFY_MODULUS_LEN) || (start < MIN_PKCS1_PADLEN)) {
+		return (1);
+	}
+
+	/* PKCS#1 padding for signatures begins with 0x00, 0x01 */
+	padded_buffer[0] = 0x00;
+	padded_buffer[1] = 0x01;
+
+	/* Pad remaining bytes, except for last byte, with 0xff */
+	grub_memset(&padded_buffer[2], 0xff, start - (2 + 1));
+
+	/* Last byte of padding ends with 0x00 */
+	padded_buffer[start -1] = 0x00;
+
+	/* Copy data at end of buffer */
+	grub_memcpy(&padded_buffer[start], data, data_len);
+
+	return (0);
+}
+
+
+/*
+ * verify_signature()
+ * Verify an elfsign(1) RSA signature, given data and a RSA elfsign public key.
+ * Return 0 if a signature and a key matches against data, otherwise non-zero.
+ *
+ * A signature is verified using RSA encryption as follows:
+ *		hash data = (signature^exponent) % modulus
+ * where:
+ * hash data	the expected hash (SHA-256) of selected ELF sections.
+ *		This is compared against the actual hash
+ * signature	the 256-byte RSA-2048 signature from the ELF
+ *		.SUNW_SIGNATURE section
+ * exponent	65537 (constant). The exponent part of the elfsign public key
+ * modulus	the 256-byte RSA-2048 modulus part of the elfsign public key
+ *
+ * Parameters:
+ * modulus		The modulus from the elfsign public key
+ *			(RSA-2048 for versions 5-6)
+ * signature		RSA signature from ELF SUNW_signature section
+ * data			Hash of selected ELF sections (SHA-256 for version 5-6)
+ * *_len		Byte lengths of the key, signature, and data above
+ */
+static int
+verify_signature(const unsigned char *modulus,
+    const unsigned char *signature, size_t signature_len,
+    const unsigned char *data, size_t data_len)
+{
+	static const unsigned char	exponent65537[] = {0x01, 0x00, 0x01};
+	int				r;
+	gcry_mpi_t			pkey_mpi = NULL;
+	gcry_mpi_t			padded_data_mpi = NULL;
+	gcry_mpi_t			sig_mpi = NULL;
+	gcry_mpi_t			exponent_mpi = NULL;
+	gcry_mpi_t			result_mpi = NULL;
+	unsigned char			padded_buffer[VERIFY_MODULUS_LEN];
+
+	/* sanity checks */
+	if ((modulus == NULL) || (signature == NULL) || (data == NULL)) {
+		grub_dprintf(DBGLABEL, "verify_signature: "
+		    "Error: NULL pointer passed to verify_signature()\n");
+		return (2);
+	}
+
+#ifdef	VERBOSE_VBOOT_DEBUG
+	grub_dprintf(DBGLABEL,  "verify_signature: Unpadded hash data:\n");
+	vboot_hex_print(data, data_len);
+#endif
+
+	/* Pad data-to-be-verified to signature length using PKCS#1 padding */
+	r = pad_data_to_signature_length(padded_buffer, sizeof (padded_buffer),
+	    data, data_len);
+	if (r != 0) {
+		grub_dprintf(DBGLABEL, "verify_signature: "
+		    "pad_data_to_signature_length() length error; rc %d\n", r);
+		goto ret;
+	}
+
+	/* Convert data, key, signature, and exponent to internal MPI format */
+	if ((r = gcry_mpi_scan(&padded_data_mpi, GCRYMPI_FMT_USG,
+	    padded_buffer, sizeof (padded_buffer), NULL)) != 0) {
+		grub_dprintf(DBGLABEL, "verify_signature: "
+		    "gcry_mpi_scan(data) returned %d\n", r);
+		goto ret;
+	}
+
+	if ((r = gcry_mpi_scan(&pkey_mpi, GCRYMPI_FMT_USG,
+	    modulus, VERIFY_MODULUS_LEN, NULL)) != 0) {
+		grub_dprintf(DBGLABEL, "verify_signature: "
+		    "gcry_mpi_scan(key) returned %d\n", r);
+		goto ret;
+	}
+
+	if ((r = gcry_mpi_scan(&sig_mpi, GCRYMPI_FMT_USG,
+	    signature, signature_len, NULL)) != 0) {
+		grub_dprintf(DBGLABEL, "verify_signature: "
+		    "gcry_mpi_scan(sig) returned %d\n", r);
+		goto ret;
+	}
+
+	if ((r = gcry_mpi_scan(&exponent_mpi, GCRYMPI_FMT_USG,
+	    exponent65537, sizeof (exponent65537), NULL)) != 0) {
+		grub_dprintf(DBGLABEL, "verify_signature: "
+		    "gcry_mpi_scan(sig) returned %d\n", r);
+		goto ret;
+	}
+
+	/* Allocate memory to hold result */
+	result_mpi = gcry_mpi_new(VERIFY_MODULUS_LEN * 8);
+	if (result_mpi == NULL) {
+		r = 4;
+		goto ret;
+	}
+
+	/*
+	 * Verify RSA signature by computing the following:
+	 *   expectedSHAChecksumPadded = (signature^65537) % publicKeyModulus
+	 * Then comparing the result with the actual SHA checksum + padding.
+	 */
+	gcry_mpi_powm(result_mpi, sig_mpi, exponent_mpi, pkey_mpi);
+
+	r = gcry_mpi_cmp(result_mpi, padded_data_mpi);
+	if (r != 0) {
+		grub_dprintf(DBGLABEL, "verify_signature: signature "
+		    "does NOT match; gcry_mpi_cmp() returned: %d\n", r);
+	}
+
+ret:
+	gcry_mpi_release(pkey_mpi);
+	gcry_mpi_release(padded_data_mpi);
+	gcry_mpi_release(sig_mpi);
+	gcry_mpi_release(exponent_mpi);
+	gcry_mpi_release(result_mpi);
+
+	return (r);
+}
+
+
+/*
+ * Sanity test for signature verification.
+ * Return 0 for pass, non-zero for fail.
+ */
+static int
+verify_signature_self_test_rsa(void)
+{
+	/* Verify data with a known signature and RSA key */
+	return (verify_signature(raw_test_modulus,
+	    raw_test_signature, sizeof (raw_test_signature),
+	    hash_unpadded_test_data, sizeof (hash_unpadded_test_data)));
+}
+
+
+/*
+ * verify_signature_against_keys()
+ * Verify an elfsign(1) RSA signature, given data and 1 or more
+ * elfsign raw RSA public keys.
+ * Return 0 if a signature and a key matches against data, otherwise non-zero.
+ *
+ * Parameters:
+ * keys			One or more RSA-2048 elfsign public key(s).
+ * dn_hash		SHA-256 hash of the DN
+ * signature		RSA signature from ELF SUNW_signature section
+ * data			SHA-256 Hash of selected ELF sections
+ * *_len		Byte lengths of the key, signature, and data
+ */
+int
+verify_signature_against_keys(
+    verified_boot_cert_t *certs, unsigned int num_keys,
+    const unsigned char *signature, size_t sig_len,
+    const unsigned char *dn_hash, const unsigned char *data, size_t data_len)
+{
+	static const unsigned char	zero_key[VERIFY_MODULUS_LEN] = {'\0'};
+	static const unsigned char	zero_dn_hash[VERIFY_DN_HASH_LEN] = {0};
+	const unsigned char		*cur_key, *prev_key;
+	const unsigned char		*cur_dn_hash;
+	int				i;
+	int				r = -1;
+	static bool			first_time = true;
+
+	if (first_time) {
+		/* Perform one-time self tests */
+		if (verify_signature_self_test_rsa() != 0) {
+			grub_dprintf(DBGLABEL, "verify_signature_against_keys: "
+			    "Failed verify_signature_self_test_rsa.\n");
+			return (-2);
+		}
+		first_time = false;
+	}
+
+#ifdef VERBOSE_VBOOT_DEBUG
+	grub_dprintf(DBGLABEL, "verify_signature_against_keys: dn_hash:\n");
+	vboot_hex_print(dn_hash, VERIFY_DN_HASH_LEN);
+#endif
+
+	if (num_keys == 0) {
+		grub_printf("Internal error: no verified boot keys\n");
+		return (-3);
+	}
+
+	prev_key = zero_key;
+
+	/* Verify signature against all keys until successful */
+	for (i = 0; i < num_keys; i++, prev_key = cur_key) {
+
+		cur_key = certs[i].key;
+		cur_dn_hash = certs[i].dn_hash;
+
+		/* skip key if it's all 0s */
+		if (grub_memcmp(cur_key, zero_key,
+		    VERIFY_MODULUS_LEN) == 0) {
+			grub_dprintf(DBGLABEL, "verify_signature_against_keys: "
+			    "skipping zero key #%u\n", i);
+			r = 1;
+			continue;
+		}
+
+		/* skip key if it's the same as the previous key */
+		if (grub_memcmp(cur_key, prev_key,
+		    VERIFY_MODULUS_LEN) == 0) {
+			grub_dprintf(DBGLABEL, "verify_signature_against_keys: "
+			    "skipping dup key #%u\n", i);
+			r = 2;
+			continue;
+		}
+
+		/* skip if current DN does not match the desired DN */
+		if ((grub_memcmp(cur_dn_hash, zero_dn_hash,
+		    VERIFY_DN_HASH_LEN) != 0) && (grub_memcmp(cur_dn_hash,
+		    dn_hash, VERIFY_DN_HASH_LEN) != 0)) {
+			grub_dprintf(DBGLABEL, "verify_signature_against_keys: "
+			    "skipping key #%u (DN does not match)\n", i);
+			r = 3;
+			continue;
+		}
+
+		if ((r = verify_signature(cur_key, signature, sig_len,
+		    data, data_len)) == 0) {
+			return (0); /* success */
+		}
+	}
+
+	grub_dprintf(DBGLABEL,
+	    "verify_signature_against_keys: FAILED, ret=%d\n", r);
+	return (r); /* fail */
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/vboot/verify_zvboot.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/vboot/verify_zvboot.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,124 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Solaris kernel zones zvboot-specific functions for Solaris Verified Boot.
+ *
+ * No ELF- or crypto-specific code should be in this file.
+ */
+
+#include <sys/types.h>
+#include <sys/verified_boot.h>	/* Verified Boot types */
+#include "verify.h"
+
+#include <grub/misc.h>		/* grub_str*() and other useful utilities */
+#include <grub/mm.h>		/* grub_*alloc* and other memory management */
+
+#include "zv_asm.h"			/* do_hypercall() */
+#include "zvcons.h"			/* panic(), console I/O */
+#include <sys/zvmm/zvmm_hcall.h>	/* Hypercalls */
+#include <sys/zvmm/zvmm_mach_hcall.h>	/* X86 Hypercalls */
+#include <sys/zone.h>
+
+#ifndef ZVBOOT
+#error	"ZVBOOT needs to be defined."
+#endif
+
+#define	ALIGN_SIZE 4096
+
+
+/*
+ * Return non-0 if a key is already present, else 0.
+ */
+static int
+verify_dup_key_check(const uchar_t *key, verify_public_certs_t *certs,
+    uint_t key_count)
+{
+	int i;
+
+	for (i = 0; i < key_count; ++i) {
+		if (grub_memcmp(key, (*certs)[i].key, VERIFY_MODULUS_LEN)
+		    == 0) {
+			return (1);
+		}
+	}
+	return (0);
+}
+
+
+/*
+ * Get cert key/dn pairs and other information from the Hypervisor.
+ * Return 0 if OK.
+ * Return -1 if the HV call is not implemented.
+ * Otherwise return non-zero for other errors.
+ */
+int
+verify_get_settings_hv(verified_boot_cert_t *certs, uint_t max_key_count,
+    uint_t *key_count, verify_policy_t *boot_policy)
+{
+	static uint64_t buffer[2 * ALIGN_SIZE / sizeof (uint64_t)];
+	union {
+		verified_boot_info_v1_t	*p;
+		intptr_t		n;
+	} vboot_align = { .n = ((intptr_t)buffer + ALIGN_SIZE - 1) &
+	    ~(ALIGN_SIZE - 1UL) };
+
+	uint64_t vboot_size = sizeof (verified_boot_info_v1_t);
+	int i, rc;
+
+	rc = do_hypercall(ZVMM_CNTRL_EXTID, ZVCNTRL_GET_ZONEATTR,
+	    ZONE_ATTR_VBOOT_INFO, vboot_align.p, &vboot_size);
+	if (rc != 0) {
+		grub_dprintf("zvboot", "verify_get_settings_hv: "
+		    "do_hypercall() failed; error %d\n", rc);
+		return (-1);
+	}
+
+	grub_dprintf("zvboot", "verify_get_settings_hv: "
+	    "do_hypercall() succeeded with policy %d, key_count %d\n",
+	    (int)vboot_align.p->policy, (int)vboot_align.p->key_count);
+
+	*boot_policy = vboot_align.p->policy;
+
+	for (i = 0; (i < vboot_align.p->key_count) &&
+	    (*key_count < max_key_count); i++) {
+		if (verify_dup_key_check(vboot_align.p->cert[i].key,
+		    certs, *key_count) != 0) {
+			grub_dprintf("zvboot", "Skipping dup key %d.\n", i);
+#ifdef	VERBOSE_VBOOT_DEBUG
+			vboot_hex_print(vboot_align.p->cert[i].key,
+			    VERIFY_MODULUS_LEN);
+#endif
+			continue;
+		}
+
+		grub_memcpy(&certs[*key_count], (void *)&vboot_align.p->cert[i],
+		    sizeof (verified_boot_cert_t));
+
+		grub_dprintf("zvboot", "verify_get_settings_hv: HV key %d.\n",
+		    i);
+#ifdef	VERBOSE_VBOOT_DEBUG
+		vboot_hex_print(certs[*key_count].key,
+		    VERIFY_MODULUS_LEN);
+#endif
+
+		++(*key_count);
+	}
+
+	return (0);
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/Mapfile.zvboot.amd64
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/Mapfile.zvboot.amd64	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,31 @@
+# GRUB  --  GRand Unified Bootloader
+# Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+# 
+# GRUB is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+# 
+# GRUB is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+
+$mapfile_version 2
+
+LOAD_SEGMENT zvboot {
+	FLAGS = READ WRITE EXECUTE;
+	# The Solaris amd64 kernel loads into memory from 4Meg to
+	# just over 12Meg. We'll put our loader below that at 3Meg.
+	VADDR = 0x300000;
+	PADDR = 0x300000; 
+	ALIGN = 0x1000;
+
+	ASSIGN_SECTION is_alloc {
+		FLAGS = ALLOC;
+	};
+	IS_ORDER = is_alloc;
+};
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/gnasher.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/gnasher.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,273 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Gnasher: a randomising hypercall stress test.
+ *
+ * Gnasher attempts to test the input validation and error handling of
+ * host extender drivers by performing pseudo-random hypercalls. It
+ * will determine the set of extenders configured for the guest domain
+ * and then attempt to exercise them at random.
+ *
+ * For each test hypercall, gnasher will generate random arguments:
+ *
+ * - argument 1 is the extender number.
+ * - argument 2 is usually the hypercall function number. A value
+ *   between 0 and 63 is generated.
+ * - argument 3 is often a guest physical address. A value between 0
+ *   and 4G is generated.
+ * - arguments 4 though 6 vary in use. 64 bit random values are
+ *   generated.
+ *
+ * The simplest way to use gnasher is to boot with the "-B
+ * zvboot_gnasher=true" flag:
+ *
+ *   # zoneadm -z colony boot -- -B zvboot_gnasher=true
+ *
+ * Standard host behaviour is to kill a guest that issues an invalid
+ * hypercall. Most of the hypercalls generated by gnasher will be
+ * invalid, which means that testing can be slow. The behaviour of the
+ * host can be modified by setting the kernel variable
+ * "zvmm_allow_bad_hypercall" to 1 before beginning any testing:
+ *
+ *   # echo "zvmm_allow_bad_hypercall/w 1" | mdb -kw
+ *
+ * Similarly, the host will object if the guest causes a host extender
+ * to write to memory that should not be writable by the guest. This
+ * can be modified using:
+ *
+ *   # echo "zvmm_allow_write_to_readonly/w 1" | mdb -kw
+ *
+ * It is a good idea to monitor the output of gnasher (using "zlogin
+ * -C colony") to see the hypercall sequence that leads up to a host
+ * panic.
+ *
+ * Please tag any bugs found using gnasher with "gnasher". 
+ */
+
+#include <stdarg.h>
+#include <sys/types.h>
+#include <sys/errno.h>
+
+#include <sys/zvmm/zvmm_hcall.h>
+#include <sys/zvmm/zvmm_mach_hcall.h>
+#include <sys/zvmm/zvmm_ext_common.h>
+#include <sys/zvmm/zvterm_common.h>
+#include <sys/zvmm/zvblk_common.h>
+#include <sys/zvmm/zvsdir_common.h>
+#include <sys/zvmm/zvnet_common.h>
+
+#include <grub/mm.h>
+#include <grub/misc.h>
+
+#include "zv_asm.h"
+#include "zv_mem.h"
+#include "zvcons.h"
+#include "gnasher.h"
+
+typedef struct blacklist_entry {
+	struct blacklist_entry *next;
+	char *type;
+	uint64_t extender;
+	uint64_t function;
+	char *reason;
+} blacklist_entry_t;
+
+static blacklist_entry_t *blacklist = NULL;
+
+static zv_extinfo_v2_t *ext_p;
+static int ext_n;
+
+static void
+blacklist_add(char *t, uint64_t e, uint64_t f, char *r)
+{
+	blacklist_entry_t *new = grub_malloc(sizeof (*new));
+	if (new == NULL)
+		panic("Cannot allocate blacklist entry.");
+
+	new->type = NULL;
+	if (t != NULL)
+		new->type = grub_strdup(t);
+	new->extender = e;
+	new->function = f;
+	new->reason = r;
+
+	new->next = blacklist;
+	blacklist = new;
+}
+
+static blacklist_entry_t *
+blacklist_find(uint64_t e, uint64_t f, uint64_t arg3, uint64_t arg4,
+    uint64_t arg5, uint64_t arg6)
+{
+	char *type = ext_p[e].ze_name;
+
+	blacklist_entry_t *l;
+	for (l = blacklist; l != NULL; l = l->next) {
+		/*
+		 * If this blacklist entry specifies an extender
+		 * number and it matches, this hypercall is
+		 * blacklisted (i.e. an extender with a blacklisted
+		 * extender number is never tested).
+		 */
+		if ((l->extender >= 0) && (l->extender == e))
+			return (l);
+
+		/*
+		 * If the blacklist entry specifies an extender type
+		 * and it doesn't match, this hypercall can't be
+		 * blacklisted.
+		 */
+		if ((l->type != NULL) &&
+		    (grub_strcmp(type, l->type) != 0))
+			continue;
+
+		/*
+		 * If the blacklist entry specifies a function number
+		 * and it matches, this hypercall is blacklisted.
+		 */
+		if ((l->function >= 0) && (l->function == f))
+			return (l);
+	}
+
+	return (NULL);
+}
+
+static void
+find_extenders(void)
+{
+	/* Allows only for 4k of extenders. */
+	static void *enum_page = NULL;
+	boolean_t support_new_enum = (do_hypercall(ZVMM_CNTRL_EXTID,
+	    ZVCNTRL_FEATURE, ZVCNTRL_ENUM_V2) == 0);
+
+	if (enum_page == NULL)
+		enum_page = page_alloc(PGSIZE);
+	ext_p = (zv_extinfo_v2_t *)enum_page;
+
+	if (support_new_enum) {
+		zv_extinfo_v2_t *ei;
+
+		if (do_hypercall(ZVMM_CNTRL_EXTID, ZVCNTRL_ENUM_V2,
+		    enum_page, 0) == 0)
+			panic("No extenders?");
+		for (ei = (zv_extinfo_v2_t *)enum_page, ext_n = 0;
+		     ei->ze_name[0] != '\0';
+		     ei++, ext_n++)
+			;
+	} else {
+		zv_extinfo_v1_t *ei;
+		zv_extinfo_v2_t *ein;
+		void *page = page_alloc(PGSIZE);
+
+		if (do_hypercall(ZVMM_CNTRL_EXTID,
+		    ZVCNTRL_ENUM_V1, page, 0) == 0)
+			panic("No extenders?");
+		for (ei = (zv_extinfo_v1_t *)page, ein = ext_p, ext_n = 0;
+		     ei->ze_name[0] != '\0';
+		     ei++, ein++, ext_n++) {
+			grub_memcpy(ein->ze_name, ei->ze_name,
+			    sizeof (ein->ze_name));
+			ein->ze_id = ei->ze_id;
+			(void) grub_snprintf(ein->ze_dev_id,
+			    ZVMM_ID_MAX_LEN, "%d", ei->ze_addr);
+		}
+	}
+
+	grub_printf("Found %d extenders at 0x%p.\n", ext_n, ext_p);
+}
+
+static uint64_t
+rand(void)
+{
+	return (do_hypercall(ZVMM_CNTRL_EXTID, ZVCNTRL_GET_RANDOM_BYTES));
+}
+
+static void
+gnash(uint64_t ext, int iter)
+{
+	uint64_t args[6];
+
+	args[0] = ext;
+	/* Function numbers are typically small integers. */
+	args[1] = rand() % 64;
+	args[2] = rand() & 0xffffffff;
+	args[3] = rand();
+	args[4] = rand();
+	args[5] = rand();
+
+	grub_printf("iter %d: "
+	    "hypercall(0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx)...\n", iter,
+	    args[0], args[1], args[2], args[3], args[4], args[5]);
+
+	blacklist_entry_t *be = blacklist_find(args[0], args[1], args[2],
+	    args[3], args[4], args[5]);
+	if (be != NULL) {
+		grub_printf("iter %d: "
+		    "                                                 "
+		    "...blacklisted (%s)\n", iter, be->reason);
+	} else {
+		uint64_t rc = do_hypercall(args[0], args[1], args[2], args[3],
+		    args[4], args[5]);
+
+		grub_printf("iter %d: "
+		    "                                                 "
+		    "...result = 0x%lx\n", iter, rc);
+	}
+}
+
+void
+gnasher(void)
+{
+	int n;
+
+	grub_printf("\nGnash, gnash!\n\n");
+
+	find_extenders();
+
+	/*
+	 * Describe the extenders discovered.
+	 */
+	zv_extinfo_v2_t *ei;
+	for (n = 0, ei = ext_p; n < ext_n; n++, ei++) {
+		grub_printf("extender %d is type %s\n",
+		    n, ei->ze_name);
+	}
+
+	blacklist_add("zvcntrl", -1, ZVCNTRL_REBOOT, "stops testing");
+	blacklist_add("zvcntrl", -1, ZVCNTRL_HALT, "stops testing");
+	blacklist_add("zvcntrl", -1, ZVCNTRL_PAUSE, "stops testing");
+	blacklist_add("zvcntrl", -1, ZVCNTRL_SUSPEND, "stops testing");
+	blacklist_add("zvcntrl", -1, ZVCNTRL_CRASHDUMP, "stops testing");
+	blacklist_add("zvcntrl", -1, ZVCNTRL_STOP_CPU, "stops testing");
+
+	blacklist_add(NULL, 1, -1, "not yet ready to test the console");
+
+	/*
+	 * Describe the configured blacklist.
+	 */
+	blacklist_entry_t *be = blacklist;
+	for (be = blacklist; be != NULL; be = be->next) {
+		grub_printf("blacklist: "
+		    "type %s, extender %ld, function %ld, reason %s\n",
+		    be->type, be->extender, be->function, be->reason);
+	}
+
+	for (n = 0; ; n++)
+		gnash(rand() % ext_n, n);
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/gnasher.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/gnasher.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,19 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+extern void gnasher(void);
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/stub/stub_gpt.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/stub/stub_gpt.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,21 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "gpt.c"
+
+struct grub_partition_map *_grub_gpt_partition_map = &grub_gpt_partition_map;
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/stub/stub_iso9660.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/stub/stub_iso9660.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,21 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "iso9660.c"
+
+struct grub_fs *_grub_iso9660_fs = &grub_iso9660_fs;
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/stub/stub_msdos.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/stub/stub_msdos.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,22 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "msdos.c"
+
+struct grub_partition_map *_grub_msdos_partition_map = 
+    &grub_msdos_partition_map;
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/stub/stub_sun.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/stub/stub_sun.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,21 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "sun.c"
+
+struct grub_partition_map *_grub_sun_partition_map = &grub_sun_partition_map;
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/stub/stub_sunpc.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/stub/stub_sunpc.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,22 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "sunpc.c"
+
+struct grub_partition_map *_grub_sun_pc_partition_map =
+    &grub_sun_pc_partition_map;
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/stub/stub_ufs.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/stub/stub_ufs.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,21 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ufs.c"
+
+struct grub_fs *_grub_ufs_fs = &grub_ufs_fs;
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/stub/stub_zfs.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/stub/stub_zfs.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,21 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "zfs.c"
+
+struct grub_fs *_grub_zfs_fs = &grub_zfs_fs;
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/stubs.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/stubs.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,119 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/command.h>
+#include <grub/device.h>
+#include <grub/disk.h>
+#include <grub/dl.h>
+#include <grub/misc.h>
+#include <grub/term.h>
+
+#include "zvcons.h"
+
+/* No dynamic loading in zvboot. */
+int
+grub_dl_ref(grub_dl_t mod)
+{
+	return (1);
+}
+
+int
+grub_dl_unref(grub_dl_t mod)
+{
+	return (1);
+}
+
+/* Miscellaneous. */
+void
+grub_exit(void)
+{
+	extern void panic(char *fmt, ...);
+
+	panic("grub_exit() called.");
+	for (;;)
+		;
+}
+
+/*
+ * Set to 'zvboot' for zvboot specific details, set to 'all' for
+ * more.
+ */
+static char *grub_debug_value = "";
+
+const char *
+grub_env_get(const char *var)
+{
+	if (grub_strcmp(var, "debug") == 0)
+		return (grub_debug_value);
+
+	return (NULL);
+}
+
+grub_err_t
+grub_env_set(const char *var, const char *val)
+{
+	if (grub_strcmp(var, "debug") == 0) {
+		if (val[0] != '\0') {
+			if (grub_debug_value[0] != '\0')
+				grub_free(grub_debug_value);
+			grub_debug_value = grub_strdup(val);
+		}
+	}
+
+	return (GRUB_ERR_NONE);
+}
+
+grub_command_t
+grub_register_command_prio(const char *name, grub_command_func_t func,
+    const char *summary, const char *description, int prio)
+{
+	return (NULL);
+}
+
+void
+grub_unregister_command(grub_command_t cmd)
+{
+}
+
+grub_uint64_t
+grub_get_time_ms(void)
+{
+	/*
+	 * Nothing needs real time, so we provide a simple
+	 * incrementing counter just in case some code compares the
+	 * results.
+	 */
+	static grub_uint64_t t;
+
+	return (t++);
+}
+
+/* Terminal support. */
+void (*grub_xputs) (const char *str) = zcons_puts;
+struct grub_term_input *grub_term_inputs = NULL;
+
+int
+grub_getkey(void)
+{
+	return (GRUB_TERM_NO_KEY);
+}
+
+void
+grub_refresh(void)
+{
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/zv_asm.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/zv_asm.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,36 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef	_ZV_ASM_H
+#define	_ZV_ASM_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#ifdef amd64
+extern uint64_t getcr3(void);
+#endif /* amd64 */
+
+extern uint64_t do_hypercall(uint64_t, uint64_t, ...);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _ZV_ASM_H */
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/zv_asm_amd64.s
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/zv_asm_amd64.s	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,88 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#if defined(__lint)
+
+#include "zv_asm.h"
+
+int silence_lint_warnings = 0;
+
+uint64_t
+getcr3(void)
+{ return (0); }
+
+/*ARGSUSED*/
+uint64_t
+do_hypercall(uint64_t, uint64_t, ...)
+{ return (0); }
+
+#else /* __lint */
+
+#include <sys/asm_linkage.h>
+
+	.text
+	.globl _start
+_start:
+	/*
+	 * At entry we are in 64 bit paging mode with interrupts disabled.
+	 *
+	 * %RDI has a pointer to our zv_start_data
+	 * %RSP has lots of room and is 16 byte aligned.
+	 *
+	 * really not much more to do here so just
+	 * go off into C to handle everything.
+	 * We never actually return here either, but
+	 * just call into the loaded kernel.
+	 */
+	jmp	boot
+
+	ENTRY(getcr3)
+	movq	%cr3, %rax
+	ret
+	SET_SIZE(getcr3)
+
+	ENTRY(do_hypercall)
+        pushq   %rbx
+        pushq   %rcx
+        pushq   %rdx
+
+        xorq    %rax, %rax
+        cpuid
+        cmpl    $0x68747541, %ebx       /* "Auth" part of AuthenticAMD */
+        jne     1f
+        leaq    amd_vmmcall_insn(%rip), %rax
+        jmp     2f
+1:
+        leaq    intel_vmcall_insn(%rip), %rax
+2:
+        popq    %rdx
+        popq    %rcx
+        popq    %rbx
+        jmp     *%rax
+
+intel_vmcall_insn:
+        vmcall
+        ret
+
+amd_vmmcall_insn:
+        vmmcall
+        ret
+
+	SET_SIZE(do_hypercall)
+
+#endif /* __lint */
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/zv_mem.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/zv_mem.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,72 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef	_ZVMEM_H
+#define	_ZVMEM_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#ifndef NULL
+#define	NULL (void *)0
+#endif
+
+#define KBYTE(x) ((x) * 1024ul)
+#define MBYTE(x) (KBYTE(x) * 1024ul)
+#define GBYTE(x) (MBYTE(x) * 1024ul)
+
+#define ROUND_UP(val, align) (((val) + ((align)-1)) & ~(uint64_t)((align)-1))
+
+#if defined(amd64)
+
+#define	PGSIZE	KBYTE(4)
+
+/*
+ * page table bit defines
+ */
+#define	PT_VALID	(0x001) /* a valid translation is present */
+#define	PT_WRITABLE	(0x002) /* the page is writable */
+#define	PT_USER		(0x004) /* the page is accessible by user mode */
+#define	PT_WRITETHRU	(0x008) /* write back caching is disabled (non-PAT) */
+#define	PT_NOCACHE	(0x010) /* page is not cacheable (non-PAT) */
+#define	PT_REF		(0x020) /* page was referenced */
+#define	PT_MOD		(0x040) /* page was modified */
+#define	PT_PAGESIZE	(0x080) /* above level 0, indicates a large page */
+#define	PT_GLOBAL	(0x100) /* the mapping is global */
+#define PT_NOCONSIST	(0x400) /* PTE has no mapping list entry */
+typedef uint64_t x86pte_t;
+
+extern x86pte_t *find_pte(uintptr_t va, uint_t level);
+extern void map_pa_at_va(uint64_t pa, void *va, uint_t level);
+
+#endif /* amd64 */
+
+#define PGOFFSET	(PGSIZE - 1)
+#define PGMASK		~PGOFFSET
+
+extern uintptr_t last_phys;
+
+extern void *page_alloc(size_t size);
+extern void *memmove(void *s, const void *s0, size_t n);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _ZVMEM_H */
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/zv_mem_amd64.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/zv_mem_amd64.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,133 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <sys/types.h>
+#include <sys/x86_archext.h>
+#include <sys/archsystm.h>
+#include <sys/controlregs.h>
+#include "zv_mem.h"
+#include "zv_asm.h"
+
+/*
+ * This program loads into memory at 3Meg virt/phys.
+ *
+ * The memory from 1Meg up to 3Meg will be available for page tables.
+ * Which allows us to build mappings for up to 1Gig. That should be plenty.
+ */
+
+/*
+ * Standard bits used in PTE (page level) and PTP (internal levels)
+ */
+static x86pte_t ptp_bits = PT_VALID | PT_REF | PT_WRITABLE | PT_USER;
+static x86pte_t pte_bits = PT_VALID | PT_REF | PT_WRITABLE | PT_MOD |
+    PT_NOCONSIST;
+
+uintptr_t last_phys = 0;
+static uintptr_t next_ptable = MBYTE(1);
+
+static uint_t shift_amt[] = {12, 21, 30, 39};
+static uint_t ptes_per_table = 512;
+static uint_t top_level = 3;
+
+/*
+ * get the index corresponding to a virt address at a given page table level.
+ */
+static uint_t
+vatoindex(uintptr_t va, uint_t level)
+{
+	return ((va >> shift_amt[level]) & (ptes_per_table - 1));
+}
+
+/*
+ * Return the page table entry that maps a virtual address.
+ */
+x86pte_t *
+find_pte(uintptr_t va, uint_t level)
+{
+	uint_t l;
+	uint_t index;
+	x86pte_t *table;
+	x86pte_t *new_table;
+	x86pte_t pteval;
+
+	/*
+	 * Walk down the page tables creating any needed intermediate tables.
+	 */
+	table = (x86pte_t *)(getcr3() & PGMASK);
+	for (l = top_level; l != level; --l) {
+
+		index = vatoindex(va, l);
+		pteval = table[index];
+
+		if (pteval & PT_VALID) {
+			table = (x86pte_t *)(pteval & PGMASK);
+		} else {
+			new_table = (x86pte_t *)next_ptable;
+			next_ptable += PGSIZE;
+			pteval = (x86pte_t)new_table | ptp_bits;
+			table[index] = pteval;
+			table = new_table;
+		}
+	}
+
+	/*
+	 * Return a pointer into the current pagetable.
+	 */
+	index = vatoindex(va, l);
+	return (table + index);
+}
+
+/*
+ * Add a mapping for the machine page at the given virtual address.
+ */
+void
+map_pa_at_va(uint64_t pa, void *vaddr, uint_t level)
+{
+	uintptr_t va = (uintptr_t)vaddr;
+	x86pte_t *pte_ptr;
+	x86pte_t pteval;
+
+	pteval = pa | pte_bits;
+	if (level > 0)
+		pteval |= PT_PAGESIZE;
+	if (va != pa)
+		pteval |= PT_GLOBAL;
+
+	/*
+	 * Find the pte that will map this address. This creates any
+	 * missing intermediate level page tables
+	 */
+	pte_ptr = find_pte(va, level);
+	*pte_ptr = pteval;
+}
+
+/*
+ * Allocate guest physical from low memory towards high
+ */
+void *
+page_alloc(size_t size)
+{
+	uintptr_t val;
+	uintptr_t v;
+
+	val = last_phys;
+	last_phys = val + ROUND_UP(size, PGSIZE);
+	for (v = val; v < last_phys; v += PGSIZE)
+		map_pa_at_va(v, (void *)v, 0);
+	return ((void *)val);
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/zvblk.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/zvblk.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,329 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2024, Oracle and/or its affiliates.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <sys/types.h>
+
+#include "zv_asm.h"
+#include "zv_mem.h"
+#include "zvcons.h"
+
+#include <sys/zvmm/zvmm_hcall.h>
+#include <sys/zvmm/zvmm_ext_common.h>
+#include <sys/zvmm/zvblk_common.h>
+
+#include <grub/disk.h>
+#include <grub/misc.h>
+#include <grub/mm.h>
+
+#define	ZVBLK_NAME	"zvblk"
+
+typedef struct zvblk_dev {
+	zv_extinfo_v2_t ei;
+	struct zvblk_dev *next;
+} zvblk_dev_t;
+
+static zvblk_dev_t *zvblk_dev = NULL;
+static zvblk_dev_t *zvblk_last = NULL;
+
+static zvblk_dev_t *
+find_dev(int addr)
+{
+	zvblk_dev_t *d;
+	zv_idstr_t idstr;
+
+	(void) grub_snprintf(idstr, ZVMM_ID_MAX_LEN, "%d", addr);
+	for (d = zvblk_dev; d != NULL; d = d->next)
+		if (grub_strcmp(d->ei.ze_dev_id, idstr) == 0)
+			return (d);
+
+	return (NULL);
+}
+
+uint64_t
+disk_get_info(int drive, uint64_t flag)
+{
+	static zvblk_info_t *zi = NULL;
+
+	if (zi == NULL)
+		zi = page_alloc(PGSIZE);
+
+	if (do_hypercall(drive, ZVBLK_GET_INFO_V1, flag, zi) != 0)
+		return (0);
+
+	if (flag == ZVBLK_DEV_SIZE)
+		return (zi->zdi_size);
+
+	/* Grub should only care about logical block size. */
+	if (flag == ZVBLK_DEV_BSIZE)
+		return (zi->zdi_lblksize);
+
+	if (flag == ZVBLK_DEV_TYPE)
+		return (zi->zdi_removable);
+
+	return (0);
+}
+
+uint64_t
+zvblk_disk_get_info(const char *name, uint64_t flag)
+{
+	const unsigned int l = grub_strlen(ZVBLK_NAME);
+
+	if (grub_strncmp(name, ZVBLK_NAME, l) != 0) {
+		grub_dprintf("zvblk", "%s: you're not one of us!\n",
+			name);
+		return (-1);
+	}
+
+	unsigned int addr = grub_strtoul(name + l, 0, 0);
+	zvblk_dev_t *d = find_dev(addr);
+	if (d == NULL)
+		return (-1);
+
+	return (disk_get_info(d->ei.ze_id, flag));
+}
+
+static int
+zvblk_iterate(grub_disk_dev_iterate_hook_t hook, void *hook_data, grub_disk_pull_t pull)
+{
+	zvblk_dev_t *d;
+
+	if (pull != GRUB_DISK_PULL_NONE)
+		return (0);
+
+	for (d = zvblk_dev; d != NULL; d = d->next) {
+		char devname[40];
+
+		grub_snprintf(devname, sizeof (devname),
+		    "%s%s", ZVBLK_NAME, d->ei.ze_dev_id);
+		if (hook(devname, hook_data))
+			return (1);
+	}
+	return (0);
+}
+
+static grub_err_t
+zvblk_open(const char *name, grub_disk_t disk)
+{
+	const unsigned int l = grub_strlen(ZVBLK_NAME);
+	uint64_t bsize;
+
+	grub_dprintf("zvblk", "attempt to open %s:\n", name);
+
+	if (grub_strncmp(name, ZVBLK_NAME, l) != 0) {
+		grub_dprintf("zvblk", "%s: you're not one of us!\n",
+			name);
+		return (grub_error(GRUB_ERR_UNKNOWN_DEVICE,
+			"not a zvblk device"));
+	}
+
+	unsigned int addr = grub_strtoul(name + l, 0, 0);
+	zvblk_dev_t *d = find_dev(addr);
+	if (d == NULL) {
+		grub_dprintf("zvblk", "open of %s fails.\n", name);
+		return (grub_error(GRUB_ERR_UNKNOWN_DEVICE,
+			"unknown extender"));
+	}
+
+	bsize = disk_get_info(d->ei.ze_id, ZVBLK_DEV_BSIZE);
+	disk->total_sectors =
+	    disk_get_info(d->ei.ze_id, ZVBLK_DEV_SIZE) / bsize;
+	for (disk->log_sector_size = 0;
+	    (1U << disk->log_sector_size) < bsize;
+	    disk->log_sector_size++)
+		;
+
+	disk->id = addr;
+	disk->data = d;
+
+	grub_errno = GRUB_ERR_NONE;
+	grub_dprintf("zvblk", "open of %s succeeds.\n", name);
+
+	return (GRUB_ERR_NONE);
+}
+
+static void
+zvblk_close(grub_disk_t disk)
+{
+	/* Nothing. */
+}
+
+static grub_err_t
+zvblk_read(grub_disk_t disk, grub_disk_addr_t sector,
+    grub_size_t size, char *buf)
+{
+	static zvblk_first_desc_t *iodesc = NULL;
+	zvblk_dev_t *d = disk->data;
+	zvblk_vec_desc_t *vec;
+	uint64_t *pa;
+	uint64_t seg;
+	uint64_t max_segs;
+	uint64_t rc;
+	uint64_t real_size = size << disk->log_sector_size;
+
+	grub_dprintf(ZVBLK_NAME, "zvblk_read: "
+	    "disk: %s, sector 0x%lx, size 0x%lx, real 0x%lx, buf %p\n",
+	    disk->name, sector, size, real_size, buf);
+
+	/*
+	 * Page-aligned iodesc.  Both the iodesc and disk_buffer are guest
+	 * physical addresses, as required by the host side driver. In
+	 * zvboot, VA == PA, so no conversion is required.
+	 */
+	if (iodesc == NULL)
+		iodesc = page_alloc(PGSIZE);
+	iodesc->zid_hdr.zih_ver = 0;
+	iodesc->zid_hdr.zih_desc_type = ZVBLK_IODESC_TYPE_FIRST;
+	iodesc->zid_hdr.zih_next_desc_gpa = 0;
+	iodesc->zid_id = 0;
+	iodesc->zid_op = ZVBLK_OP_READ;
+	iodesc->zid_op |= ZVBLK_OP_FLAG_SYNC;
+	/* We don't need more than one descriptor page for max 1MB I/O size. */
+	iodesc->zid_desc_num = 1;
+	iodesc->zid_block = sector;
+	iodesc->zid_size = real_size;
+	vec = (zvblk_vec_desc_t *)iodesc->zid_data;
+	/* We only need one vector descriptor. */
+	pa = iodesc->zid_data + 1;
+	iodesc->zid_vec_num = 1;
+
+	max_segs = (PGSIZE - sizeof (zvblk_first_desc_t)) / sizeof (*pa);
+
+	for (seg = 0; real_size > 0; seg++) {
+		size_t avail = PGSIZE - ((uint64_t)buf & PGOFFSET);
+		size_t this_len = (real_size > avail) ? avail : real_size;
+
+		if (seg > max_segs)
+			panic("Too many segments");
+
+		pa[seg] = (uint64_t)buf;
+
+		buf += this_len;
+		real_size -= this_len;
+	}
+
+	iodesc->zid_page_num = seg;
+	vec->zvd_desc_index = 0;
+	vec->zvd_desc_offset = (uintptr_t)pa & PGOFFSET;
+	vec->zvd_size = iodesc->zid_size;
+
+	/* start the disk blk read then wait for it to complete */
+	rc = do_hypercall(d->ei.ze_id, ZVBLK_IO, iodesc);
+	if (rc != ZVBLK_IO_DONE) {
+		return (grub_error(GRUB_ERR_READ_ERROR,
+			"IO operation failed"));
+	}
+	if ((iodesc->zid_result & ZVBLK_RES_OKAY) == 0) {
+		return (grub_error(GRUB_ERR_READ_ERROR,
+			"failed to read block"));
+	}
+
+	return (GRUB_ERR_NONE);
+}
+
+static grub_err_t
+zvblk_write(grub_disk_t disk, grub_disk_addr_t sector,
+    grub_size_t size, const char *buf)
+{
+	return (GRUB_ERR_NOT_IMPLEMENTED_YET);
+}
+
+static struct grub_disk_dev grub_zvblk_dev = {
+	.name = ZVBLK_NAME,
+	/*
+	 * There is no GRUB_DISK_DEVICE_*_ID identifier assigned for
+	 * zvblk, so we re-use that for ATA devices. Given that we
+	 * will never see anything other than zvblk disk devices, this
+	 * is safe.
+	 */
+	.id = GRUB_DISK_DEVICE_ATA_ID,
+	.disk_iterate = zvblk_iterate,
+	.disk_open = zvblk_open,
+	.disk_close = zvblk_close,
+	.disk_read = zvblk_read,
+	.disk_write = zvblk_write,
+	.next = NULL
+};
+
+static void
+zvblk_add(zv_extinfo_v2_t *eip)
+{
+	zvblk_dev_t *new;
+
+	grub_dprintf("zvblk", "add zvblk extender addr %s.\n", eip->ze_dev_id);
+
+	new = grub_malloc(sizeof (*new));
+	if (new == NULL)
+		panic("out of memory");
+
+	new->ei = *eip;
+	new->next = NULL;
+	if (zvblk_last != NULL)
+		zvblk_last->next = new;
+	else
+		zvblk_dev = new;
+	zvblk_last = new;
+}
+
+void
+zvblk_init(void)
+{
+	boolean_t support_new_enum = (do_hypercall(ZVMM_CNTRL_EXTID,
+	    ZVCNTRL_FEATURE, ZVCNTRL_ENUM_V2) == 0);
+
+	/* Declare the zvblk disk type. */
+	grub_disk_dev_register(&grub_zvblk_dev);
+
+	/* Enumerate the extenders, adding disk devices. */
+	void *enum_page = page_alloc(PGSIZE);
+	uint64_t rc;
+
+	rc = 0;
+	for (;;) {
+		if (support_new_enum) {
+			zv_extinfo_v2_t *eip;
+
+			rc = do_hypercall(ZVMM_CNTRL_EXTID, ZVCNTRL_ENUM_V2,
+			    enum_page, rc);
+			if (rc == 0)
+				break;
+			for (eip = enum_page; eip->ze_name[0] != '\0';
+			    eip++) {
+				if (grub_strcmp(eip->ze_name, "zvblk") == 0)
+					zvblk_add(eip);
+			}
+		} else {
+			zv_extinfo_v1_t *ei;
+			zv_extinfo_v2_t ein;
+
+			rc = do_hypercall(ZVMM_CNTRL_EXTID, ZVCNTRL_ENUM_V1,
+			    enum_page, rc);
+			if (rc == 0)
+				break;
+			for (ei = enum_page; ei->ze_name[0] != '\0'; ei++) {
+				if (grub_strcmp(ei->ze_name, "zvblk") == 0) {
+					grub_memcpy(ein.ze_name, ei->ze_name,
+					    sizeof (ein.ze_name));
+					ein.ze_id = ei->ze_id;
+					(void) grub_snprintf(ein.ze_dev_id,
+					    ZVMM_ID_MAX_LEN, "%d", ei->ze_addr);
+					zvblk_add(&ein);
+				}
+			}
+		}
+	}
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/zvcons.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/zvcons.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,91 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <sys/types.h>
+#include <stdarg.h>
+#include <sys/zvmm/zvmm_hcall.h>
+#include <sys/zvmm/zvterm_common.h>
+
+#include "zv_asm.h"
+#include "zv_mem.h"
+#include "zvcons.h"
+
+#include <grub/misc.h>
+
+#define	EAGAIN	(11)
+
+/*
+ * Primitive version of panic, prints a message then resets the system.
+ */
+void
+panic(char *fmt, ...)
+{
+	va_list	args;
+
+	grub_printf("\nPANIC: zvboot: ");
+	va_start(args, fmt);
+	(void) grub_vprintf(fmt, args);
+	va_end(args);
+	grub_printf("\n");
+
+	do_hypercall(ZVMM_CNTRL_EXTID, ZVCNTRL_PAUSE);
+	do_hypercall(ZVMM_CNTRL_EXTID, ZVCNTRL_HALT);
+}
+
+void
+zcons_puts(const char *s)
+{
+	while (*s != 0) {
+		zcons_putchar(*s);
+		++s;
+	}
+}
+
+void
+zcons_putchar(char c)
+{
+	int checks = 10000;
+
+	while (checks--) {
+		if (do_hypercall(ZVMM_CONS_EXTID, ZVTERM_WRITE, 0, 0) != EAGAIN)
+			break;
+
+		(void) do_hypercall(ZVMM_CNTRL_EXTID, ZVCNTRL_PAUSE);
+	}
+
+	(void) do_hypercall(ZVMM_CONS_EXTID, ZVTERM_PUTCHAR, c);
+}
+
+char
+zcons_getchar(void)
+{
+	for (;;) {
+		if (do_hypercall(ZVMM_CONS_EXTID, ZVTERM_READ, 0, 0) != EAGAIN)
+			break;
+
+		(void) do_hypercall(ZVMM_CNTRL_EXTID, ZVCNTRL_PAUSE);
+	}
+
+	return (do_hypercall(ZVMM_CONS_EXTID, ZVTERM_GETCHAR));
+}
+
+int
+zcons_ischar(void)
+{
+	return (do_hypercall(ZVMM_CONS_EXTID, ZVTERM_READ, 0, 0) == 0);
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/zvcons.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/zvcons.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,36 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef	_ZV_PRINTF_H
+#define	_ZV_PRINTF_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+extern void panic(char *fmt, ...);
+extern void zcons_puts(const char *);
+extern void zcons_putchar(char);
+extern char zcons_getchar(void);
+extern int zcons_ischar(void);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _ZV_PRINTF_H */
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/zvgrub.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/zvgrub.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,1623 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ * Copyright (c) 2011, 2024, Oracle and/or its affiliates.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <sys/types.h>
+#include <sys/varargs.h>
+
+#include <grub/device.h>
+#include <grub/disk.h>
+#include <grub/file.h>
+#include <grub/misc.h>
+#include <grub/mm.h>
+/* Avoid clashing definitions with kernel headers. */
+#define	GRUB_DL_H 1
+#include <grub/partition.h>
+#include <grub/zfs/zfs.h>
+
+#include "zvload.h"
+#include "zvcons.h"
+#include "zv_mem.h"
+#include "zv_asm.h"
+#include "gnasher.h"
+
+#include <sys/zvmm/zvmm_hcall.h>
+#include <sys/zvmm/zvmm_ext_common.h>
+#include <sys/zvmm/zvmm_mach_hcall.h>
+#include <sys/zvmm/zvblk_common.h>
+
+#include <sys/zone.h>
+
+#define	KEY_CTRL_F	(0x06)
+#define	KEY_CTRL_B	(0x02)
+#define	KEY_ESC		(0x1b)
+#define	KEY_ENTER	(0x0d)
+#define	KEY_DEL		(0x7f)
+#define	KEY_BACK	(0x08)
+
+#define	LINELEN		(BOOTARGS_MAX)
+
+#define	STR(s) (((s) != NULL ? (s) : ""))
+
+/* The grub2 name for our boot device. */
+static char *boot_device_name = NULL;
+/* The type of the filesystem on the boot device. */
+static char *boot_fstype = NULL;
+
+static char *config_file_path = "/boot/menu.conf";
+
+/* Default boot device. */
+#define	DEFAULT_BOOT_DEVICE	"disk0"
+
+/* grub2 device name for a ramdisk. */
+#define	GRUB_RAMDISK_DEVICE	"memdisk"
+/* grub2 device prefix for a zvmm block device. */
+#define	GRUB_ZVBLK_DEVICE	"zvblk"
+
+extern grub_device_t memdisk_set(char *, grub_off_t);
+
+static char *config;
+
+typedef struct config_entry {
+	char *ce_title;
+	char *ce_rootdev;
+	char *ce_bootfs;
+	char *ce_bootargs;
+	char *ce_kernel;
+	char *ce_module;
+	int ce_default;
+	int ce_index;
+} config_entry_t;
+
+typedef struct boot_args {
+	char *ba_dev;
+	char *ba_be;
+	char *ba_kern;
+	char *ba_kernargs;
+	char *ba_debugargs;
+	boolean_t ba_list;
+	boolean_t ba_gnasher;
+} boot_args_t;
+
+static config_entry_t chosen_entry;
+
+static grub_file_t
+file_open(const char *dev, const char *dataset, const char *path)
+{
+	char fullpath[2 * LINELEN];
+	char *tp;
+
+	fullpath[0] = '\0';
+
+	/*
+	 * Generate a grub2 style pathname, including the device
+	 * specifier.
+	 *
+	 * We assume that:
+	 * - a `path' that includes the @ character already has the
+         *   ZFS filesystem name prepended to it,
+	 * - `dataset' includes a ZFS pool name (as well as filesystem)
+         *   if it doesn't being with a slash (/),
+	 * - only the boot device might be ZFS.
+	 *
+	 * XXX: This is a complicated mess, as it tries to deal with
+	 * ZFS and non-ZFS, the presence/absence of a dataset, etc.
+	 * It, and the callers, should be cleaned up.
+	 */
+
+	tp = grub_stpcpy(fullpath, "(");
+	tp = grub_stpcpy(tp, dev);
+	tp = grub_stpcpy(tp, ")");
+
+	if ((grub_strcmp(dev, boot_device_name) == 0) &&
+	    (grub_strcmp(boot_fstype, "zfs") == 0) &&
+	    (dataset != NULL) &&
+	    (dataset[0] != '\0') &&
+	    (grub_strchr(path, '@') == NULL)) {
+		char *slash;
+
+		/* Remove the dataset name, if present. */
+		if ((dataset[0] != '/') &&
+		    ((slash = grub_strchr(dataset, '/')) != NULL))
+			tp = grub_stpcpy(tp, slash);
+		else
+			tp = grub_stpcpy(tp, dataset);
+		tp = grub_stpcpy(tp, "/@/");
+	}
+	tp = grub_stpcpy(tp, path);
+
+	grub_dprintf("zvboot", "file_open(<%s>, %s, %s) -> %s\n",
+	    dev, dataset, path, fullpath);
+
+	return (grub_file_open(fullpath, GRUB_FILE_TYPE_NONE));
+}
+
+static grub_ssize_t
+file_read(grub_file_t file, void *buf, grub_size_t len)
+{
+	char *p = buf;
+	grub_size_t remain = len;
+	grub_ssize_t r = 0;
+
+	/* Read in 1MB chunks to help out zvblk. */
+	while (remain > 0) {
+		grub_size_t this = remain;
+		grub_size_t good;
+
+		if (this > MBYTE(1))
+			this = MBYTE(1);
+
+		if ((good = grub_file_read(file, p, this)) != this) {
+			r += good;
+			return (r);
+		}
+
+		remain -= this;
+		r += good;
+		p += this;
+	}
+
+	return (r);
+}
+
+static void
+delete_char(char *buf, size_t pos)
+{
+	char *cp;
+
+	if (buf[pos] == '\0')
+		return;
+
+	cp = &buf[pos + 1];
+
+	do {
+		*(cp - 1) = *cp;
+		cp++;
+	} while (*(cp - 1) != '\0');
+}
+
+static void
+insert_char(char *buf, size_t pos, char ch)
+{
+	char *cp = buf + grub_strlen(buf);
+
+	*(cp + 1) = '\0';
+
+	while (cp != &buf[pos]) {
+		*cp = *(cp - 1);
+		cp--;
+	}
+
+	buf[pos] = ch;
+}
+
+static char *
+eat_white(char *cp)
+{
+	while (grub_isspace(*cp))
+		++cp;
+	return (cp);
+}
+
+static char *
+eat_word(char *cp, char *buf, size_t size)
+{
+	if (buf != NULL)
+		*buf = '\0';
+
+	while (!grub_isspace(*cp) && *cp != '\n' && *cp != '\0') {
+		if (buf != NULL && size > 1) {
+			*buf = *cp;
+			size--;
+			buf++;
+		}
+
+		cp++;
+	}
+
+	if (buf != NULL)
+		*buf = '\0';
+
+	return (cp);
+}
+
+static int
+get_num(const char *cp, int *valid)
+{
+	int x = 0;
+	int sign = 1;
+
+	if (*cp == '-') {
+		sign = -1;
+		++cp;
+	}
+
+	while ('0' <= *cp && *cp <= '9') {
+		if (valid != NULL)
+			*valid = 1;
+		x = x * 10 + *cp - '0';
+		++cp;
+	}
+
+	if (*cp != '\0' && *cp != '\t' && *cp != '\n') {
+		if (valid != NULL)
+			*valid = 0;
+	}
+
+	return (x * sign);
+}
+
+static void
+clear_line(void)
+{
+	zcons_putchar(0x1b);
+	zcons_putchar('[');
+	zcons_putchar('2');
+	zcons_putchar('K');
+	zcons_putchar('\r');
+}
+
+/*
+ * primitive interactive line editing
+ */
+static void
+getline(char *buf, size_t size)
+{
+	size_t pos = 0;
+
+	buf[0] = '\0';
+
+	for (;;) {
+		size_t len;
+		char ch;
+
+		len = grub_strlen(buf);
+
+		clear_line();
+		grub_printf("%s", buf);
+
+		switch ((ch = zcons_getchar())) {
+		case KEY_CTRL_F:
+			if (pos < len)
+				pos++;
+			break;
+
+		case KEY_CTRL_B:
+			if (pos > 0)
+				pos--;
+			break;
+
+		case KEY_ENTER:
+			zcons_putchar('\n');
+			return;
+
+		/*
+		 * Rather than attempt to support delete, we're better off
+		 * treating them the same due to the world's insanity over
+		 * backspace/delete.
+		 */
+		case KEY_DEL:
+		case KEY_BACK:
+			if (pos == 0)
+				break;
+
+			delete_char(buf, --pos);
+			break;
+
+		default:
+			if (len + 1 == size)
+				break;
+
+			insert_char(buf, pos++, ch);
+			break;
+		}
+	}
+}
+
+static char *
+get_poolname(const char *device)
+{
+	grub_device_t dev;
+	dev = grub_device_open(device);
+	if (dev == NULL)
+		return (NULL);
+
+	grub_err_t err;
+	char *nvlist;
+	err = grub_zfs_fetch_nvlist(dev, &nvlist);
+	grub_device_close(dev);
+	if (err != 0)
+		return (NULL);
+
+	char *poolname;
+	poolname = grub_zfs_nvlist_lookup_string(nvlist,
+	    ZPOOL_CONFIG_POOL_NAME);
+	if (poolname == NULL) {
+		grub_free(nvlist);
+		return (NULL);
+	}
+	grub_free(nvlist);
+
+	return (poolname);
+}
+
+static char *
+get_default_bootfs(const char *device)
+{
+	grub_device_t dev;
+	dev = grub_device_open(device);
+	if (dev == NULL) {
+		/* Any failure should not carry forward. */
+		grub_errno = GRUB_ERR_NONE;
+		return (NULL);
+	}
+
+	/* Find the default boot filesystem. */
+	char *default_bootfs;
+	grub_err_t err;
+	err = grub_zfs_defaultbootfsname(dev, &default_bootfs);
+	if (err != 0) {
+		grub_device_close(dev);
+
+		/*
+		 * Any error should not carry forward - this function
+		 * can be called with a device which has a non-ZFS
+		 * filesystem.
+		 */
+		grub_errno = GRUB_ERR_NONE;
+		return (NULL);
+	}
+
+	grub_device_close(dev);
+
+	return (default_bootfs);
+}
+
+static char *
+get_default_dataset(const char *device)
+{
+	/* Find the pool name. */
+	char *poolname = get_poolname(device);
+	if (poolname == NULL) {
+		/*
+		 * Any error should not carry forward - this function
+		 * can be called with a device which has a non-ZFS
+		 * filesystem.
+		 */
+		grub_errno = GRUB_ERR_NONE;
+		return (NULL);
+	}
+
+	/* Find the default boot filesystem. */
+	char *default_bootfs = get_default_bootfs(device);;
+	if (default_bootfs == NULL)
+		return (NULL);
+
+	/* Combine the two. */
+	grub_size_t sz = grub_strlen(poolname) + grub_strlen(default_bootfs)
+	    + 2; /* / and \0. */
+	char *combined = grub_malloc(sz);
+	if (combined == NULL) {
+		grub_dprintf("zvboot", "Could not allocate %ld bytes for "
+		    "default bootfs name.\n", sz);
+
+		grub_free(default_bootfs);
+		grub_free(poolname);
+		return (NULL);
+	}
+
+	grub_snprintf(combined, sz, "%s/%s", poolname, default_bootfs);
+
+	grub_free(default_bootfs);
+	grub_free(poolname);
+
+	grub_dprintf("zvboot", "default bootfs for %s is %s.\n",
+	    device, combined);
+
+	return (combined);
+}
+
+/*
+ * We have various things to fix up before we can use the chosen config entry.
+ */
+static void
+complete_entry(config_entry_t *entry, char *default_device, boot_args_t *ba)
+{
+#if defined(amd64)
+#define	DEFAULT_KERNEL	"/platform/i86pc/kernel/amd64/unix"
+#define	DEFAULT_ARCHIVE	"/platform/i86pc/amd64/boot_archive"
+#else
+#error "Unknown platform"
+#endif
+
+	if (entry->ce_title == NULL)
+		entry->ce_title = "default";
+	/* If no root device is specified, use the default. */
+	if (entry->ce_rootdev == NULL)
+		entry->ce_rootdev = default_device;
+	/* If no bootfs is specified, used the default for the pool. */
+	if (entry->ce_bootfs == NULL)
+		entry->ce_bootfs = get_default_dataset(entry->ce_rootdev);
+
+	if (ba != NULL && ba->ba_kern != NULL)
+		entry->ce_kernel = ba->ba_kern;
+	else if (entry->ce_kernel == NULL)
+		entry->ce_kernel = DEFAULT_KERNEL;
+
+	if (ba != NULL && ba->ba_kernargs != NULL)
+		entry->ce_bootargs = ba->ba_kernargs;
+
+	if (entry->ce_module == NULL)
+		entry->ce_module = DEFAULT_ARCHIVE;
+}
+
+static void
+print_entry(const char *title, config_entry_t *c)
+{
+	grub_dprintf("zvboot", "%s:\n", title);
+	grub_dprintf("zvboot", "   title: %s\n", c->ce_title);
+	grub_dprintf("zvboot", " rootdev: %s\n", c->ce_rootdev);
+	grub_dprintf("zvboot", "  bootfs: %s\n", c->ce_bootfs);
+	grub_dprintf("zvboot", "bootargs: %s\n", c->ce_bootargs);
+	grub_dprintf("zvboot", "  kernel: %s\n", c->ce_kernel);
+	grub_dprintf("zvboot", "  module: %s\n", c->ce_module);
+	grub_dprintf("zvboot", " default: %d\n", c->ce_default);
+	grub_dprintf("zvboot", "   index: %d\n", c->ce_index);
+}
+
+static void
+print_ba(const char *title, boot_args_t *ba)
+{
+	grub_dprintf("zvboot", "%s:\n", title);
+	grub_dprintf("zvboot", "      ba_dev: %s\n", STR(ba->ba_dev));
+	grub_dprintf("zvboot", "       ba_be: %s\n", STR(ba->ba_be));
+	grub_dprintf("zvboot", "     ba_kern: %s\n", STR(ba->ba_kern));
+	grub_dprintf("zvboot", " ba_kernargs: %s\n", STR(ba->ba_kernargs));
+	grub_dprintf("zvboot", "     ba_list: %d\n", ba->ba_list);
+	grub_dprintf("zvboot", "ba_debugargs: %s\n", STR(ba->ba_debugargs));
+	grub_dprintf("zvboot", "  ba_gnasher: %d\n", ba->ba_gnasher);
+}
+
+static char *
+trim_space(char *s)
+{
+	char *new = s;
+
+	/* Trim the beginning. */
+	while ((*new != '\0') && (*new == ' '))
+		new++;
+
+	/* Trim the end. */
+	char *e = new + grub_strlen(new) - 1;
+	while ((e > new) && (*e == ' ')) {
+		*e = '\0';
+		e--;
+	}
+
+	return (new);
+}
+
+static void
+parse_kv(char *s, char **k, char **v)
+{
+	*k = *v = NULL;
+
+	char *eq = grub_strchr(s, '=');
+	if (eq == NULL)
+		return;
+
+	*eq = '\0';
+	*k = trim_space(s);
+	*v = trim_space(eq + 1);
+}
+
+/*
+ * Walk a pybootmgmt menu.conf file.
+ */
+static void
+walk_config(int (*cb)(config_entry_t *, void *), void *arg)
+{
+	config_entry_t entry;
+	grub_memset(&entry, 0, sizeof (entry));
+
+	/*
+	 * This routine is destructive on the `config' buffer, so work
+	 * with a copy.
+	 */
+	char *copy = grub_strdup(config);
+	boolean_t valid_entry = B_FALSE;
+	char *p = copy;
+	int index = 0;
+	while ((p != NULL) && (*p != '\0')) {
+		char *next = grub_strchr(p, '\n');
+		if (next != NULL)
+			*next = '\0';
+
+		switch (p[0]) {
+		case '\0':
+			/* Blank. */
+			break;
+
+		case '#':
+			/* Comment. */
+			break;
+
+		case '[':
+			/* Start of section. */
+			p[grub_strlen(p) - 1] = '\0';
+
+			/* Callback for the previous entry. */
+			if (valid_entry) {
+				print_entry("Found BE", &entry);
+
+				if (cb(&entry, arg)) {
+					grub_free(copy);
+					return;
+				}
+			}
+
+			/* We ignore "meta" and "global" sections. */
+			valid_entry = !((grub_strcmp(p + 1, "meta") == 0)
+			    || (grub_strcmp(p + 1, "global") == 0));
+
+			/* Reset for the next entry. */
+			grub_free(entry.ce_title);
+			grub_free(entry.ce_rootdev);
+			grub_free(entry.ce_bootfs);
+			grub_free(entry.ce_bootargs);
+			grub_free(entry.ce_kernel);
+			grub_free(entry.ce_module);
+			grub_memset(&entry, 0, sizeof (entry));
+
+			if (valid_entry)
+				entry.ce_index = index++;
+			break;
+
+		default:;
+			char *k, *v;
+			parse_kv(p, &k, &v);
+
+#define	SET_FIELD(key, field) \
+	if (grub_strcmp(k, key) == 0) entry.field = grub_strdup(v);
+
+			SET_FIELD("title", ce_title);
+			SET_FIELD("bootfs", ce_bootfs);
+			SET_FIELD("kargs", ce_bootargs);
+			SET_FIELD("kernel", ce_kernel);
+			SET_FIELD("boot_archive", ce_module);
+#undef SET_FIELD
+
+			if ((grub_strcmp(k, "default") == 0) &&
+			    (grub_strcmp(v, "True") == 0)) {
+				entry.ce_default = 1;
+			}
+		}
+
+		if (next != NULL)
+			p = next + 1;
+	}
+
+	/* Callback for the final entry. */
+	if (valid_entry) {
+		print_entry("Found BE", &entry);
+
+		(void) cb(&entry, arg);
+	}
+
+	grub_free(copy);
+}
+
+static int search_address;
+static int search_removable;
+static char *found_device;
+
+static int
+select_boot_hook(const char *name, void *data)
+{
+	grub_dprintf("zvboot", "Looking for name %s\n", name);
+	/* Only zvblk devices can match. */
+	if (grub_strncmp(name, GRUB_ZVBLK_DEVICE,
+		grub_strlen(GRUB_ZVBLK_DEVICE)) != 0) {
+		grub_dprintf("zvboot",
+		    "%s is not a %s device -> not acceptable.\n",
+		    name, GRUB_ZVBLK_DEVICE);
+		return (0);
+	}
+
+	/* If specified, the unit number must match. */
+	if (search_address >= 0) {
+		char proposal[16];
+		int plen;
+		char *comma;
+
+		plen = grub_snprintf(proposal, sizeof (proposal),
+		    "%s%d", GRUB_ZVBLK_DEVICE, search_address);
+		/*
+		 * The name can be in a form zvblkN or zvblkN,gptM. In the
+		 * second case we want to match just the first part.
+		 *
+		 * If we find a comma in the provided name, we calculate
+		 * the length of the first part, otherwise we just use strlen()
+		 * for comparison against the length of our proposed device
+		 * string. This is necessary to prevent matching e.g zvblk1
+		 * with zvblk100.
+		 */
+		comma = grub_strchr(name, ',');
+		if ((plen != (comma ? (comma - name) : grub_strlen(name))) ||
+		    (grub_strncmp(name, proposal, plen) != 0)) {
+			grub_dprintf("zvboot",
+			    "wrong unit number (%s != %s) -> not acceptable.\n",
+			    name, proposal);
+			return (0);
+		}
+	}
+
+	/* From zvblk.c. */
+	extern uint64_t zvblk_disk_get_info(const char *, uint64_t);
+	uint64_t removable = zvblk_disk_get_info(name, ZVBLK_DEV_TYPE);
+	if (search_removable != removable) {
+		grub_dprintf("zvboot", "%s is %sremovable -> not acceptable.\n",
+		    name, removable ? "" : "not ");
+		return (0);
+	}
+
+	/* The device details match. */
+
+	/* If no filesystem, no point in trying to use this device. */
+	grub_device_t dev = grub_device_open(name);
+	if (dev == NULL) {
+		grub_dprintf("zvboot", "cannot open %s -> not acceptable.\n", name);
+		/* Error should not carry forward */
+		grub_errno = GRUB_ERR_NONE;
+		return (0);
+	}
+	grub_fs_t fs = grub_fs_probe(dev);
+	grub_device_close(dev);
+	if (fs == NULL) {
+		grub_dprintf("zvboot",
+		    "cannot determine filesystem of %s -> not acceptable.\n",
+		    name);
+		/* Error should not carry forward */
+		grub_errno = GRUB_ERR_NONE;
+		return (0);
+	}
+
+	/* Remember the filesystem type of the chosen boot device. */
+	boot_fstype = grub_strdup(fs->name);
+
+	found_device = grub_strdup(name);
+
+	grub_dprintf("zvboot", "boot device: %s, fs: %s.\n",
+	    found_device, boot_fstype);
+
+	return (1);
+}
+
+static char *
+select_boot_device(const char *boot_dev)
+{
+	int removable;
+	int address;
+	int valid = 0;
+	char *space;
+	const char *dev = boot_dev;
+
+	/*
+	 * Matching rules:
+	 * - "cdrom" means a CD with any address,
+	 * - "cdromN" means a CD with address N,
+	 * - "disk" means disk0,
+	 * - "diskN" means a disk with address N.
+	 */
+
+	/*
+	 * Iterate the ba_dev list (space separated) looking for a bootable
+	 * device.
+	 */
+	for (;;) {
+		space = grub_strchr(dev, ' ');
+		if (space != NULL)
+			*space = '\0';
+
+		if (grub_strncmp(dev, "cdrom", grub_strlen("cdrom")) == 0) {
+			removable = 1;
+			address = get_num(dev + grub_strlen("cdrom"),
+			    &valid);
+			if (!valid)
+				address = -1;
+		} else if (grub_strncmp(dev, "disk",
+		    grub_strlen("disk")) == 0) {
+			removable = 0;
+			address = get_num(dev + grub_strlen("disk"), &valid);
+			if (!valid)
+				address = 0;
+		}
+
+		if (space != NULL)
+			*space = ' ';
+
+		search_address = address;
+		search_removable = removable;
+		found_device = NULL;
+
+		grub_dprintf("zvboot", "Looking for boot device "
+		    "- address %d, removable %d.\n",
+		    search_address, search_removable);
+
+		grub_device_iterate(select_boot_hook, NULL);
+		if (found_device != NULL || space == NULL)
+			break;
+
+		for (dev = space; *dev == ' '; dev++)
+			;
+		if (*dev == '\0')
+			break;
+	}
+
+	if (found_device == NULL)
+		panic("Cannot determine boot device from '%s'.\n", boot_dev);
+
+	return (found_device);
+}
+
+static char *
+get_boot_device(boot_args_t *ba)
+{
+	uint64_t bootdevlen = 1024;
+	char *bootdev;
+	int err = 0;
+
+	if (ba->ba_dev != NULL)
+		return (grub_strdup(ba->ba_dev));
+
+	/* If no boot device specified, get the boot device based on bootpri. */
+
+	bootdev = grub_malloc(bootdevlen);
+
+	if (bootdev == NULL || (err = do_hypercall(ZVMM_CNTRL_EXTID,
+	    ZVCNTRL_GET_ZONEATTR, ZONE_ATTR_BOOT_DEVICE,
+	    bootdev, &bootdevlen)) != 0 || bootdevlen < 2) {
+		grub_free(bootdev);
+		bootdev = grub_strdup(DEFAULT_BOOT_DEVICE);
+		grub_dprintf("zvboot", "Using default boot device %s "
+		    "bootdev: err %d\n", DEFAULT_BOOT_DEVICE, err);
+	} else {
+		grub_dprintf("zvboot", "Boot device based on bootpri:\n");
+		grub_dprintf("zvboot", "     bootdev = %s\n", bootdev);
+	}
+
+	return (bootdev);
+}
+
+/*
+ * Options -L and -Z <dataset> are not checked as they are not considered as
+ * real boot arguments. They are rather meta arguments allowing a selection of
+ * desired boot entry.
+ */
+static boolean_t
+ba_is_empty(boot_args_t *ba)
+{
+	if (ba->ba_dev != NULL || ba->ba_kern != NULL ||
+	    ba->ba_kernargs != NULL || ba->ba_debugargs != NULL ||
+	    ba->ba_gnasher)
+		return (B_FALSE);
+
+	return (B_TRUE);
+}
+
+static void
+parse_bootargs(char *buf, boot_args_t *ba)
+{
+	char debugstr[BOOTARGS_MAX] = { 0 };
+	char *ds = debugstr;
+	char *cp = buf;
+
+	grub_memset(ba, 0, sizeof (boot_args_t));
+
+	if (cp == NULL)
+		return;
+
+	cp = eat_white(cp);
+
+	/*
+	 * Skip kz= arguments. These are for kzhost only. See kzhost's argument
+	 * parsing.
+	 */
+	if (grub_strncmp(cp, "kz=", grub_strlen("kz=")) == 0) {
+		cp = eat_word(cp, NULL, 0);
+		cp = eat_white(cp);
+	}
+	
+	/*
+	 * Handle various invocations:
+	 *
+	 * boot -L
+	 * boot -Z rpool/ROOT/be
+	 * boot cdrom
+	 * boot disk0 unix
+	 * boot unix
+	 *
+	 * All potentially with trailing kernel bootargs. In summary:
+	 *
+	 * boot [cdrom|cdrom[0-9]|disk|disk[0-9]] \
+	 *      [-L|-Z rpool/ROOT/be] [unix] [args]...
+	 */
+
+	/*
+	 * Including "zvboot_debug" anywhere in the boot string
+	 * enables zvboot debugging output. Typically this is done
+	 * using "zoneadm -z colony boot -- -B zvboot_debug=true".
+	 */
+	if (grub_strstr(cp, "zvboot_debug") != NULL) {
+		ds = grub_stpcpy(ds, " zvboot");
+	}
+	/*
+	 * Including "zvblk_debug" anywhere in the boot string
+	 * enables zvblk debugging output. Typically this is done
+	 * using "zoneadm -z colony boot -- -B zvblk_debug=true".
+	 */
+	if (grub_strstr(cp, "zvblk_debug") != NULL) {
+		ds = grub_stpcpy(ds, " zvblk");
+	}
+
+	/*
+	 * Including "zvboot_gnasher" anywhere in the boot string
+	 * enables the gnasher hypercall test tool. Typically this is
+	 * done using "zoneadm -z colony boot -- -B
+	 * zvboot_gnasher=true".
+	 */
+	if (grub_strstr(cp, "zvboot_gnasher") != NULL)
+		ba->ba_gnasher = B_TRUE;
+
+	do {
+		char word[LINELEN];
+		char *ocp = cp;
+
+		cp = eat_word(cp, word, sizeof (word));
+		cp = eat_white(cp);
+
+		if (word[0] == '\0')
+			break;
+
+		if (word[0] == '-') {
+			switch (word[1]) {
+			case 'L':
+				if (ba->ba_be != NULL) {
+					grub_printf("zvboot: "
+					    "both -Z and -L specified "
+					    "- assuming -L.\n");
+					ba->ba_be = NULL;
+				}
+				ba->ba_list = B_TRUE;
+				break;
+
+			case 'Z':
+				cp = eat_word(cp, word, sizeof (word));
+				cp = eat_white(cp);
+				ba->ba_be = grub_strdup(word);
+				if (ba->ba_list) {
+					grub_printf("zvboot: "
+					    "both -Z and -L specified "
+					    "- assuming -L.\n");
+					ba->ba_be = NULL;
+				}
+				break;
+
+			default:
+				/*
+				 * Anything other than -L or -Z must
+				 * be a kernel argument. That means
+				 * that we're done - the rest are all
+				 * kernel arguments.
+				 */
+				while ((cp != NULL) && (cp[0] != '\0')) {
+					word[grub_strlen(word)] = ' ';
+					cp = eat_word(cp, word, sizeof (word));
+					cp = eat_white(cp);
+				}
+				cp = NULL;
+				ba->ba_kernargs = grub_strdup(ocp);
+				break;
+			}
+		} else if ((ba->ba_dev == NULL) &&
+		    ((grub_strncmp(word, "cdrom",
+			    grub_strlen("cdrom")) == 0) ||
+			(grub_strncmp(word, "disk",
+			    grub_strlen("disk")) == 0))) {
+			/* This is a device name. */
+			ba->ba_dev = grub_strdup(word);
+		} else if (ba->ba_kern == NULL) {
+			/* This is the name of a kernel. */
+			ba->ba_kern = grub_strdup(word);
+		} else {
+			/*
+			 * Anything else is a standard kernel
+			 * argument.
+			 */
+			while ((cp != NULL) && (cp[0] != '\0')) {
+				word[grub_strlen(word)] = ' ';
+				cp = eat_word(cp, word, sizeof (word));
+				cp = eat_white(cp);
+			}
+			cp = NULL;
+			ba->ba_kernargs = grub_strdup(ocp);
+		}
+	} while (cp != NULL);
+
+	if (debugstr[0] != '\0')
+		ba->ba_debugargs = grub_strdup(debugstr);
+}
+
+static void
+process_debug_bootargs(boot_args_t *ba)
+{
+	extern grub_err_t grub_env_set(const char *, const char *);
+
+	if (ba->ba_debugargs != NULL)
+		(void) grub_env_set("debug", ba->ba_debugargs);
+	
+	if (ba->ba_gnasher)
+		gnasher();
+}
+
+static int
+get_host_bootargs_attr(int type, boot_args_t *ba)
+{
+	char buf[BOOTARGS_MAX];
+	size_t buf_sz = sizeof (buf);
+	int rc;
+
+	rc = do_hypercall(ZVMM_CNTRL_EXTID, ZVCNTRL_GET_ZONEATTR, type,
+	    buf, &buf_sz);
+	if (rc != 0)
+		return (rc);
+	
+	parse_bootargs(buf, ba);
+
+	return (0);
+}
+
+/*
+ * Retrieve transient and default host boot arguments. Default ones come from
+ * the zonecfg(8) "bootargs" property, transient were passed by a user/client
+ * to zoneadmd(8).
+ */
+static void
+get_host_bootargs(boot_args_t *ba, boot_args_t *ba_def)
+{
+	int rc;
+
+	if ((rc = get_host_bootargs_attr(ZONE_ATTR_BOOTARGS_TRAN, ba)) != 0 ||
+	    (rc = get_host_bootargs_attr(ZONE_ATTR_BOOTARGS_CFG, ba_def)) != 0)
+	{
+		/*
+		 * If the host does not know requested zone bootargs attributes
+		 * zvcntrl_get_zoneattr() returns EPERM. Do not panic as the
+		 * host may just be old.
+		 */
+		if (rc != EPERM) {
+			panic("Failed to read default/transient host bootargs "
+			    "with error %d", rc);
+		}
+		/*
+		 * The host is old and does not provide transient/default host
+		 * bootargs zone attributes. Fail back to the legacy behavior.
+		 * Retrieve zone boot arguments and mark them as transient, no
+		 * matter where they came from - this is for a compatibility
+		 * reason.
+		 */
+		if ((rc = get_host_bootargs_attr(ZONE_ATTR_BOOTARGS, ba)) != 0)
+			panic("Failed to read host bootargs with error %d", rc);
+	}
+
+	if (!ba_is_empty(ba) || ba->ba_list || ba->ba_be != NULL) {
+		process_debug_bootargs(ba);
+		print_ba("Transient host boot arguments", ba);
+	}
+}
+
+static int
+show_be(config_entry_t *entry, void *arg)
+{
+	size_t *nep = arg;
+
+	grub_printf("%ld %s", *nep + 1, entry->ce_title);
+	if (entry->ce_bootfs != NULL)
+		grub_printf(" (%s)", entry->ce_bootfs);
+	grub_printf("\n");
+	*nep += 1;
+	return (0);
+}
+
+static int
+match_be_index(config_entry_t *entry, void *arg)
+{
+	int index = *((int *)arg);
+
+	if (entry->ce_index == index) {
+		grub_memcpy(&chosen_entry, entry, sizeof (chosen_entry));
+		return (1);
+	}
+
+	return (0);
+}
+
+static void
+list_bes(void)
+{
+	int num;
+
+	for (;;) {
+		size_t nr_entries = 0;
+		int valid = 0;
+		char buf[10];
+
+		walk_config(show_be, &nr_entries);
+
+		if (nr_entries == 0)
+			panic("No entries to list.");
+
+		grub_printf("Select environment to boot: [ 1 - %ld ]:\n",
+		    nr_entries);
+
+		getline(buf, sizeof (buf));
+
+		num = get_num(buf, &valid);
+
+		if (valid && num >= 1 && num <= nr_entries)
+			break;
+
+		grub_printf("Invalid entry.\n");
+	}
+
+	grub_dprintf("zvboot", "entry %d chosen (index %d).\n", num, num-1);
+
+	num--;
+
+	walk_config(match_be_index, &num);
+}
+
+/*
+ * A matching BE is either one explicitly chosen via bootfs, or the default one.
+ */
+/*ARGSUSED*/
+static int
+match_be(config_entry_t *entry, void *arg)
+{
+	char *ba_be = arg;
+
+	/* Administrator selected BE. */
+	if (ba_be != NULL) {
+		if (grub_strcmp(entry->ce_bootfs, ba_be) == 0) {
+			grub_memcpy(&chosen_entry, entry, sizeof (chosen_entry));
+			return (1);
+		}
+		return (0);
+	}
+
+	if (entry->ce_default) {
+		grub_memcpy(&chosen_entry, entry, sizeof (chosen_entry));
+		return (1);
+	}
+
+	return (0);
+}
+
+static void
+load_module(const char *device, const char *pool, const char *module_path)
+{
+	/*
+	 * Load module if present.
+	 */
+	if (module_path[0] == '\0')
+		return;
+
+	grub_file_t module;
+	if ((module = file_open(device, pool, module_path)) == NULL) {
+		/*
+		 * If we couldn't find a boot archive and this is a ramdisk,
+		 * assume that the ramdisk _is_ the boot archive and continue on
+		 * with it.
+		 */
+		if (grub_strcmp(device, GRUB_RAMDISK_DEVICE) == 0)
+			return;
+
+		panic("Failed to open boot_archive: '%s' (%d)",
+		    module_path, grub_errno);
+	}
+
+	grub_printf("reading module %s...", module_path);
+
+	module_size = grub_file_size(module);
+	if (module_size == 0)
+		panic("Zero sized module %s", module_path);
+
+	if ((module_bytes = page_alloc(module_size)) == NULL)
+		panic("Cannot allocate %ld bytes for module.", module_size);
+	grub_dprintf("zvboot", "module is %ld (0x%lx) bytes at %p.\n",
+	    module_size, module_size, module_bytes);
+
+	if (file_read(module, module_bytes, module_size) != module_size)
+		panic("Read of module file %s failed", module_path);
+
+	grub_file_close(module);
+
+	grub_printf("done.\n");
+
+	/* Add the boot_archive as a ramdisk. */
+	memdisk_set(module_bytes, module_size);
+}
+
+/*
+ * Load kernel from disk.
+ */
+static void
+load_kernel(const char *device, const char *pool, const char *kernel_path)
+{
+	grub_printf("reading kernel file %s...", kernel_path);
+
+	grub_file_t kernel;
+	if ((kernel = file_open(device, pool, kernel_path)) == NULL)
+		panic("Cannot open kernel file: %s (%d)",
+		    kernel_path, grub_errno);
+
+	grub_ssize_t kernel_size = grub_file_size(kernel);
+	if (kernel_size == 0)
+		panic("Zero sized kernel %s", kernel_path);
+
+	if ((kernel_bytes = page_alloc(kernel_size)) == NULL)
+		panic("Cannot allocate %ld bytes for kernel.", kernel_size);
+	grub_dprintf("zvboot", "kernel is %ld (0x%lx) bytes at %p.\n",
+	    kernel_size, kernel_size, kernel_bytes);
+
+	if (file_read(kernel, kernel_bytes, kernel_size) != kernel_size)
+		panic("Read of kernel file %s failed", kernel_path);
+	grub_file_close(kernel);
+
+	grub_printf("done.\n");
+
+	path_to_kernel = (char *)kernel_path;
+}
+
+/*
+ * Lifted from grub_cmd_zfs_bootfs().
+ */
+static char *
+set_zfs_bootargs(const char *device, const char *dataset)
+{
+	static char zfs_args[BOOTARGS_MAX];
+	char work[BOOTARGS_MAX];
+	char *zp = zfs_args;
+
+	zfs_args[0] = '\0';
+
+	grub_device_t dev;
+	dev = grub_device_open(device);
+	if (dev == NULL) {
+		grub_dprintf("zvboot", "Cannot open device %s (%d).\n",
+		    device, grub_errno);
+		return (NULL);
+	}
+
+	/* Strip the pool name, if present. */
+	const char *slash, *fs;
+	if ((dataset[0] != '/') &&
+	    ((slash = grub_strchr(dataset, '/')) != NULL))
+		fs = slash;
+	else
+		fs = dataset;
+
+	grub_err_t err;
+	grub_uint64_t mdnobj;
+	err = grub_zfs_getmdnobj(dev, fs, &mdnobj);
+	if (err != 0) {
+		grub_dprintf("zvboot", "Cannot find mdnobj for "
+		    "filesystem %s on device %s (%d).\n",
+		    fs, device, err);
+		grub_device_close(dev);
+		return (NULL);
+	}
+
+	char *poolname = get_poolname(device);
+	if (poolname == NULL) {
+		grub_dprintf("zvboot", "Cannot find poolname for %s.\n",
+		    device);
+		grub_device_close(dev);
+		return (NULL);
+	}
+	
+	grub_snprintf(work, sizeof (work), " -B zfs-bootfs=%s/%ld",
+	    poolname, mdnobj);
+	zp = grub_stpcpy(zp, work);
+	grub_free(poolname);
+
+	/*
+	 * If the pool was previously imported somewhere else, the bootpath
+	 * in the vdev label is useless.  Kernel zones are a very controlled
+	 * environment - we know what the physical path is.  That is, we need to
+	 * translate "zvblk0,gpt2" to "/zvnex/zvblk@0:b".
+	 */
+	const char letters[] = "abcdefgh";
+	const int zvblklen = grub_strlen("zvblk");
+	char bootpath[MAXPATHLEN];
+	int inst, partnum;
+	char *p;
+
+	if (grub_strncmp(device, "zvblk", zvblklen) != 0) {
+		grub_dprintf("zvboot", "Invalid device %s.\n", device);
+		grub_device_close(dev);
+		return (NULL);
+	}
+
+	inst = get_num(device + zvblklen, NULL);
+
+	if ((p = grub_strchr(device + zvblklen, ',')) == NULL) {
+		grub_dprintf("zvboot", "No partition in %s.\n", device);
+		grub_device_close(dev);
+		return (NULL);
+	}
+	p++;
+	if (grub_strncmp(p, "gpt", grub_strlen("gpt")) != 0) {
+		grub_dprintf("zvboot", "Invalid partition in %s.\n", device);
+		grub_device_close(dev);
+		return (NULL);
+	}
+
+	partnum = get_num(p + grub_strlen("gpt"), NULL);
+	if (partnum < 1 || partnum > grub_strlen(letters)) {
+		grub_dprintf("zvboot", "Invalid gpt partition %s in %s.\n", p,
+		    device);
+		grub_device_close(dev);
+		return (NULL);
+	}
+
+	grub_snprintf(bootpath, sizeof (bootpath), "/zvnex/zvblk@%d:%c", inst,
+	    letters[partnum - 1]);
+	grub_snprintf(work, sizeof (work), " -B bootpath=\"%s\"", bootpath);
+	zp = grub_stpcpy(zp, work);
+
+	char *nvlist;
+	err = grub_zfs_fetch_nvlist(dev, &nvlist);
+	if (err != 0) {
+		grub_dprintf("zvboot", "Cannot fetch nvlist for %s.\n",
+		    device);
+		grub_device_close(dev);
+		return (NULL);
+	}
+	grub_device_close(dev);
+
+	grub_uint64_t devguid;
+	if (grub_zfs_nvlist_lookup_uint64(nvlist, ZPOOL_CONFIG_GUID,
+		&devguid) == 0) {
+		grub_dprintf("zvboot", "Cannot find GUID for %s.\n",
+		    device);
+		grub_free(nvlist);
+		return (NULL);
+	}
+
+	char *nv = grub_zfs_nvlist_lookup_nvlist(nvlist,
+	    ZPOOL_CONFIG_VDEV_TREE);
+	if (nv == NULL) {
+		grub_dprintf("zvboot", "Cannot find vdev in nvlist for %s.\n",
+		    device);
+		grub_free(nvlist);
+		return (NULL);
+	}
+
+	/* From zfsinfo.c. */
+	extern grub_err_t get_bootpath(char *, grub_uint64_t, char **, char **);
+	char *cfg_bootpath, *devid;
+	if (get_bootpath(nv, devguid, &cfg_bootpath, &devid) == GRUB_ERR_NONE) {
+		if (grub_strcmp(bootpath, cfg_bootpath) != 0) {
+			grub_dprintf("zvboot",
+			    "Preferring calculated bootpath (%s) to that from "
+			    "the pool (%s).\n", bootpath, cfg_bootpath);
+		}
+
+		if (devid != NULL) {
+			grub_snprintf(work, sizeof (work),
+			    " -B diskdevid=\"%s\"", devid);
+			zp = grub_stpcpy(zp, work);
+		}
+	}
+
+	grub_free(nv);
+	grub_free(nvlist);
+
+	return (zfs_args);
+}
+
+static void
+set_bootargs(const char *device, const char *dataset, const char *inargs,
+    zv_boot_info_t *binfo)
+{
+	char *bp;
+
+	if ((boot_args = grub_malloc(BOOTARGS_MAX)) == NULL)
+		panic("Cannot allocate %d bytes for boot args.", BOOTARGS_MAX);
+		   
+	boot_args[0] = '\0';
+	bp = boot_args;
+
+	/*
+	 * Boot arguments specified at boot time override anything in
+	 * the grub configuration file.
+	 */
+	if (inargs != NULL)
+		bp = grub_stpcpy(bp, inargs);
+
+	if (grub_strcmp(boot_fstype, "zfs") == 0) {
+		char *zfs_args = set_zfs_bootargs(device, dataset);
+
+		bp = grub_stpcpy(bp, zfs_args);
+	}
+
+	if (grub_strstr(boot_args, "zvmm_platform=true") == NULL) {
+		bp = grub_stpcpy(bp, " -B zvmm_platform=true");
+	}
+
+	if (grub_strstr(boot_args, "boot-max-ncpus=") == NULL) {
+		char ncpu[5];
+
+		(void) grub_snprintf(ncpu, sizeof (ncpu) - 1, "%d",
+		    binfo->zv_ncpu);
+		bp = grub_stpcpy(bp, " -B boot-max-ncpus=");
+		bp = grub_stpcpy(bp, ncpu);
+	}
+
+#if defined(amd64)
+	if (grub_strstr(boot_args, "console=ttya") == NULL)
+		bp = grub_stpcpy(bp, " -B console=ttya");
+#endif /* amd64 */
+
+	grub_dprintf("zvboot", "final boot_args: %s\n", boot_args);
+}
+
+static void
+open_grub_configuration(const char *boot_dev)
+{
+	grub_file_t menu_lst;
+	grub_ssize_t sz;
+
+	menu_lst = file_open(boot_dev, "/", config_file_path);
+	if (menu_lst == NULL) {
+		grub_printf("zvboot: cannot open %s, using default "
+		    "configuration.\n", config_file_path);
+		config = "";
+		return;
+	}
+	sz = grub_file_size(menu_lst);
+
+	grub_dprintf("zvboot", "Config file is %ld bytes.\n", sz);
+
+	config = grub_malloc(sz + 1);
+
+	if (file_read(menu_lst, config, sz) != sz)
+		panic("Read of %s failed", config_file_path);
+	grub_file_close(menu_lst);
+
+	config[sz] = '\0';
+}
+
+static void
+select_be(boot_args_t *ba)
+{
+	grub_memset(&chosen_entry, 0, sizeof (chosen_entry));
+
+	if (ba->ba_list)
+		list_bes();
+	else
+		walk_config(match_be, (void *)ba->ba_be);
+}
+
+/*
+ * Select arguments to boot the kernel with. The priority of boot arguments is
+ * following: Transient host arguments, transient guest arguments (stored in the
+ * "Solaris_reboot_transient" entry), common entry arguments, default host
+ * arguments (zonecfg property "bootargs").
+ */
+static boot_args_t *
+select_bootargs(boot_args_t *ba_htrans, boot_args_t *ba_guest,
+    boot_args_t *ba_hdef)
+{
+	if (!ba_is_empty(ba_htrans) || ba_htrans->ba_list ||
+	    ba_htrans->ba_be != NULL) {
+
+		select_be(ba_htrans);
+		if (chosen_entry.ce_title == NULL)
+			return (NULL);
+		if (!ba_is_empty(ba_htrans))
+			return (ba_htrans);
+		/*
+		 * If a host user called zoneadm reboot just with -L or -Z
+		 * <dataset> then we proceed with arguments from the grub entry
+		 * and then with the default host arguments.
+		 */
+		parse_bootargs(chosen_entry.ce_bootargs, ba_guest);
+
+		if (!ba_is_empty(ba_guest))
+			return (ba_guest);
+
+		return (ba_hdef);
+	}
+
+	/*
+	 * The host invoked (re)boot without any arguments OR 'reboot' was
+	 * called within the ba_guest without or with arguments (transient
+	 * ba_guest arguments).
+	 */
+
+	walk_config(match_be, NULL);
+	if (chosen_entry.ce_title == NULL)
+		return (NULL);
+
+	/*
+	 * In order to prevent a chaining of -L and -Z <dataset> options we
+	 * permit them only in the transient entry. All other occurences are
+	 * ignored.
+	 */
+
+	if (grub_strcmp(chosen_entry.ce_title,
+	    "Solaris_reboot_transient") == 0) {
+		parse_bootargs(chosen_entry.ce_bootargs, ba_guest);
+		select_be(ba_guest);
+		if (chosen_entry.ce_title == NULL)
+			return (NULL);
+		if (!ba_is_empty(ba_guest))
+			return (ba_guest);
+		grub_free(ba_guest->ba_be);
+	}
+
+	parse_bootargs(chosen_entry.ce_bootargs, ba_guest);
+
+	if (!ba_is_empty(ba_guest))
+		return (ba_guest);
+
+	return (ba_hdef);
+}
+
+void
+do_grubby_stuff(zv_boot_info_t *binfo)
+{
+	/*
+	 * Provide some heap for grub_malloc().
+	 *
+	 * Be careful using any grub_* functions before this point, as
+	 * they will not be able to allocate any memory.
+	 */
+#define	HEAP_SIZE	(MBYTE(2))
+	void *heap = page_alloc(HEAP_SIZE);
+	grub_mm_init_region(heap, HEAP_SIZE);
+
+	boot_args_t *ba;
+	boot_args_t ba_htrans = { 0 };
+	boot_args_t ba_hdef = { 0 };
+	boot_args_t ba_guest = { 0 };
+
+	get_host_bootargs(&ba_htrans, &ba_hdef);
+
+	char *boot_device = get_boot_device(&ba_htrans);
+
+	/* After `get_bootargs' as that might enable debug output. */
+	grub_dprintf("zvboot", "I'm the new zvboot!\n");
+	grub_dprintf("zvboot", "last_phys = %p\n", (void *)last_phys);
+	grub_dprintf("zvboot", "heap is 0x%lx bytes at %p\n", HEAP_SIZE, heap);
+	
+	/* If there is a ramdisk loaded, declare it. */
+	if ((binfo->zv_ramdisk_start != 0) &&
+	    (binfo->zv_ramdisk_size > 0)) {
+		memdisk_set(binfo->zv_ramdisk_start,
+		    binfo->zv_ramdisk_size);
+	}
+
+	/* Discover the disks available. */
+	extern void zvblk_init(void);
+	zvblk_init();
+
+	/* Declare the partition schemes. */
+#if defined(amd64)
+	extern struct grub_partition_map *_grub_msdos_partition_map;
+	grub_partition_map_register(_grub_msdos_partition_map);
+	extern struct grub_partition_map *_grub_sun_pc_partition_map;
+	grub_partition_map_register(_grub_sun_pc_partition_map);
+#endif /* amd64 */
+	extern struct grub_partition_map *_grub_sun_partition_map;
+	grub_partition_map_register(_grub_sun_partition_map);
+	extern struct grub_partition_map *_grub_gpt_partition_map;
+	grub_partition_map_register(_grub_gpt_partition_map);
+
+	/* Declare the filesystems. */
+	extern struct grub_fs *_grub_iso9660_fs;
+	grub_fs_register(_grub_iso9660_fs);
+	extern struct grub_fs *_grub_zfs_fs;
+	grub_fs_register(_grub_zfs_fs);
+	extern struct grub_fs *_grub_ufs_fs;
+	grub_fs_register(_grub_ufs_fs);
+
+	/* Declare the GZIP file reader. */
+	extern grub_file_t grub_gzio_open (grub_file_t, enum grub_file_type);
+	grub_file_filter_register (GRUB_FILE_FILTER_GZIO, grub_gzio_open);
+
+	/*
+	 * If a ramdisk was specified, load the configuration file,
+	 * kernel, etc. from it. Otherwise choose a boot device,
+	 * presumably a disk or cdrom.
+	 */
+	grub_device_t dev;
+	if ((dev = grub_device_open(GRUB_RAMDISK_DEVICE)) != 0) {
+		boot_device_name = GRUB_RAMDISK_DEVICE;
+		grub_device_close(dev);
+	} else {
+		/*
+		 * Failure to open the ramdisk should not carry
+		 * forward.
+		 */
+		grub_errno = GRUB_ERR_NONE;
+
+		boot_device_name = select_boot_device(boot_device);
+	}
+
+	open_grub_configuration(boot_device_name);
+
+	ba = select_bootargs(&ba_htrans, &ba_guest, &ba_hdef);
+	if (ba != NULL) {
+		process_debug_bootargs(ba);
+		print_ba("Chosen boot arguments", ba);
+	}
+
+	if (chosen_entry.ce_title != NULL)
+		print_entry("Chosen BE", &chosen_entry);
+	else 
+		grub_printf("zvboot: No 'default' entry, using default "
+		    "configuration.\n");
+
+	/*
+	 * Complete the entry by merging grub entry arguments with provided or
+	 * found arguments. Provided arguments have a higher priority. If we
+	 * failed to find the entry in the grub menu (ba is NULL) provided
+	 * arguments cannot be trusted and so system default values will be
+	 * used.
+	 */
+
+	complete_entry(&chosen_entry, boot_device_name, ba);
+	print_entry("Completed BE", &chosen_entry);
+
+	grub_printf("Boot device: %s  File and args: %s%s%s\n",
+	    boot_device, STR(chosen_entry.ce_kernel),
+	    chosen_entry.ce_kernel != NULL ? " " : "",
+	    STR(chosen_entry.ce_bootargs));
+
+	load_module(chosen_entry.ce_rootdev, chosen_entry.ce_bootfs,
+	    chosen_entry.ce_module);
+
+	/*
+	 * If we can mount the boot_archive, load unix from
+	 * it. Otherwise, load it from the disk.
+	 */
+	grub_device_t boot_archive = grub_device_open(GRUB_RAMDISK_DEVICE);
+	char *unixdev = chosen_entry.ce_rootdev;
+	if (boot_archive != NULL) {
+		if (grub_fs_probe(boot_archive) != NULL)
+			unixdev = GRUB_RAMDISK_DEVICE;
+		grub_device_close(boot_archive);
+	}
+
+	load_kernel(unixdev, chosen_entry.ce_bootfs, chosen_entry.ce_kernel);
+
+	set_bootargs(chosen_entry.ce_rootdev, chosen_entry.ce_bootfs,
+	    chosen_entry.ce_bootargs, binfo);
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/zvload.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/zvload.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,292 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2024, Oracle and/or its affiliates.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <sys/types.h>
+#include <sys/varargs.h>
+#include <sys/elf.h>
+#include <sys/elf_notes.h>
+#ifdef amd64
+#include <sys/archsystm.h>
+#include <sys/x86_archext.h>
+#include <sys/controlregs.h>
+#endif /* amd64 */
+
+#include <grub/misc.h>
+#include <grub/mm.h>
+
+#include "zv_mem.h"
+#include "zv_asm.h"
+#include "zvcons.h"
+#include "zvload.h"
+#include "verify.h"
+
+#ifdef amd64
+/*
+ * from Solaris kernel source for now
+ */
+#define	_BOOT_TARGET_amd64
+#include <sys/bootinfo.h>
+#endif /* amd64 */
+
+#include <sys/zvmm/zvmm_hcall.h>
+#include <sys/zvmm/zvmm_mach_hcall.h>
+
+/*
+ * values of command line arguments
+ */
+char *boot_args;	/* arguments passed to the 64 bit kernel */
+char *path_to_kernel;
+
+char *kernel_bytes;	/* 64 bit ELF kernel that is loaded */
+char *module_bytes;	/* module file that is loaded */
+size_t module_size;
+
+/*
+ * from ELF - virt addr for kernel nucleus 8Meg for amd64
+ */
+uint64_t kernel_virt;
+
+#ifdef amd64
+static struct boot_modules boot_module;
+static struct xboot_info xboot;
+#endif /* amd64 */
+
+#define	PGETBYTES(off) (void *)(kernel_bytes + (off))
+
+/*
+ * Parse the kernel ELF file for program information and copy the kernel
+ * text and data segments to their physical memory locations.
+ */
+static void
+elfload64(void)
+{
+	Elf64_Ehdr *eh;
+	Elf64_Phdr *phdr;
+	caddr_t allphdrs;
+	int i;
+	char *src;
+	char *dst;
+	uchar_t *ident;
+
+	ident = PGETBYTES(0);
+	if (ident == NULL)
+		panic("Cannot read kernel ELF header");
+
+	if (ident[EI_MAG0] != ELFMAG0 || ident[EI_MAG1] != ELFMAG1 ||
+	    ident[EI_MAG2] != ELFMAG2 || ident[EI_MAG3] != ELFMAG3)
+		panic("malformed kernel ELF file");
+
+	if (ident[EI_CLASS] == ELFCLASS64)
+		eh = PGETBYTES(0);
+	else
+		panic("kernel not ELF64");
+
+	if (eh->e_type != ET_EXEC)
+		panic("not ET_EXEC, e_type = 0x%x", eh->e_type);
+
+	if (eh->e_phnum == 0 || eh->e_phoff == 0)
+		panic("no program headers");
+
+	/*
+	 * Get the program headers.
+	 */
+	allphdrs = PGETBYTES(eh->e_phoff);
+
+	/*
+	 * Next look for interesting program headers.
+	 */
+	for (i = 0; i < eh->e_phnum; i++) {
+		/*LINTED [ELF program header alignment]*/
+		phdr = (Elf64_Phdr *)(allphdrs + eh->e_phentsize * i);
+
+		/*
+		 * Dynamically-linked executables are not expected nor
+		 * usable.
+		 */
+		if (phdr->p_type == PT_INTERP) {
+			panic("Illegal PT_INTERP section.");
+		}
+
+		/*
+		 * At this point we only care about PT_LOAD segments.
+		 */
+		if (phdr->p_type != PT_LOAD)
+			continue;
+
+		if (phdr->p_flags == (PF_R | PF_W) && phdr->p_vaddr == 0)
+			panic("warning: krtld reloc info?");
+
+		/*
+		 * If memory size is zero just ignore this header.
+		 */
+		if (phdr->p_memsz == 0)
+			continue;
+
+#ifdef amd64
+		grub_dprintf("zvboot", "p: %p, v: %p\n",
+		    (void *)phdr->p_paddr, (void *)phdr->p_vaddr);
+		/*
+		 * If load address 1:1 then ignore this header, it's for dboot.
+		 */
+		if (phdr->p_paddr == phdr->p_vaddr)
+			continue;
+
+		/*
+		 * Copy the data to kernel area.
+		 */
+		switch (phdr->p_paddr) {
+		case MBYTE(4): /* KTEXT_PHYS */
+			/* Kernel text loads at PA 4M. */
+			kernel_virt = phdr->p_vaddr;
+			break;
+		case MBYTE(12): /* KDATA_PHYS */
+			/* Kernel data loads at PA 12M. */
+			break;
+		default:
+			panic("Bad p_paddr for nucleus segment");
+		}
+		dst = (char *)phdr->p_paddr;
+#endif /* amd64 */
+
+		src = (char *)PGETBYTES(phdr->p_offset);
+		grub_dprintf("zvboot", "elf: move 0x%lx from %p to %p\n",
+		    phdr->p_filesz, src, dst);
+		grub_memcpy(dst, src, phdr->p_filesz);
+	}
+}
+
+/*
+ * Boot a kernel zone
+ */
+void
+boot(zv_boot_info_t *zv_boot_info)
+{
+	char *pp, *cp;
+
+	/*
+	 * Make sure memory allocator is aligned.
+	 */
+	last_phys = ROUND_UP((uintptr_t)zv_boot_info->free_mem_start, PGSIZE);
+
+	/*
+	 * Read in the kernel and module files.
+	 */
+	extern void do_grubby_stuff(zv_boot_info_t *zv_boot_info);
+	do_grubby_stuff(zv_boot_info);
+
+	/*
+	 * Verify the kernel module before loading.
+	 */
+	(void) verify_module((uchar_t *)kernel_bytes);
+
+	/*
+	 * Copy the kernel text/data from the ELF file to its desired
+	 * RAM.
+	 */
+	elfload64();
+
+#ifdef amd64
+	/*
+	 * Fill in xboot info.
+	 */
+	grub_memset(&xboot, 0, sizeof (xboot));
+	xboot.bi_phys_install = (uint64_t)zv_boot_info->zv_memlist;
+
+	/*
+	 * Record where the boot module is in memory.
+	 */
+	if (module_bytes != NULL) {
+		boot_module.bm_addr = (uint64_t)module_bytes;
+		boot_module.bm_size = module_size;
+	} else {
+		boot_module.bm_addr =
+		    (uint64_t)zv_boot_info->zv_ramdisk_start;
+		boot_module.bm_size = zv_boot_info->zv_ramdisk_size;
+	}
+	xboot.bi_modules = (uint64_t)&boot_module;
+	xboot.bi_module_cnt = 1;
+
+	/*
+	 * Build the kernel command line.
+	 */
+	pp = page_alloc(PGSIZE);
+	cp = grub_stpcpy(pp, path_to_kernel);
+	if (boot_args != NULL) {
+		cp = grub_stpcpy(cp, " ");
+		cp = grub_stpcpy(cp, boot_args);
+	}
+	xboot.bi_cmdline = (uint64_t)pp;
+
+	grub_dprintf("zvboot", "kernel command line: %s\n", pp);
+
+	/*
+	 * Add high memory page table entries.
+	 */
+	uint64_t off;
+	xboot.bi_top_page_table = getcr3() & ~0xffful;
+	xboot.bi_pt_window = (uint64_t)page_alloc(PGSIZE);
+	/* size is 2 * KERN_NUCLEUS_SIZE */
+	for (off = 0; off < 4 * MBYTE(4); off += MBYTE(2)) {
+		grub_dprintf("zvboot", "map %p at %p\n",
+		    (void *)(MBYTE(4) + off), (void *)(kernel_virt + off));
+		map_pa_at_va(MBYTE(4) + off, (void *)(kernel_virt + off), 1);
+	}
+	xboot.bi_pte_to_pt_window =
+	    (uint64_t)find_pte((uintptr_t)xboot.bi_pt_window, 0);
+
+	/*
+	 * Finish off the xboot data.
+	 */
+	xboot.bi_rsvdmem = NULL;	/* no BIOS memory */
+	xboot.bi_pcimem = NULL;		/* no device memory */
+	xboot.bi_uefi_systab = NULL;
+	xboot.bi_smbios_entry = NULL;
+	xboot.bi_smbios_entry_len = 0;
+	xboot.bi_framebuffer_info = 0;
+	xboot.bi_mb_info = NULL;	/* since we didn't use grub */
+
+	xboot.bi_use_largepage = 1;
+	xboot.bi_use_pae = 1;
+	xboot.bi_use_nx = 1;
+	xboot.bi_use_pge = 1;
+	xboot.bi_kseg_size = (uint64_t)MBYTE(8);
+	xboot.bi_next_paddr = (uint64_t)last_phys;
+	xboot.bi_next_vaddr = (uint64_t)last_phys;
+
+	grub_dprintf("zvboot", "xboot.bi_cmdline = %p\n",
+	    (void *)xboot.bi_cmdline);
+	grub_dprintf("zvboot", "xboot.bi_next_paddr = %p\n",
+	    (void *)xboot.bi_next_paddr);
+	grub_dprintf("zvboot", "xboot.bi_pt_window = %p\n",
+	    (void *)xboot.bi_pt_window);
+	grub_dprintf("zvboot", "xboot.bi_pte_to_pt_window = %p\n",
+	    (void *)xboot.bi_pte_to_pt_window);
+	grub_dprintf("zvboot", "boot_module.bm_addr = %p\n",
+	    (void *)boot_module.bm_addr);
+	grub_dprintf("zvboot", "boot_module.bm_size = 0x%x\n",
+	    boot_module.bm_size);
+
+	/* That's it, just enter the kernel. */
+	grub_dprintf("zvboot", "Entering kernel at VA = %p\n",
+	    (void *)kernel_virt);
+
+	void (*entry_addr)(struct xboot_info *);
+	entry_addr = (void (*)(struct xboot_info *))kernel_virt;
+	entry_addr(&xboot);
+#endif /* amd64 */
+}
diff -r 68f95e015346 usr/src/grub/src/contrib/zvboot/zvload.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/contrib/zvboot/zvload.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,39 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef	_ZVLOAD_H
+#define	_ZVLOAD_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#include <sys/zvmm/zvmm_mach_hcall.h>
+
+extern char *boot_args;		/* arguments passed to the 64 bit kernel */
+extern char *path_to_kernel;
+
+extern char *kernel_bytes;	/* 64 bit ELF kernel that is loaded */
+extern char *module_bytes;	/* module file that is loaded */
+extern size_t module_size;
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _ZVLOAD_H */
diff -r 68f95e015346 usr/src/grub/src/docs/man/grub-version-check.h2m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/docs/man/grub-version-check.h2m	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,2 @@
+[NAME]
+grub-version-check \- compare two version.lst and estabilish the most recent 
diff -r 68f95e015346 usr/src/grub/src/grub-core/lib/libgcrypt_vboot/README
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/grub-core/lib/libgcrypt_vboot/README	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,40 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+README
+------
+Headers in this directory are solely used to build Solaris Verified Boot
+functionality into GRUB multiboot2 for EFI.
+
+This also requires:
+* Gcrypt SHA-256 and
+* (for RSA), the Multi-precision Integer (MPI or bignum) library.
+
+GRUB has customized both Gcrypt and MPI for their own use.
+
+
+Gcrypt header file include structure
+------------------------------------
+g10lib.h
+	types.h
+	gcrypt.h
+		gpg_error.h
+			stddef.h
+		stdarg.h
+		string.h
+		...
diff -r 68f95e015346 usr/src/grub/src/grub-core/lib/libgcrypt_vboot/crypto.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/grub-core/lib/libgcrypt_vboot/crypto.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,39 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Emulate required libgcrypt functions for use by the MPI library in GRUB.
+ * This for Solaris Verified boot's use of libgcrypt functions in multiboot.
+ */
+
+/* gcrypt.h contains a subset of crypto.h definitions */
+
+#ifndef _CRYPTO_H
+#define	_CRYPTO_H
+
+#include <gcrypt.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _CRYPTO_H */
diff -r 68f95e015346 usr/src/grub/src/grub-core/lib/libgcrypt_vboot/gcrypt.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/grub-core/lib/libgcrypt_vboot/gcrypt.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,112 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2009, Free Software Foundation, Inc.
+ *  Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Emulate required libgcrypt functions for use by the MPI library in GRUB.
+ * This for Solaris Verified boot's use of libgcrypt functions in multiboot.
+ */
+
+#ifndef _GCRYPT_H
+#define	_GCRYPT_H
+
+#include <sys/types.h>	/* size_t */
+/* gpg_err_code_t, gpg_error_t, gcry_error_t, gcry_err_code_t:  */
+#include <gpg-error.h>
+#include <string.h>	/* strcasecmp() */
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* Different formats of external big integer representation. */
+enum gcry_mpi_format {
+	GCRYMPI_FMT_NONE = 0,
+	GCRYMPI_FMT_STD = 1, /* Twos complement stored without length. */
+	GCRYMPI_FMT_PGP = 2, /* As used by OpenPGP (unsigned only). */
+	GCRYMPI_FMT_SSH = 3, /* As used by SSH (like STD but with length). */
+	GCRYMPI_FMT_HEX = 4, /* Hex format. */
+	GCRYMPI_FMT_USG = 5  /* Like STD but unsigned. */
+};
+
+/* Flags used for creating big integers. */
+enum gcry_mpi_flag {
+	GCRYMPI_FLAG_SECURE = 1, /* Allocate the number in "secure" memory. */
+	/*
+	 * The number is not a real one but just a way to store some bytes.
+	 * This is useful for encrypted big integers.
+	 */
+	GCRYMPI_FLAG_OPAQUE = 2
+};
+
+typedef enum gcry_random_level {
+	GCRY_WEAK_RANDOM = 0,
+	GCRY_STRONG_RANDOM = 1,
+	GCRY_VERY_STRONG_RANDOM = 2
+} gcry_random_level_t;
+
+enum gcry_ctl_cmds {
+	GCRYCTL_DUMMY_UNUSED
+};
+
+typedef struct gcry_md_handle {
+	void *dummy_unused;
+} *gcry_md_hd_t;
+
+typedef struct gcry_sexp {
+	void *dummy_unused;
+} *gcry_sexp_t;
+
+
+struct gcry_mpi;	/* defined in mpi.h */
+typedef struct gcry_mpi *gcry_mpi_t;
+
+/* gcrypt_util.c */
+void *_gcry_malloc(size_t n);
+void *_gcry_calloc(size_t n, size_t m);
+void _gcry_free(void *p);
+void *_gcry_xrealloc(void *p, size_t n);
+void _gcry_check_heap(const void *p);
+void *_gcry_xmalloc(size_t n);
+void *_gcry_malloc_secure(size_t n);
+void *_gcry_xmalloc_secure(size_t n);
+void *_gcry_xcalloc(size_t n, size_t m);
+void *_gcry_xcalloc_secure(size_t n, size_t m);
+int _gcry_is_secure(const void *a);
+void _gcry_log_bug(const char *fmt, ...);
+void _gcry_log_printf(const char *fmt, ...);
+void _gcry_assert_failed(const char *expr, const char *file, int line,
+    const char *func);
+void *_gcry_random_bytes(size_t nbytes, enum gcry_random_level level);
+void *_gcry_random_bytes_secure(size_t nbytes, enum gcry_random_level level);
+void _gcry_create_nonce(void *buffer, size_t length);
+
+/* Gcrypt MPI functions used by Verified Boot */
+gcry_mpi_t gcry_mpi_new(unsigned int nbits);
+void gcry_mpi_release(gcry_mpi_t a);
+int gcry_mpi_cmp(const gcry_mpi_t u, const gcry_mpi_t v);
+void gcry_mpi_powm(gcry_mpi_t w, const gcry_mpi_t b, const gcry_mpi_t e,
+	const gcry_mpi_t m);
+gcry_error_t gcry_mpi_scan(gcry_mpi_t *ret_mpi, enum gcry_mpi_format format,
+	const void *buffer, size_t buflen, size_t *nscanned);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _GCRYPT_H */
diff -r 68f95e015346 usr/src/grub/src/grub-core/lib/libgcrypt_vboot/gpg-error.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/grub-core/lib/libgcrypt_vboot/gpg-error.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,71 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2009, Free Software Foundation, Inc.
+ *  Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Emulate required GPG error enums for use by the MPI library in GRUB.
+ * This for Solaris Verified boot's use of libgcrypt functions in multiboot.
+ */
+
+#ifndef _GPG_ERROR_H
+#define	_GPG_ERROR_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/*
+ * libgcrypt error values and functions as adapted for GRUB.
+ */
+
+typedef enum {
+	GPG_ERR_NO_ERROR = 0,
+	GPG_ERR_INV_ARG = 45,
+	GPG_ERR_INTERNAL = 63,
+	GPG_ERR_INV_OBJ = 65,
+	GPG_ERR_TOO_SHORT = 66,
+	GPG_ERR_TOO_LARGE = 67,
+	GPG_ERR_MISSING_ERRNO = 16381,
+	GPG_ERR_UNKNOWN_ERRNO = 16382,
+	/* Error codes after this are for mapping grub_errno values: */
+#define	GPG_ERR_SYSTEM_ERROR	(1 << 15)
+	GPG_ERR_CODE_DIM = 65536	/* Highest error code + 1 */
+} gpg_err_code_t;
+
+typedef unsigned int gpg_error_t;
+/* Wrappers for the libgpg-error library. */
+typedef gpg_error_t gcry_error_t;
+typedef gpg_err_code_t gcry_err_code_t;
+
+gpg_err_code_t gpg_err_code_from_syserror(void);
+
+static inline gpg_error_t
+gcry_error(gcry_err_code_t code) {
+	return (code);
+}
+
+static inline gpg_error_t
+gpg_error_from_syserror(void) {
+	return (gpg_err_code_from_syserror());
+}
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _GPG_ERROR_H */
diff -r 68f95e015346 usr/src/grub/src/grub-core/lib/libgcrypt_vboot/stdint.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/grub-core/lib/libgcrypt_vboot/stdint.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,58 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Emulate required Solaris types for use by Solaris Verified Boot in GRUB.
+ */
+
+#ifndef _STDINT_H
+#define	_STDINT_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#ifndef _SIZE_T
+#define	_SIZE_T
+#if defined(__LP64__) || defined(_LP64)
+typedef unsigned long	size_t;
+#else
+typedef unsigned int	size_t;
+#endif
+#endif
+
+typedef unsigned int		int32_t;
+
+typedef signed long		ssize_t;
+typedef unsigned int		uint_t;
+typedef unsigned char		uchar_t;
+typedef unsigned short		ushort_t;
+#ifdef _LP64
+typedef unsigned long		uint64_t;
+#else
+typedef unsigned long long	uint64_t;
+#endif
+typedef unsigned int		uint32_t;
+typedef unsigned short		uint16_t;
+typedef unsigned char		uint8_t;
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _STDINT_H */
diff -r 68f95e015346 usr/src/grub/src/grub-core/lib/libgcrypt_vboot/stdio.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/grub-core/lib/libgcrypt_vboot/stdio.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,39 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Emulate required libgcrypt functions for use by the MPI library in GRUB.
+ * This for Solaris Verified boot's use of mpi functions in multiboot.
+ */
+
+#ifndef _STDIO_H
+#define	_STDIO_H
+
+#include <grub/file.h>	/* struct grub_file */
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+typedef struct grub_file FILE;
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _STDIO_H */
diff -r 68f95e015346 usr/src/grub/src/grub-core/lib/libgcrypt_vboot/string.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/grub-core/lib/libgcrypt_vboot/string.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,49 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2017, 2024, Oracle and/or its affiliates.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Emulate required libgcrypt functions for use by the MPI library in GRUB.
+ * This for Solaris Verified boot's use of libgcrypt functions in multiboot.
+ */
+
+
+#ifndef _STRING_H
+#define	_STRING_H
+
+#include <sys/types.h>	/* size_t */
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* gcrypt_util.c */
+size_t strlen(const char *s);
+
+/* referenced in g10lib.h */
+
+char *strchr(const char *s, int c);
+#define memcmp grub_memcmp
+#define memset grub_memset
+#define memmove grub_memmove
+#define memcpy grub_memcpy
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _STRING_H */
diff -r 68f95e015346 usr/src/grub/src/grub-core/lib/libgcrypt_vboot/strings.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/grub-core/lib/libgcrypt_vboot/strings.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,40 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Emulate required libgcrypt functions for use by the MPI library in GRUB.
+ * This for Solaris Verified boot's use of libgcrypt functions in multiboot.
+ */
+
+#ifndef _STRINGS_H
+#define	_STRINGS_H
+
+#include <sys/types.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* gcrypt_util.c */
+void bcopy(const void *src, void *dest, size_t n);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _STRINGS_H */
diff -r 68f95e015346 usr/src/grub/src/grub-core/lib/libgcrypt_vboot/sys/types.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/grub-core/lib/libgcrypt_vboot/sys/types.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,31 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Emulate required libgcrypt functions for use by the MPI library in GRUB.
+ * This is to wrap the libgcrypt functions for use by multiboot.
+ */
+
+#ifndef _SYS_TYPES_H
+#define	_SYS_TYPES_H
+
+#include <stdint.h>
+
+typedef enum {_B_FALSE = 0, _B_TRUE = 1} boolean_t;
+
+#endif	/* _SYS_TYPES_H */
diff -r 68f95e015346 usr/src/grub/src/grub-core/lib/libgcrypt_vboot/sys/verify_key2.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/grub-core/lib/libgcrypt_vboot/sys/verify_key2.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,35 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * This is a "placeholder" header file to take the place of the usual
+ * header file containing the ephmeral development public key for
+ * on_closed_bins builds, where the usr/closed source tree is not present.
+ * The usual verify_key2.h directory, keep/$(isainfo -k)/signing-material,
+ * should be specified with CPPFLAGS -I ahead of this directory.
+ */
+
+#ifndef _SYS_VERIFY_KEY2_H
+#define	_SYS_VERIFY_KEY2_H
+
+#include <sys/verified_boot.h>
+
+static const uchar_t internal_dn_hash[VERIFY_DN_HASH_LEN];
+static const uchar_t internal_modulus[VERIFY_MODULUS_LEN];
+
+#endif	/* _SYS_VERIFY_KEY2_H */
diff -r 68f95e015346 usr/src/grub/src/include/grub/i386/pc/smbios.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/include/grub/i386/pc/smbios.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,40 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef GRUB_SMBIOS_HEADER
+#define GRUB_SMBIOS_HEADER 1
+
+#include <grub/types.h>
+
+struct grub_smbios_entry_point {
+	grub_uint8_t	ep_anchor[4];
+	grub_uint8_t	ep_cksum;
+	grub_uint8_t	ep_length;
+	grub_uint8_t	ep_major;
+	grub_uint8_t	ep_minor;
+	grub_uint16_t	ep_maxsize;
+	grub_uint8_t	ep_rev;
+	grub_uint8_t	ep_formatted[5];
+	grub_uint8_t	ep_ianchor[5];
+	grub_uint8_t	ep_icksum;
+	grub_uint16_t	ep_table_length;
+	grub_uint32_t	ep_table_addr;
+	grub_uint16_t	ep_struct_count;
+	grub_uint8_t	ep_bcdrev;
+} __attribute__ ((packed));
+
+#endif
diff -r 68f95e015346 usr/src/grub/src/include/grub/util/modvers.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/include/grub/util/modvers.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,24 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2012, 2024, Oracle and/or its affiliates.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _GRUB_MODVERS_H
+#define _GRUB_MODVERS_H
+
+#define GRUB_MODULE_INTERFACE_VERSION	2
+#define	GRUB_MODULE_IF_VERSION_FILE "version.lst"
+#define	GRUB_MODULE_IF_NAME "module_interface_version"
+#endif
diff -r 68f95e015346 usr/src/grub/src/include/grub/util/version.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/include/grub/util/version.h	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,40 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2010, 2024, Oracle and/or its affiliates.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_UTIL_VERSION_HEADER
+#define GRUB_UTIL_VERSION_HEADER	1
+
+/*
+ * grub_util_version_info describes associates a versioning scheme to
+ * its comparing function. compare() is expected to return 0 if the two
+ * passed versions coincide, more than 0 if the first version is more recent
+ * than the second and less than 0 otherwise. (basically, compare behaves
+ * like strcmp()).
+ */
+struct grub_util_version_info
+{
+  const char *versioning_scheme;
+  int (*compare)(const char *, const char *);
+  const char *static_version;
+  int compulsory; /* If both source and dest MUST be present */
+};
+
+/* "solaris_version" handler. */
+extern struct grub_util_version_info grub_util_solaris_grub_version;
+
+#endif /* ! GRUB_UTIL_VERSION_HEADER */
diff -r 68f95e015346 usr/src/grub/src/util/grub-solvers.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/util/grub-solvers.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,281 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define	BBLK_EINFO_VERSION	(1)
+#define	EINFO_MAGIC		"EXTINFO"
+#define	EINFO_MAGIC_SIZE	(7)
+
+enum bblk_hash_types_t {
+	BBLK_NO_HASH = 0,
+	BBLK_HASH_MD5
+};
+
+/* Extra header preceding the payloads at the end of the bootblock. */
+typedef struct _bb_extra_header {
+	uint32_t	size;
+	uint32_t	checksum;
+} bb_header_ext_t;
+
+#pragma pack(1)
+typedef struct _extended_info {
+	char		magic[EINFO_MAGIC_SIZE];
+	uint8_t		version;
+	uint8_t		flags;
+	uint32_t	str_off;
+	uint16_t	str_size;
+	uint8_t		hash_type;
+	uint32_t	hash_off;
+	uint16_t	hash_size;
+	char		rsvd[32];
+} bblk_einfo_t;
+#pragma pack()
+
+typedef struct _hashing_function {
+	unsigned int	type;
+	unsigned int	size;
+	char		name[16];
+	void 		(*compute_hash)(void *, const void *, unsigned int);
+} bblk_hash_t;
+
+typedef struct _hashing_source {
+	unsigned char	*src_buf;
+	unsigned int	src_size;
+} bblk_hs_t;
+
+
+uint32_t compute_checksum(char *, uint32_t);
+int add_einfo(char *, char *, bblk_hs_t *, uint32_t, int, uint32_t *);
+int prepare_and_write_einfo(unsigned char *, char *, bblk_hs_t *,
+    uint32_t, uint32_t *, int);
+
+/*************************************************************************/
+
+void
+grub_md5_calc(void *output, const void *input, unsigned int inlen)
+{
+	grub_uint8_t ctx[GRUB_MD_MD5->contextsize];
+	unsigned char *digest;
+
+	GRUB_MD_MD5->init (ctx);
+	GRUB_MD_MD5->write (ctx, input, inlen);
+	digest = GRUB_MD_MD5->read (ctx);
+	GRUB_MD_MD5->final (ctx);
+	memcpy(output, digest, 0x10);
+}
+
+/*************************************************************************/
+
+bblk_hash_t	bblk_no_hash = {BBLK_NO_HASH, 0, "(no hash)", NULL};
+bblk_hash_t	bblk_md5_hash = {BBLK_HASH_MD5, 0x10, "MD5", grub_md5_calc};
+
+static int
+compute_hash(bblk_hs_t *hs, unsigned char *dest, bblk_hash_t *hash)
+{
+	if (hs == NULL || dest == NULL || hash == NULL)
+		return (-1);
+
+	hash->compute_hash(dest, hs->src_buf, hs->src_size);
+	return (0);
+}
+
+int
+prepare_and_write_einfo(unsigned char *dest, char *infostr, bblk_hs_t *hs,
+    uint32_t maxsize, uint32_t *used_space, int doit)
+{
+	uint16_t	hash_size;
+	uint32_t	hash_off;
+	unsigned char	*data;
+	bblk_einfo_t	*einfo = (bblk_einfo_t *)dest;
+	bblk_hash_t	*hashinfo = &bblk_md5_hash;
+
+	/*
+	 * 'dest' might be both containing the buffer we want to hash and
+	 * containing our einfo structure: delay any update of it after the
+	 * hashing has been calculated.
+	 */
+	hash_size = hashinfo->size;
+	hash_off = sizeof (bblk_einfo_t);
+
+	if (hash_off + hash_size > maxsize) {
+		(void) fprintf(stderr, gettext("Unable to add extended info, "
+		    "not enough space\n"));
+		return (-1);
+	}
+
+        if (doit) {
+		data = dest + hash_off;
+
+		if (compute_hash(hs, data, hashinfo) < 0) {
+			(void) fprintf(stderr, gettext("%s hash operation failed\n"),
+			    hashinfo->name);
+			einfo->hash_type = bblk_no_hash.type;
+			einfo->hash_size = bblk_no_hash.size;
+		} else {
+			einfo->hash_type = hashinfo->type;
+			einfo->hash_size = hashinfo->size;
+		}
+
+		(void) memcpy(einfo->magic, EINFO_MAGIC, EINFO_MAGIC_SIZE);
+		einfo->version = BBLK_EINFO_VERSION;
+		einfo->flags = 0;
+		einfo->hash_off = hash_off;
+		einfo->hash_size = hash_size;
+		einfo->str_off = einfo->hash_off + einfo->hash_size + 1;
+	}
+
+	if (infostr == NULL) {
+		(void) fprintf(stderr, gettext("Unable to add extended info, "
+		    "string is empty\n"));
+		return (-1);
+	}
+
+	if (doit)
+		einfo->str_size = strlen(infostr);
+
+	if (einfo->str_off + einfo->str_size > maxsize) {
+		(void) fprintf(stderr, gettext("Unable to add extended info, "
+		    "not enough space\n"));
+		return (-1);
+	}
+
+	if (!doit) {
+		*used_space = hash_off + hash_size + 1 + strlen(infostr);
+		return (0);
+	}
+
+	data = dest + einfo->str_off;
+	(void) memcpy(data, infostr, einfo->str_size);
+	*used_space = einfo->str_off + einfo->str_size;
+
+	return (0);
+}
+
+/*************************************************************************/
+
+/*
+ * Common functions to deal with the fake-multiboot encapsulation of the
+ * bootblock and the location of the extra information area.
+ */
+
+/* mboot checksum routine. */
+uint32_t
+compute_checksum(char *data, uint32_t size)
+{
+	uint32_t	*ck_ptr;
+	uint32_t	cksum = 0;
+	int		i;
+
+	ck_ptr = (uint32_t *)data;
+	for (i = 0; i < size; i += sizeof (uint32_t))
+		cksum += *ck_ptr++;
+
+	return (-cksum);
+}
+
+/*
+ * Given a pointer to the extra area, add the extended information structure
+ * encapsulated by a bb_header_ext_t structure.
+ */
+int
+add_einfo(char *extra, char *updt_str, bblk_hs_t *hs, uint32_t avail_space,
+    int doit, uint32_t *space_usedp)
+{
+	bb_header_ext_t	*ext_hdr;
+	unsigned char	*dest;
+	uint32_t	used_space;
+	int		ret;
+
+	assert(extra != NULL);
+
+	if (updt_str == NULL) {
+		return (1);
+	}
+
+	/* Reserve space for the extra header. */
+	ext_hdr = (bb_header_ext_t *)extra;
+	dest = (unsigned char *)extra + sizeof (*ext_hdr);
+	/* Place the extended information structure. */
+	ret = prepare_and_write_einfo(dest, updt_str, hs, avail_space,
+	    &used_space, doit);
+	if (ret != 0) {
+		if (doit)
+			(void) fprintf(stderr, gettext("Unable to write the extended "
+			    "versioning information\n"));
+		return(1);
+	}
+
+	if (!doit) {
+		if (space_usedp)
+			*space_usedp = ALIGN_UP(used_space, 8);
+		return (0);
+	}
+
+	/* Fill the extended information associated header. */
+	ext_hdr->size = ALIGN_UP(used_space, 8);
+	ext_hdr->checksum = compute_checksum((char *)dest, ext_hdr->size);
+	return (0);
+}
+
+/*************************************************************************/
+static void
+grub_solaris_get_size_with_versioning(char *core_img, size_t core_size,
+    size_t buflen, char *vers_str, size_t *new_core_size)
+{
+	bblk_hs_t       hs;
+	uint32_t        avail_space;
+	bb_header_ext_t *ext_hdr;
+	uint32_t	space = 0;
+
+        hs.src_buf = (unsigned char *)core_img;
+        hs.src_size = core_size;
+
+        avail_space = buflen - ALIGN_UP(core_size, 8);
+	ext_hdr = (bb_header_ext_t *)(core_img + ALIGN_UP(core_size, 8));
+	if (add_einfo((char *)ext_hdr, vers_str, &hs, avail_space, 0, &space)
+	    == 0) {
+		*new_core_size = ALIGN_UP(core_size, 8) + space +
+		    sizeof (*ext_hdr);
+		if (verbosity)
+			printf("Size of versioning info: %d\n",
+			    *new_core_size - core_size);
+	}
+}
+
+static void
+grub_solaris_add_versioning_payload(char *core_img, size_t core_size,
+    size_t buflen, char *vers_str)
+{
+	bblk_hs_t       hs;
+	uint32_t        avail_space;
+	bb_header_ext_t *ext_hdr;
+
+        hs.src_buf = (unsigned char *)core_img;
+        hs.src_size = core_size;
+
+        avail_space = buflen - ALIGN_UP(core_size, 8);
+	ext_hdr = (bb_header_ext_t *)(core_img + ALIGN_UP(core_size, 8));
+	if (add_einfo((char *)ext_hdr, vers_str, &hs, avail_space, 1, NULL)
+	    == 0) {
+		if (verbosity)
+			printf("Size before versioning: %d, after: %d\n",
+			    core_size, ALIGN_UP(core_size, 8) + ext_hdr->size +
+			    sizeof (*ext_hdr));
+	}
+}
+
+
diff -r 68f95e015346 usr/src/grub/src/util/grub-version-check.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/util/grub-version-check.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,289 @@
+/* grub-check-version.c - compare grub versioning information. */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2010, 2024, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <config.h>
+#include <grub/types.h>
+#include <grub/mm.h>
+#include <grub/misc.h>
+#include <grub/emu/misc.h>
+#include <grub/util/misc.h>
+#include <grub/util/version.h>
+#include <grub/i18n.h>
+
+#define _GNU_SOURCE	1
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+
+#include "progname.h"
+
+static struct option options[] =
+  {
+    {"source", required_argument, 0, 's'},
+    {"dest", required_argument, 0, 'd'},
+    {"type", required_argument, 0, 't'},
+    {"help", no_argument, 0, 'h'},
+    {"print", no_argument, 0, 'p'},
+    {"version", no_argument, 0, 'V'},
+    {"verbose", no_argument, 0, 'v'},
+    {0, 0, 0, 0}
+  };
+
+static struct grub_util_version_info grub_util_module_interface_version;
+
+static struct grub_util_version_info *grub_util_version_list[] =
+{
+  &grub_util_solaris_grub_version,
+  &grub_util_module_interface_version,
+  NULL
+};
+
+static char buf[1024];
+
+static void
+usage (int status)
+{
+  if (status)
+    fprintf (stderr,
+	     "Try ``%s --help'' for more information.\n", program_name);
+  else
+    printf ("\
+Usage: %s [PATH]\n\
+\n\
+Compares grub versioning information..\n\
+\n\
+  -s, --source=FILE         read version.lst from FILE.\n\
+  -d, --dest=FILE           read version.lst to compare to from FILE.\n\
+  -t, --type=(solaris_grub_version, module_interface_version)\n\
+                            versioning scheme to check.\n\
+  -h, --help                display this message and exit\n\
+  -p, --print               print the version obtained from source file (give with -s)\n\
+  -V, --version             print version information and exit\n\
+  -v, --verbose             print the script as it is being processed\n\
+\n\
+Report bugs to <%s>.\n\
+", program_name,
+	    PACKAGE_BUGREPORT);
+  exit (status);
+}
+
+static char *
+get_version_from_file (FILE *fp, const char *version_type)
+{
+  char *version = NULL;
+
+  if (fp == NULL)
+    return NULL;
+
+  if (version_type == NULL)
+    return NULL;
+
+  /*
+   * Loop through the various version entries looking for the requested one.
+   * Keep looping after finding the first occurrence because the last present
+   * entry overrides the previous ones.
+   */
+  while (fgets (buf, sizeof (buf), fp))
+    {
+       char *p;
+
+       buf[strlen (buf) - 1] = '\0';
+
+       p = strchr (buf, ':');
+       if (!p)
+         continue;
+
+       *p++ = '\0';
+
+       /* Is this the version we want? */
+       if (strcmp (buf, version_type) != 0)
+         continue;
+
+       while (*p && isspace (*p))
+         p++;
+
+       if (! *p) 
+         continue;
+
+       if (version != NULL)
+         free (version);
+
+       version = xstrdup(p);
+     }
+
+   return version;
+}
+
+int
+main (int argc, char *argv[])
+{
+  int i = 0;
+  int do_print_only = 0;
+  char *source_version;
+  char *dest_version;
+  char *versioning_type = NULL;
+  FILE *source_fp = NULL;
+  FILE *dest_fp = NULL;
+  struct grub_util_version_info *verp;
+
+
+
+  grub_util_host_init(&argc, &argv);
+
+  /* Check for options.  */
+  while (1)
+    {
+      int c = getopt_long (argc, argv, "s:d:t:hpvV", options, 0);
+
+      if (c == -1)
+	break;
+      else
+	switch (c)
+	  {
+          case 's':
+            grub_util_info ("source file is: %s", optarg);
+            source_fp = fopen (optarg, "r");
+            if (source_fp == NULL)
+                grub_util_error (_("cannot open %s"), optarg);
+            break;
+          case 'd':
+            grub_util_info ("compare to file is: %s", optarg);
+            dest_fp = fopen (optarg, "r");
+            if (dest_fp == NULL)
+                grub_util_error (_("cannot open %s"), optarg);
+            break;
+          case 't':
+            versioning_type = xstrdup(optarg);
+            break;
+	  case 'h':
+	    usage (0);
+	    break;
+	  case 'p':
+  	    do_print_only = 1;
+	    break;
+	  case 'V':
+	    printf ("%s (%s) %s\n", program_name, PACKAGE_NAME, PACKAGE_VERSION);
+	    return 0;
+
+	  case 'v':
+	    verbosity++;
+	    break;
+
+	  default:
+	    usage (1);
+	    break;
+	  }
+    }
+
+  if (versioning_type == NULL)
+    grub_util_error (_("no versioning scheme specified"));
+
+  while ((verp = grub_util_version_list[i++]) != NULL)
+    if (strcmp(verp->versioning_scheme, versioning_type) == 0)
+      break;
+
+  if (verp == NULL)
+    grub_util_error (_("unsupported versioning scheme specified"));
+
+  if (source_fp == NULL && verp->static_version != NULL)
+    source_version = xstrdup(verp->static_version);
+  else
+    source_version = get_version_from_file (source_fp, versioning_type);
+
+  if (do_print_only)
+    {
+      if (source_version == NULL)
+        {
+          grub_util_info ("could not find source matching type");
+          exit(1);
+        }
+      printf("%s\n", source_version);
+      exit (0);
+    }
+
+  dest_version = get_version_from_file (dest_fp, versioning_type);
+
+  if (source_version == NULL || dest_version == NULL)
+    {
+      if (verp->compulsory)
+	{
+	  printf("no\n");
+	  return 0;
+	}
+
+      if (source_version == NULL)
+        grub_util_info("source was NULL");
+
+      if (dest_version == NULL)
+        grub_util_info("dest was NULL");
+
+      if (source_version == NULL && dest_version != NULL)
+        printf("no\n");
+      else if (source_version != NULL && dest_version == NULL)
+          printf("yes\n");
+      else /* both are NULL */
+          printf("no\n");
+    }
+  else
+    {
+     grub_util_info ("going to compare %s with %s", source_version,
+                     dest_version);
+      if (verp->compare (source_version, dest_version) >= 0)
+        printf("yes\n");
+      else
+        printf("no\n");
+    }
+
+  return 0;
+}
+
+static int
+compare_modintf_version (const char *a, const char *b)
+{
+  long ai, bi;
+
+  errno = 0;
+  ai = strtoul(a, 0, 0);
+  bi = strtoul(b, 0, 0);
+
+  if (errno != 0)
+    return -1;
+
+  if (ai != bi)
+    return -1;
+  return 0;
+}
+
+#include <grub/util/modvers.h>
+/* 2 levels of macros are needed to stringify the numeric constant in
+   GRUB_MODULE_INTERFACE_VERSION */
+#define STRINGIFY(x) STRINGIFY2(x)
+#define STRINGIFY2(x) #x
+static struct grub_util_version_info grub_util_module_interface_version =
+{
+  "module_interface_version",
+  compare_modintf_version,
+  STRINGIFY(GRUB_MODULE_INTERFACE_VERSION),
+  1
+};
+
diff -r 68f95e015346 usr/src/grub/src/util/grub.d/10_solaris.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/util/grub.d/10_solaris.in	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,8 @@
+#!/usr/bin/python3.11
+#
+# Copyright (c) 2012, 2024, Oracle and/or its affiliates.
+#
+from bootmgmt.backend.loader.grub2 import GRUB2MenuEntryEmitter
+emitter = GRUB2MenuEntryEmitter(force_grub2=True)
+emitter.target = '@target_cpu@-@platform@'
+emitter.emit_entries()
diff -r 68f95e015346 usr/src/grub/src/util/solaris-version.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/usr/src/grub/src/util/solaris-version.c	Mon Aug 12 16:01:42 2024 -0700
@@ -0,0 +1,159 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <config.h>
+
+#include <grub/mm.h>
+#include <grub/types.h>
+#include <grub/misc.h>
+#include <grub/util/misc.h>
+#include <grub/util/version.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+static int compare_version (const char *, const char *);
+
+struct grub_util_version_info grub_util_solaris_grub_version =
+{
+  "solaris_grub_version",
+  compare_version,
+  NULL,
+  0
+};
+
+/*
+ * compare_dotted_version()
+ * Compares two strings with an arbitrary long number of dot-separated numbers.
+ * Returns:	0  - if the version numbers are equal
+ *             >0  - if str1 version number is more recent than str2
+ *             <0  - if str2 version number is more recent than str1
+ *
+ * Comparison is done field by field, by retrieving an unsigned integer value,
+ * (missing fields are assumed as 0, but explict zeroes take precedence) so:
+ *   4.1.2.11 > 4.1.2.2 > 4.1.2.0 > 4.1.2
+ *
+ * where ">" means "more recent than".
+ */
+static int
+compare_dotted_version(const char *str1, const char *str2)
+{
+  int  retval = 0;
+  char *verstr1, *verstr2, *freeptr1, *freeptr2;
+  char *parsep1, *parsep2;
+  int val_str1, val_str2;
+
+  freeptr1 = verstr1 = xstrdup (str1);
+  freeptr2 = verstr2 = xstrdup (str2);
+
+  while (verstr1 != NULL && verstr2 != NULL)
+    {
+      parsep1 = strsep (&verstr1, ".");
+      parsep2 = strsep (&verstr2, ".");
+
+      val_str1 = atoi (parsep1);
+      val_str2 = atoi (parsep2);
+
+      retval = val_str1 - val_str2;
+      if (retval != 0)
+        goto out; 
+    }
+
+  /* Common portion of the version string is equal. */
+  if (verstr1 == NULL && verstr2 != NULL)
+    retval = -1;
+  if (verstr2 == NULL && verstr1 != NULL)
+    retval = 1;
+
+out:
+  free (freeptr1);
+  free (freeptr2);
+  grub_util_info("comparing dotted version %s %s returning %d",
+                 str1, str2, retval);
+  return (retval);
+}
+
+/*
+ * compare_timestamps()
+ * Currently, timestamp is in %Y%m%dT%H%M%SZ format in UTC, which means that
+ * we can simply do a lexicographic comparison to know which one is the most
+ * recent.
+ *
+ * Returns:   0  - if timestamps coincide
+ *            1  - if the timestamp in str1 is more recent
+ *            2  - if the timestamp in str2 is more recent
+ */
+static int
+compare_timestamps (const char *str1, const char *str2)
+{
+  int  retval;
+
+  retval = strcmp (str1, str2);
+  grub_util_info("comparing timestamps %s %s returning %d", str1, str2, retval);
+  return (retval);
+}
+
+/*
+ * compare_version()
+ * Given two solaris versions, compare the two and returns which one is more
+ * "recent". Comparison is based on dotted version number fields and a
+ * timestamp.
+ *
+ * Returns:     0   - if the two versions coincide
+ *             >0   - if the version in str1 is more recent
+ *             <0   - if the version in str2 is more recent
+ */
+static int
+compare_version (const char *str1, const char *str2)
+{
+  int retval = 0;
+  char *verstr1, *verstr2, *freeptr1, *freeptr2;
+  char *parsep1, *parsep2;
+
+  freeptr1 = verstr1 = xstrdup(str1);
+  freeptr2 = verstr2 = xstrdup(str2);
+
+  parsep1 = verstr1;
+  parsep2 = verstr2;
+
+  while (parsep1 != NULL && parsep2 != NULL)
+    {
+      parsep1 = strsep (&verstr1, ",:-");
+      parsep2 = strsep (&verstr2, ",:-");
+
+     /* verstr1 or verstr2 will be NULL before parsep1 or parsep2. */
+     if (verstr1 == NULL || verstr2 == NULL)
+       {
+         retval = compare_timestamps (parsep1, parsep2);
+         goto out;
+       }
+
+     retval = compare_dotted_version (parsep1, parsep2);
+     if (retval == 0)
+       continue;
+     else
+       goto out;
+    }
+
+out:
+  free (freeptr1);
+  free (freeptr2);
+  return (retval);
+}
